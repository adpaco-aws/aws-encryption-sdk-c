
<html>
<head>
<title>verification/cbmc/aws-c-common/include/aws/common/atomics.h</title>
<link rel="stylesheet" type="text/css" href="../../../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 #ifndef <a href="atomics.h.html#2">AWS_COMMON_ATOMICS_H</a></div><div id="2" class="line none">    2 #define <a href="atomics.h.html#2">AWS_COMMON_ATOMICS_H</a></div><div id="3" class="line none">    3 </div><div id="4" class="line none">    4 #include &lt;aws/common/common.h&gt;</div><div id="5" class="line none">    5 </div><div id="6" class="line none">    6 /**</div><div id="7" class="line none">    7  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.</div><div id="8" class="line none">    8  * SPDX-License-Identifier: Apache-2.0.</div><div id="9" class="line none">    9  */</div><div id="10" class="line none">   10 </div><div id="11" class="line none">   11 /**</div><div id="12" class="line none">   12  * struct aws_atomic_var represents an atomic variable - a value which can hold an integer or pointer</div><div id="13" class="line none">   13  * that can be manipulated atomically. struct aws_atomic_vars should normally only be manipulated</div><div id="14" class="line none">   14  * with atomics methods defined in this header.</div><div id="15" class="line none">   15  */</div><div id="16" class="line none">   16 struct <a href="atomics.h.html#16">aws_atomic_var</a> {</div><div id="17" class="line none">   17     void *<a href="atomics.h.html#17">value</a>;</div><div id="18" class="line none">   18 };</div><div id="19" class="line none">   19 /* Helpers for extracting the integer and pointer values from aws_atomic_var. */</div><div id="20" class="line none">   20 #define <a href="atomics.h.html#20">AWS_ATOMIC_VAR_PTRVAL</a>(var) ((var)-&gt;<a href="atomics.h.html#17">value</a>)</div><div id="21" class="line none">   21 #define <a href="atomics.h.html#21">AWS_ATOMIC_VAR_INTVAL</a>(var) (*(<a href="atomics_gnu.inl.html#26">aws_atomic_impl_int_t</a> *)(var))</div><div id="22" class="line none">   22 </div><div id="23" class="line none">   23 /*</div><div id="24" class="line none">   24  * This enumeration specifies the memory ordering properties requested for a particular</div><div id="25" class="line none">   25  * atomic operation. The atomic operation may provide stricter ordering than requested.</div><div id="26" class="line none">   26  * Note that, within a single thread, all operations are still sequenced (that is, a thread</div><div id="27" class="line none">   27  * sees its own atomic writes and reads happening in program order, but other threads may</div><div id="28" class="line none">   28  * disagree on this ordering).</div><div id="29" class="line none">   29  *</div><div id="30" class="line none">   30  * The behavior of these memory orderings are the same as in the C11 atomics API; however,</div><div id="31" class="line none">   31  * we only implement a subset that can be portably implemented on the compilers we target.</div><div id="32" class="line none">   32  */</div><div id="33" class="line none">   33 </div><div id="34" class="line none">   34 enum <a href="atomics.h.html#34">aws_memory_order</a> {</div><div id="35" class="line none">   35     /**</div><div id="36" class="line none">   36      * No particular ordering constraints are guaranteed relative to other</div><div id="37" class="line none">   37      * operations at all; we merely ensure that the operation itself is atomic.</div><div id="38" class="line none">   38      */</div><div id="39" class="line none">   39     <a href="atomics.h.html#39">aws_memory_order_relaxed</a> = 0,</div><div id="40" class="line none">   40     /* aws_memory_order_consume - not currently implemented */</div><div id="41" class="line none">   41 </div><div id="42" class="line none">   42     /**</div><div id="43" class="line none">   43      * Specifies acquire ordering. No reads or writes on the current thread can be</div><div id="44" class="line none">   44      * reordered to happen before this operation. This is typically paired with a release</div><div id="45" class="line none">   45      * ordering; any writes that happened on the releasing operation will be visible</div><div id="46" class="line none">   46      * after the paired acquire operation.</div><div id="47" class="line none">   47      *</div><div id="48" class="line none">   48      * Acquire ordering is only meaningful on load or load-store operations.</div><div id="49" class="line none">   49      */</div><div id="50" class="line none">   50     <a href="atomics.h.html#50">aws_memory_order_acquire</a> = 2, /* leave a spot for consume if we ever add it */</div><div id="51" class="line none">   51 </div><div id="52" class="line none">   52     /**</div><div id="53" class="line none">   53      * Specifies release order. No reads or writes can be reordered to come after this</div><div id="54" class="line none">   54      * operation. Typically paired with an acquire operation.</div><div id="55" class="line none">   55      *</div><div id="56" class="line none">   56      * Release ordering is only meaningful on store or load-store operations.</div><div id="57" class="line none">   57      */</div><div id="58" class="line none">   58     <a href="atomics.h.html#58">aws_memory_order_release</a>,</div><div id="59" class="line none">   59 </div><div id="60" class="line none">   60     /**</div><div id="61" class="line none">   61      * Specifies acquire-release order; if this operation acts as a load, it acts as an</div><div id="62" class="line none">   62      * acquire operation; if it acts as a store, it acts as a release operation; if it's</div><div id="63" class="line none">   63      * a load-store, it does both.</div><div id="64" class="line none">   64      */</div><div id="65" class="line none">   65     <a href="atomics.h.html#65">aws_memory_order_acq_rel</a>,</div><div id="66" class="line none">   66 </div><div id="67" class="line none">   67     /*</div><div id="68" class="line none">   68      * Specifies sequentially consistent order. This behaves as acq_rel, but in addition,</div><div id="69" class="line none">   69      * all seq_cst operations appear to occur in some globally consistent order.</div><div id="70" class="line none">   70      *</div><div id="71" class="line none">   71      * TODO: Figure out how to correctly implement this in MSVC. It appears that interlocked</div><div id="72" class="line none">   72      * functions provide only acq_rel ordering.</div><div id="73" class="line none">   73      */</div><div id="74" class="line none">   74     <a href="atomics.h.html#74">aws_memory_order_seq_cst</a></div><div id="75" class="line none">   75 };</div><div id="76" class="line none">   76 </div><div id="77" class="line none">   77 /**</div><div id="78" class="line none">   78  * Statically initializes an aws_atomic_var to a given size_t value.</div><div id="79" class="line none">   79  */</div><div id="80" class="line none">   80 #define <a href="atomics.h.html#80">AWS_ATOMIC_INIT_INT</a>(x)                                                                                         \</div><div id="81" class="line none">   81     { .<a href="atomics.h.html#17">value</a> = (void *)(uintptr_t)(x) }</div><div id="82" class="line none">   82 </div><div id="83" class="line none">   83 /**</div><div id="84" class="line none">   84  * Statically initializes an aws_atomic_var to a given void * value.</div><div id="85" class="line none">   85  */</div><div id="86" class="line none">   86 #define <a href="atomics.h.html#86">AWS_ATOMIC_INIT_PTR</a>(x)                                                                                         \</div><div id="87" class="line none">   87     { .<a href="atomics.h.html#17">value</a> = (void *)(x) }</div><div id="88" class="line none">   88 </div><div id="89" class="line none">   89 AWS_EXTERN_C_BEGIN</div><div id="90" class="line none">   90 </div><div id="91" class="line none">   91 /*</div><div id="92" class="line none">   92  * Note: We do not use the C11 atomics API; this is because we want to make sure the representation</div><div id="93" class="line none">   93  * (and behavior) of atomic values is consistent, regardless of what --std= flag you pass to your compiler.</div><div id="94" class="line none">   94  * Since C11 atomics can silently introduce locks, we run the risk of creating such ABI inconsistencies</div><div id="95" class="line none">   95  * if we decide based on compiler features which atomics API to use, and in practice we expect to have</div><div id="96" class="line none">   96  * either the GNU or MSVC atomics anyway.</div><div id="97" class="line none">   97  *</div><div id="98" class="line none">   98  * As future work, we could test to see if the C11 atomics API on this platform behaves consistently</div><div id="99" class="line none">   99  * with the other APIs and use it if it does.</div><div id="100" class="line none">  100  */</div><div id="101" class="line none">  101 </div><div id="102" class="line none">  102 /**</div><div id="103" class="line none">  103  * Initializes an atomic variable with an integer value. This operation should be done before any</div><div id="104" class="line none">  104  * other operations on this atomic variable, and must be done before attempting any parallel operations.</div><div id="105" class="line none">  105  *</div><div id="106" class="line none">  106  * This operation does not imply a barrier. Ensure that you use an acquire-release barrier (or stronger)</div><div id="107" class="line none">  107  * when communicating the fact that initialization is complete to the other thread. Launching the thread</div><div id="108" class="line none">  108  * implies a sufficiently strong barrier.</div><div id="109" class="line none">  109  */</div><div id="110" class="line none">  110 AWS_STATIC_IMPL</div><div id="111" class="line none">  111 void <a href="atomics_gnu.inl.html#50">aws_atomic_init_int</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n);</div><div id="112" class="line none">  112 </div><div id="113" class="line none">  113 /**</div><div id="114" class="line none">  114  * Initializes an atomic variable with a pointer value. This operation should be done before any</div><div id="115" class="line none">  115  * other operations on this atomic variable, and must be done before attempting any parallel operations.</div><div id="116" class="line none">  116  *</div><div id="117" class="line none">  117  * This operation does not imply a barrier. Ensure that you use an acquire-release barrier (or stronger)</div><div id="118" class="line none">  118  * when communicating the fact that initialization is complete to the other thread. Launching the thread</div><div id="119" class="line none">  119  * implies a sufficiently strong barrier.</div><div id="120" class="line none">  120  */</div><div id="121" class="line none">  121 AWS_STATIC_IMPL</div><div id="122" class="line none">  122 void <a href="atomics_gnu.inl.html#59">aws_atomic_init_ptr</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, void *p);</div><div id="123" class="line none">  123 </div><div id="124" class="line none">  124 /**</div><div id="125" class="line none">  125  * Reads an atomic var as an integer, using the specified ordering, and returns the result.</div><div id="126" class="line none">  126  */</div><div id="127" class="line none">  127 AWS_STATIC_IMPL</div><div id="128" class="line none">  128 size_t <a href="atomics_gnu.inl.html#67">aws_atomic_load_int_explicit</a>(volatile const struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, enum <a href="atomics.h.html#34">aws_memory_order</a> memory_order);</div><div id="129" class="line none">  129 </div><div id="130" class="line none">  130 /**</div><div id="131" class="line none">  131  * Reads an atomic var as an integer, using sequentially consistent ordering, and returns the result.</div><div id="132" class="line none">  132  */</div><div id="133" class="line none">  133 AWS_STATIC_IMPL</div><div id="134" class="line none">  134 size_t <a href="atomics.inl.html#18">aws_atomic_load_int</a>(volatile const struct <a href="atomics.h.html#16">aws_atomic_var</a> *var);</div><div id="135" class="line none">  135 /**</div><div id="136" class="line none">  136  * Reads an atomic var as a pointer, using the specified ordering, and returns the result.</div><div id="137" class="line none">  137  */</div><div id="138" class="line none">  138 AWS_STATIC_IMPL</div><div id="139" class="line none">  139 void *<a href="atomics_gnu.inl.html#75">aws_atomic_load_ptr_explicit</a>(volatile const struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, enum <a href="atomics.h.html#34">aws_memory_order</a> memory_order);</div><div id="140" class="line none">  140 </div><div id="141" class="line none">  141 /**</div><div id="142" class="line none">  142  * Reads an atomic var as a pointer, using sequentially consistent ordering, and returns the result.</div><div id="143" class="line none">  143  */</div><div id="144" class="line none">  144 AWS_STATIC_IMPL</div><div id="145" class="line none">  145 void *<a href="atomics.inl.html#26">aws_atomic_load_ptr</a>(volatile const struct <a href="atomics.h.html#16">aws_atomic_var</a> *var);</div><div id="146" class="line none">  146 </div><div id="147" class="line none">  147 /**</div><div id="148" class="line none">  148  * Stores an integer into an atomic var, using the specified ordering.</div><div id="149" class="line none">  149  */</div><div id="150" class="line none">  150 AWS_STATIC_IMPL</div><div id="151" class="line none">  151 void <a href="atomics_gnu.inl.html#83">aws_atomic_store_int_explicit</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n, enum <a href="atomics.h.html#34">aws_memory_order</a> memory_order);</div><div id="152" class="line none">  152 </div><div id="153" class="line none">  153 /**</div><div id="154" class="line none">  154  * Stores an integer into an atomic var, using sequentially consistent ordering.</div><div id="155" class="line none">  155  */</div><div id="156" class="line none">  156 AWS_STATIC_IMPL</div><div id="157" class="line none">  157 void <a href="atomics.inl.html#34">aws_atomic_store_int</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n);</div><div id="158" class="line none">  158 </div><div id="159" class="line none">  159 /**</div><div id="160" class="line none">  160  * Stores a pointer into an atomic var, using the specified ordering.</div><div id="161" class="line none">  161  */</div><div id="162" class="line none">  162 AWS_STATIC_IMPL</div><div id="163" class="line none">  163 void <a href="atomics_gnu.inl.html#91">aws_atomic_store_ptr_explicit</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, void *p, enum <a href="atomics.h.html#34">aws_memory_order</a> memory_order);</div><div id="164" class="line none">  164 </div><div id="165" class="line none">  165 /**</div><div id="166" class="line none">  166  * Stores a pointer into an atomic var, using sequentially consistent ordering.</div><div id="167" class="line none">  167  */</div><div id="168" class="line none">  168 AWS_STATIC_IMPL</div><div id="169" class="line none">  169 void <a href="atomics.inl.html#42">aws_atomic_store_ptr</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, void *p);</div><div id="170" class="line none">  170 </div><div id="171" class="line none">  171 /**</div><div id="172" class="line none">  172  * Exchanges an integer with the value in an atomic_var, using the specified ordering.</div><div id="173" class="line none">  173  * Returns the value that was previously in the atomic_var.</div><div id="174" class="line none">  174  */</div><div id="175" class="line none">  175 AWS_STATIC_IMPL</div><div id="176" class="line none">  176 size_t <a href="atomics_gnu.inl.html#100">aws_atomic_exchange_int_explicit</a>(</div><div id="177" class="line none">  177     volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var,</div><div id="178" class="line none">  178     size_t n,</div><div id="179" class="line none">  179     enum <a href="atomics.h.html#34">aws_memory_order</a> memory_order);</div><div id="180" class="line none">  180 </div><div id="181" class="line none">  181 /**</div><div id="182" class="line none">  182  * Exchanges an integer with the value in an atomic_var, using sequentially consistent ordering.</div><div id="183" class="line none">  183  * Returns the value that was previously in the atomic_var.</div><div id="184" class="line none">  184  */</div><div id="185" class="line none">  185 AWS_STATIC_IMPL</div><div id="186" class="line none">  186 size_t <a href="atomics.inl.html#51">aws_atomic_exchange_int</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n);</div><div id="187" class="line none">  187 </div><div id="188" class="line none">  188 /**</div><div id="189" class="line none">  189  * Exchanges a pointer with the value in an atomic_var, using the specified ordering.</div><div id="190" class="line none">  190  * Returns the value that was previously in the atomic_var.</div><div id="191" class="line none">  191  */</div><div id="192" class="line none">  192 AWS_STATIC_IMPL</div><div id="193" class="line none">  193 void *<a href="atomics_gnu.inl.html#112">aws_atomic_exchange_ptr_explicit</a>(</div><div id="194" class="line none">  194     volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var,</div><div id="195" class="line none">  195     void *p,</div><div id="196" class="line none">  196     enum <a href="atomics.h.html#34">aws_memory_order</a> memory_order);</div><div id="197" class="line none">  197 </div><div id="198" class="line none">  198 /**</div><div id="199" class="line none">  199  * Exchanges an integer with the value in an atomic_var, using sequentially consistent ordering.</div><div id="200" class="line none">  200  * Returns the value that was previously in the atomic_var.</div><div id="201" class="line none">  201  */</div><div id="202" class="line none">  202 AWS_STATIC_IMPL</div><div id="203" class="line none">  203 void *<a href="atomics.inl.html#60">aws_atomic_exchange_ptr</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, void *p);</div><div id="204" class="line none">  204 </div><div id="205" class="line none">  205 /**</div><div id="206" class="line none">  206  * Atomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set</div><div id="207" class="line none">  207  * to the value in *var. On success, the memory ordering used was order_success; otherwise, it was order_failure.</div><div id="208" class="line none">  208  * order_failure must be no stronger than order_success, and must not be release or acq_rel.</div><div id="209" class="line none">  209  * Returns true if the compare was successful and the variable updated to desired.</div><div id="210" class="line none">  210  */</div><div id="211" class="line none">  211 AWS_STATIC_IMPL</div><div id="212" class="line none">  212 bool <a href="atomics_gnu.inl.html#125">aws_atomic_compare_exchange_int_explicit</a>(</div><div id="213" class="line none">  213     volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var,</div><div id="214" class="line none">  214     size_t *expected,</div><div id="215" class="line none">  215     size_t desired,</div><div id="216" class="line none">  216     enum <a href="atomics.h.html#34">aws_memory_order</a> order_success,</div><div id="217" class="line none">  217     enum <a href="atomics.h.html#34">aws_memory_order</a> order_failure);</div><div id="218" class="line none">  218 </div><div id="219" class="line none">  219 /**</div><div id="220" class="line none">  220  * Atomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set</div><div id="221" class="line none">  221  * to the value in *var. Uses sequentially consistent memory ordering, regardless of success or failure.</div><div id="222" class="line none">  222  * Returns true if the compare was successful and the variable updated to desired.</div><div id="223" class="line none">  223  */</div><div id="224" class="line none">  224 AWS_STATIC_IMPL</div><div id="225" class="line none">  225 bool <a href="atomics.inl.html#70">aws_atomic_compare_exchange_int</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t *expected, size_t desired);</div><div id="226" class="line none">  226 </div><div id="227" class="line none">  227 /**</div><div id="228" class="line none">  228  * Atomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set</div><div id="229" class="line none">  229  * to the value in *var. On success, the memory ordering used was order_success; otherwise, it was order_failure.</div><div id="230" class="line none">  230  * order_failure must be no stronger than order_success, and must not be release or acq_rel.</div><div id="231" class="line none">  231  * Returns true if the compare was successful and the variable updated to desired.</div><div id="232" class="line none">  232  */</div><div id="233" class="line none">  233 AWS_STATIC_IMPL</div><div id="234" class="line none">  234 bool <a href="atomics_gnu.inl.html#146">aws_atomic_compare_exchange_ptr_explicit</a>(</div><div id="235" class="line none">  235     volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var,</div><div id="236" class="line none">  236     void **expected,</div><div id="237" class="line none">  237     void *desired,</div><div id="238" class="line none">  238     enum <a href="atomics.h.html#34">aws_memory_order</a> order_success,</div><div id="239" class="line none">  239     enum <a href="atomics.h.html#34">aws_memory_order</a> order_failure);</div><div id="240" class="line none">  240 </div><div id="241" class="line none">  241 /**</div><div id="242" class="line none">  242  * Atomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set</div><div id="243" class="line none">  243  * to the value in *var. Uses sequentially consistent memory ordering, regardless of success or failure.</div><div id="244" class="line none">  244  * Returns true if the compare was successful and the variable updated to desired.</div><div id="245" class="line none">  245  */</div><div id="246" class="line none">  246 AWS_STATIC_IMPL</div><div id="247" class="line none">  247 bool <a href="atomics.inl.html#81">aws_atomic_compare_exchange_ptr</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, void **expected, void *desired);</div><div id="248" class="line none">  248 </div><div id="249" class="line none">  249 /**</div><div id="250" class="line none">  250  * Atomically adds n to *var, and returns the previous value of *var.</div><div id="251" class="line none">  251  */</div><div id="252" class="line none">  252 AWS_STATIC_IMPL</div><div id="253" class="line none">  253 size_t <a href="atomics_gnu.inl.html#165">aws_atomic_fetch_add_explicit</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n, enum <a href="atomics.h.html#34">aws_memory_order</a> <a href="../../../../sources/openssl/ec_override.c.html#30">order</a>);</div><div id="254" class="line none">  254 </div><div id="255" class="line none">  255 /**</div><div id="256" class="line none">  256  * Atomically subtracts n from *var, and returns the previous value of *var.</div><div id="257" class="line none">  257  */</div><div id="258" class="line none">  258 AWS_STATIC_IMPL</div><div id="259" class="line none">  259 size_t <a href="atomics_gnu.inl.html#173">aws_atomic_fetch_sub_explicit</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n, enum <a href="atomics.h.html#34">aws_memory_order</a> <a href="../../../../sources/openssl/ec_override.c.html#30">order</a>);</div><div id="260" class="line none">  260 </div><div id="261" class="line none">  261 /**</div><div id="262" class="line none">  262  * Atomically ORs n with *var, and returns the previous value of *var.</div><div id="263" class="line none">  263  */</div><div id="264" class="line none">  264 AWS_STATIC_IMPL</div><div id="265" class="line none">  265 size_t <a href="atomics_gnu.inl.html#181">aws_atomic_fetch_or_explicit</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n, enum <a href="atomics.h.html#34">aws_memory_order</a> <a href="../../../../sources/openssl/ec_override.c.html#30">order</a>);</div><div id="266" class="line none">  266 </div><div id="267" class="line none">  267 /**</div><div id="268" class="line none">  268  * Atomically ANDs n with *var, and returns the previous value of *var.</div><div id="269" class="line none">  269  */</div><div id="270" class="line none">  270 AWS_STATIC_IMPL</div><div id="271" class="line none">  271 size_t <a href="atomics_gnu.inl.html#189">aws_atomic_fetch_and_explicit</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n, enum <a href="atomics.h.html#34">aws_memory_order</a> <a href="../../../../sources/openssl/ec_override.c.html#30">order</a>);</div><div id="272" class="line none">  272 </div><div id="273" class="line none">  273 /**</div><div id="274" class="line none">  274  * Atomically XORs n with *var, and returns the previous value of *var.</div><div id="275" class="line none">  275  */</div><div id="276" class="line none">  276 AWS_STATIC_IMPL</div><div id="277" class="line none">  277 size_t <a href="atomics_gnu.inl.html#197">aws_atomic_fetch_xor_explicit</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n, enum <a href="atomics.h.html#34">aws_memory_order</a> <a href="../../../../sources/openssl/ec_override.c.html#30">order</a>);</div><div id="278" class="line none">  278 </div><div id="279" class="line none">  279 /**</div><div id="280" class="line none">  280  * Atomically adds n to *var, and returns the previous value of *var.</div><div id="281" class="line none">  281  * Uses sequentially consistent ordering.</div><div id="282" class="line none">  282  */</div><div id="283" class="line none">  283 AWS_STATIC_IMPL</div><div id="284" class="line none">  284 size_t <a href="atomics.inl.html#91">aws_atomic_fetch_add</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n);</div><div id="285" class="line none">  285 </div><div id="286" class="line none">  286 /**</div><div id="287" class="line none">  287  * Atomically subtracts n from *var, and returns the previous value of *var.</div><div id="288" class="line none">  288  * Uses sequentially consistent ordering.</div><div id="289" class="line none">  289  */</div><div id="290" class="line none">  290 AWS_STATIC_IMPL</div><div id="291" class="line none">  291 size_t <a href="atomics.inl.html#100">aws_atomic_fetch_sub</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n);</div><div id="292" class="line none">  292 </div><div id="293" class="line none">  293 /**</div><div id="294" class="line none">  294  * Atomically ands n into *var, and returns the previous value of *var.</div><div id="295" class="line none">  295  * Uses sequentially consistent ordering.</div><div id="296" class="line none">  296  */</div><div id="297" class="line none">  297 AWS_STATIC_IMPL</div><div id="298" class="line none">  298 size_t <a href="atomics.inl.html#109">aws_atomic_fetch_and</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n);</div><div id="299" class="line none">  299 </div><div id="300" class="line none">  300 /**</div><div id="301" class="line none">  301  * Atomically ors n into *var, and returns the previous value of *var.</div><div id="302" class="line none">  302  * Uses sequentially consistent ordering.</div><div id="303" class="line none">  303  */</div><div id="304" class="line none">  304 AWS_STATIC_IMPL</div><div id="305" class="line none">  305 size_t <a href="atomics.inl.html#118">aws_atomic_fetch_or</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n);</div><div id="306" class="line none">  306 </div><div id="307" class="line none">  307 /**</div><div id="308" class="line none">  308  * Atomically xors n into *var, and returns the previous value of *var.</div><div id="309" class="line none">  309  * Uses sequentially consistent ordering.</div><div id="310" class="line none">  310  */</div><div id="311" class="line none">  311 AWS_STATIC_IMPL</div><div id="312" class="line none">  312 size_t <a href="atomics.inl.html#127">aws_atomic_fetch_xor</a>(volatile struct <a href="atomics.h.html#16">aws_atomic_var</a> *var, size_t n);</div><div id="313" class="line none">  313 </div><div id="314" class="line none">  314 /**</div><div id="315" class="line none">  315  * Provides the same reordering guarantees as an atomic operation with the specified memory order, without</div><div id="316" class="line none">  316  * needing to actually perform an atomic operation.</div><div id="317" class="line none">  317  */</div><div id="318" class="line none">  318 AWS_STATIC_IMPL</div><div id="319" class="line none">  319 void <a href="atomics_gnu.inl.html#206">aws_atomic_thread_fence</a>(enum <a href="atomics.h.html#34">aws_memory_order</a> <a href="../../../../sources/openssl/ec_override.c.html#30">order</a>);</div><div id="320" class="line none">  320 </div><div id="321" class="line none">  321 #ifndef AWS_NO_STATIC_IMPL</div><div id="322" class="line none">  322 #    include &lt;aws/common/atomics.inl&gt;</div><div id="323" class="line none">  323 #endif /* AWS_NO_STATIC_IMPL */</div><div id="324" class="line none">  324 </div><div id="325" class="line none">  325 AWS_EXTERN_C_END</div><div id="326" class="line none">  326 </div><div id="327" class="line none">  327 #endif</div>
</div>
</body>
</html>
