
<html>
<head>
<title>verification/cbmc/aws-c-common/verification/cbmc/include/proof_helpers/utils.h</title>
<link rel="stylesheet" type="text/css" href="../../../../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 /**</div><div id="2" class="line none">    2  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.</div><div id="3" class="line none">    3  * SPDX-License-Identifier: Apache-2.0.</div><div id="4" class="line none">    4  */</div><div id="5" class="line none">    5 </div><div id="6" class="line none">    6 #pragma once</div><div id="7" class="line none">    7 </div><div id="8" class="line none">    8 #include &lt;aws/common/array_list.h&gt;</div><div id="9" class="line none">    9 #include &lt;aws/common/byte_buf.h&gt;</div><div id="10" class="line none">   10 #include &lt;proof_helpers/nondet.h&gt;</div><div id="11" class="line none">   11 #include &lt;proof_helpers/proof_allocators.h&gt;</div><div id="12" class="line none">   12 #include &lt;stddef.h&gt;</div><div id="13" class="line none">   13 #include &lt;stdint.h&gt;</div><div id="14" class="line none">   14 </div><div id="15" class="line none">   15 // The magical name __CPROVER_uninterpreted_* causes CBMC to give us an</div><div id="16" class="line none">   16 // uninterpreted function</div><div id="17" class="line none">   17 uint64_t <a href="utils.h.html#17">__CPROVER_uninterpreted_hasher</a>(void *);</div><div id="18" class="line none">   18 </div><div id="19" class="line none">   19 #define <a href="utils.h.html#19">IMPLIES</a>(a, b) (!(a) || (b))</div><div id="20" class="line none">   20 </div><div id="21" class="line none">   21 struct <a href="utils.h.html#21">store_byte_from_buffer</a> {</div><div id="22" class="line none">   22     size_t <a href="utils.h.html#22">index</a>;</div><div id="23" class="line none">   23     uint8_t <a href="utils.h.html#23">byte</a>;</div><div id="24" class="line none">   24 };</div><div id="25" class="line none">   25 </div><div id="26" class="line none">   26 /**</div><div id="27" class="line none">   27  * Asserts whether all bytes from two arrays of same length match.</div><div id="28" class="line none">   28  */</div><div id="29" class="line none">   29 void <a href="../../sources/utils.c.html#9">assert_bytes_match</a>(const uint8_t *const a, const uint8_t *const b, const size_t <a href="../../../../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="30" class="line none">   30 </div><div id="31" class="line none">   31 /**</div><div id="32" class="line none">   32  * Asserts whether all bytes from an array are equal to c.</div><div id="33" class="line none">   33  */</div><div id="34" class="line none">   34 void <a href="../../sources/utils.c.html#18">assert_all_bytes_are</a>(const uint8_t *const a, const uint8_t c, const size_t <a href="../../../../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="35" class="line none">   35 </div><div id="36" class="line none">   36 /**</div><div id="37" class="line none">   37  * Asserts whether all bytes from an array are equal to 0.</div><div id="38" class="line none">   38  */</div><div id="39" class="line none">   39 void <a href="../../sources/utils.c.html#26">assert_all_zeroes</a>(const uint8_t *const a, const size_t <a href="../../../../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="40" class="line none">   40 </div><div id="41" class="line none">   41 /**</div><div id="42" class="line none">   42  * Asserts whether the byte in storage correspond to the byte in the same position in buffer.</div><div id="43" class="line none">   43  */</div><div id="44" class="line none">   44 void <a href="../../sources/utils.c.html#30">assert_byte_from_buffer_matches</a>(const uint8_t *const <a href="../../../../include/aws/common/byte_buf.h.html#28">buffer</a>, const struct <a href="utils.h.html#21">store_byte_from_buffer</a> *const b);</div><div id="45" class="line none">   45 </div><div id="46" class="line none">   46 /**</div><div id="47" class="line none">   47  * Nondeterministically selects a byte from array and stores it into a store_array_list_byte</div><div id="48" class="line none">   48  * structure. Afterwards, one can prove using the assert_array_list_equivalence function</div><div id="49" class="line none">   49  * whether no byte in the array has changed.</div><div id="50" class="line none">   50  */</div><div id="51" class="line none">   51 void <a href="../../sources/utils.c.html#36">save_byte_from_array</a>(const uint8_t *const array, const size_t <a href="../../../../include/aws/common/private/hash_table_impl.h.html#35">size</a>, struct <a href="utils.h.html#21">store_byte_from_buffer</a> *const storage);</div><div id="52" class="line none">   52 </div><div id="53" class="line none">   53 /**</div><div id="54" class="line none">   54  * Asserts two aws_array_list structures are equivalent. Prior to using this function,</div><div id="55" class="line none">   55  * it is necessary to select a non-deterministic byte from the rhs aws_array_list structure</div><div id="56" class="line none">   56  * (use save_byte_from_array function), so it can properly assert all bytes match.</div><div id="57" class="line none">   57  */</div><div id="58" class="line none">   58 void <a href="../../sources/utils.c.html#44">assert_array_list_equivalence</a>(</div><div id="59" class="line none">   59     const struct <a href="../../../../include/aws/common/array_list.h.html#15">aws_array_list</a> *const lhs,</div><div id="60" class="line none">   60     const struct <a href="../../../../include/aws/common/array_list.h.html#15">aws_array_list</a> *const rhs,</div><div id="61" class="line none">   61     const struct <a href="utils.h.html#21">store_byte_from_buffer</a> *const rhs_byte);</div><div id="62" class="line none">   62 </div><div id="63" class="line none">   63 /**</div><div id="64" class="line none">   64  * Asserts two aws_byte_buf structures are equivalent. In order to be considered equivalent,</div><div id="65" class="line none">   65  * all member from both structures must match (i.e., len, *buffer, capacity, and *allocator),</div><div id="66" class="line none">   66  * including all bytes from its underlying buffers. Prior to using this function,</div><div id="67" class="line none">   67  * it is necessary to select a non-deterministic byte from the rhs aws_byte_buf structure</div><div id="68" class="line none">   68  * (use save_byte_from_array function), so it can properly assert all bytes match.</div><div id="69" class="line none">   69  */</div><div id="70" class="line none">   70 void <a href="../../sources/utils.c.html#81">assert_byte_cursor_equivalence</a>(</div><div id="71" class="line none">   71     const struct <a href="../../../../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const lhs,</div><div id="72" class="line none">   72     const struct <a href="../../../../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const rhs,</div><div id="73" class="line none">   73     const struct <a href="utils.h.html#21">store_byte_from_buffer</a> *const rhs_byte);</div><div id="74" class="line none">   74 </div><div id="75" class="line none">   75 /**</div><div id="76" class="line none">   76  * Asserts two aws_byte_cursor structures are equivalent. Prior to using this function,</div><div id="77" class="line none">   77  * it is necessary to select a non-deterministic byte from the rhs aws_byte_cursor structure</div><div id="78" class="line none">   78  * (use save_byte_from_array function), so it can properly assert all bytes match.</div><div id="79" class="line none">   79  */</div><div id="80" class="line none">   80 void <a href="../../sources/utils.c.html#63">assert_byte_buf_equivalence</a>(</div><div id="81" class="line none">   81     const struct <a href="../../../../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const lhs,</div><div id="82" class="line none">   82     const struct <a href="../../../../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const rhs,</div><div id="83" class="line none">   83     const struct <a href="utils.h.html#21">store_byte_from_buffer</a> *const rhs_byte);</div><div id="84" class="line none">   84 </div><div id="85" class="line none">   85 /**</div><div id="86" class="line none">   86  * Nondeterministically selects a byte from a hash_table implementation and stores it into a</div><div id="87" class="line none">   87  * store_array_list_byte structure.</div><div id="88" class="line none">   88  */</div><div id="89" class="line none">   89 void <a href="../../sources/utils.c.html#94">save_byte_from_hash_table</a>(const struct <a href="../../../../include/aws/common/hash_table.h.html#48">aws_hash_table</a> *<a href="../../../../include/aws/common/hash_table.h.html#75">map</a>, struct <a href="utils.h.html#21">store_byte_from_buffer</a> *storage);</div><div id="90" class="line none">   90 </div><div id="91" class="line none">   91 /**</div><div id="92" class="line none">   92  * Checks that a no bytes in the hash_table have changed from when "storage" was stored.</div><div id="93" class="line none">   93  */</div><div id="94" class="line none">   94 void <a href="../../sources/utils.c.html#101">check_hash_table_unchanged</a>(const struct <a href="../../../../include/aws/common/hash_table.h.html#48">aws_hash_table</a> *<a href="../../../../include/aws/common/hash_table.h.html#75">map</a>, const struct <a href="utils.h.html#21">store_byte_from_buffer</a> *storage);</div><div id="95" class="line none">   95 </div><div id="96" class="line none">   96 /**</div><div id="97" class="line none">   97  * Standard stub function to compare two items.</div><div id="98" class="line none">   98  */</div><div id="99" class="line none">   99 int <a href="../../sources/utils.c.html#107">nondet_compare</a>(const void *const a, const void *const b);</div><div id="100" class="line none">  100 </div><div id="101" class="line none">  101 /**</div><div id="102" class="line none">  102  * Standard stub function to compare two items.</div><div id="103" class="line none">  103  */</div><div id="104" class="line none">  104 int <a href="../../sources/utils.c.html#114">uninterpreted_compare</a>(const void *const a, const void *const b);</div><div id="105" class="line none">  105 </div><div id="106" class="line none">  106 /**</div><div id="107" class="line none">  107  * Standard stub function to compare two items.</div><div id="108" class="line none">  108  */</div><div id="109" class="line none">  109 bool <a href="../../sources/utils.c.html#129">nondet_equals</a>(const void *const a, const void *const b);</div><div id="110" class="line none">  110 </div><div id="111" class="line none">  111 /**</div><div id="112" class="line none">  112  * Standard stub function to compare two items.</div><div id="113" class="line none">  113  * Also enforces uninterpreted_hasher() to be equal for equal values.</div><div id="114" class="line none">  114  */</div><div id="115" class="line none">  115 bool <a href="../../sources/utils.c.html#141">uninterpreted_equals</a>(const void *const a, const void *const b);</div><div id="116" class="line none">  116 </div><div id="117" class="line none">  117 /**</div><div id="118" class="line none">  118  * uninterpreted_equals(), but with an extra assertion that a and b are both not null</div><div id="119" class="line none">  119  */</div><div id="120" class="line none">  120 bool <a href="../../sources/utils.c.html#154">uninterpreted_equals_assert_inputs_nonnull</a>(const void *const a, const void *const b);</div><div id="121" class="line none">  121 </div><div id="122" class="line none">  122 /**</div><div id="123" class="line none">  123  * Standard stub function to hash one item.</div><div id="124" class="line none">  124  */</div><div id="125" class="line none">  125 uint64_t <a href="../../sources/utils.c.html#160">nondet_hasher</a>(const void *a);</div><div id="126" class="line none">  126 </div><div id="127" class="line none">  127 /**</div><div id="128" class="line none">  128  * Standard stub function to hash one item.</div><div id="129" class="line none">  129  */</div><div id="130" class="line none">  130 uint64_t <a href="../../sources/utils.c.html#168">uninterpreted_hasher</a>(const void *a);</div><div id="131" class="line none">  131 </div><div id="132" class="line none">  132 /**</div><div id="133" class="line none">  133  * Standard stub function of a predicate</div><div id="134" class="line none">  134  */</div><div id="135" class="line none">  135 bool uninterpreted_predicate_fn(uint8_t <a href="../../../../include/aws/common/atomics.h.html#17">value</a>);</div>
</div>
</body>
</html>
