
<html>
<head>
<title>verification/cbmc/sources/openssl/evp_override.c</title>
<link rel="stylesheet" type="text/css" href="../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 /*</div><div id="2" class="line none">    2  * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.</div><div id="3" class="line none">    3  *</div><div id="4" class="line none">    4  * Licensed under the Apache License, Version 2.0 (the "License").</div><div id="5" class="line none">    5  * You may not use this file except in compliance with the License.</div><div id="6" class="line none">    6  * A copy of the License is located at</div><div id="7" class="line none">    7  *</div><div id="8" class="line none">    8  *  http://aws.amazon.com/apache2.0</div><div id="9" class="line none">    9  *</div><div id="10" class="line none">   10  * or in the "license" file accompanying this file. This file is distributed</div><div id="11" class="line none">   11  * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either</div><div id="12" class="line none">   12  * express or implied. See the License for the specific language governing</div><div id="13" class="line none">   13  * permissions and limitations under the License.</div><div id="14" class="line none">   14  */</div><div id="15" class="line none">   15 </div><div id="16" class="line none">   16 #include &lt;ec_utils.h&gt;</div><div id="17" class="line none">   17 #include &lt;make_common_data_structures.h&gt;</div><div id="18" class="line none">   18 #include &lt;openssl/evp.h&gt;</div><div id="19" class="line none">   19 #include &lt;openssl/hmac.h&gt;</div><div id="20" class="line none">   20 #include &lt;openssl/kdf.h&gt;</div><div id="21" class="line none">   21 #include &lt;openssl/rsa.h&gt;</div><div id="22" class="line none">   22 #include &lt;proof_helpers/nondet.h&gt;</div><div id="23" class="line none">   23 </div><div id="24" class="line none">   24 #define <a href="evp_override.c.html#24">DEFAULT_IV_LEN</a> 12       // For GCM AES and OCB AES the default is 12 (i.e. 96 bits).</div><div id="25" class="line none">   25 #define <a href="evp_override.c.html#25">DEFAULT_BLOCK_SIZE</a> 128  // For GCM AES, the default block size is 128</div><div id="26" class="line none">   26 </div><div id="27" class="line none">   27 /*</div><div id="28" class="line none">   28  * Description: The EVP_PKEY_new() function allocates an empty EVP_PKEY structure which is used by OpenSSL to store</div><div id="29" class="line none">   29  * public and private keys. The reference count is set to 1. Return values: EVP_PKEY_new() returns either the newly</div><div id="30" class="line none">   30  * allocated EVP_PKEY structure or NULL if an error occurred.</div><div id="31" class="line none">   31  */</div><div id="32" class="line none">   32 <a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="evp_override.c.html#32">EVP_PKEY_new</a>() {</div><div id="33" class="line none">   33     <a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a> = <a href="../../aws-c-common/verification/cbmc/sources/proof_allocators.c.html#76">can_fail_malloc</a>(sizeof(<a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a>));</div><div id="34" class="line none">   34 </div><div id="35" class="line none">   35     if (<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>) {</div><div id="36" class="line none">   36         <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;<a href="ec_override.c.html#82">references</a> = 1;</div><div id="37" class="line none">   37         <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;ec_key     = NULL;</div><div id="38" class="line none">   38     }</div><div id="39" class="line none">   39 </div><div id="40" class="line none">   40     return <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>;</div><div id="41" class="line none">   41 }</div><div id="42" class="line none">   42 </div><div id="43" class="line none">   43 /*</div><div id="44" class="line none">   44  * Description: EVP_PKEY_get0_EC_KEY() also returns the referenced key in pkey or NULL if the key is not of the correct</div><div id="45" class="line none">   45  * type but the reference count of the returned key is not incremented and so must not be freed up after use. Return</div><div id="46" class="line none">   46  * value: EVP_PKEY_get0_EC_KEY() returns the referenced key or NULL if an error occurred.</div><div id="47" class="line none">   47  */</div><div id="48" class="line none">   48 <a href="../../include/openssl/ossl_typ.h.html#33">EC_KEY</a> *<a href="evp_override.c.html#48">EVP_PKEY_get0_EC_KEY</a>(<a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>) {</div><div id="49" class="line none">   49     assert(<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>);</div><div id="50" class="line none">   50 </div><div id="51" class="line none">   51     // In our current model, the key is always of type EC</div><div id="52" class="line none">   52     return <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;ec_key;</div><div id="53" class="line none">   53 }</div><div id="54" class="line none">   54 </div><div id="55" class="line none">   55 /*</div><div id="56" class="line none">   56  * Description: EVP_PKEY_set1_EC_KEY() sets the key referenced by pkey to key.</div><div id="57" class="line none">   57  * Return values: EVP_PKEY_set1_EC_KEY() returns 1 for success or 0 for failure.</div><div id="58" class="line none">   58  */</div><div id="59" class="line none">   59 int <a href="evp_override.c.html#59">EVP_PKEY_set1_EC_KEY</a>(<a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>, <a href="../../include/openssl/ossl_typ.h.html#33">EC_KEY</a> *<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>) {</div><div id="60" class="line none">   60     if (<a href="../../../../source/cipher_openssl.c.html#77">pkey</a> == NULL || <a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a> == NULL || <a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="61" class="line none">   61         return 0;</div><div id="62" class="line none">   62     }</div><div id="63" class="line none">   63 </div><div id="64" class="line none">   64     <a href="ec_override.c.html#199">EC_KEY_up_ref</a>(<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>);</div><div id="65" class="line none">   65     <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;ec_key = <a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>;</div><div id="66" class="line none">   66 </div><div id="67" class="line none">   67     return 1;</div><div id="68" class="line none">   68 }</div><div id="69" class="line none">   69 </div><div id="70" class="line none">   70 /*</div><div id="71" class="line none">   71  * Description: EVP_PKEY_free() decrements the reference count of key and, if the reference count is zero, frees it up.</div><div id="72" class="line none">   72  * If key is NULL, nothing is done.</div><div id="73" class="line none">   73  */</div><div id="74" class="line none">   74 void <a href="evp_override.c.html#74">EVP_PKEY_free</a>(<a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>) {</div><div id="75" class="line none">   75     if (<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>) {</div><div id="76" class="line none">   76         <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;<a href="ec_override.c.html#82">references</a> -= 1;</div><div id="77" class="line none">   77         if (<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;<a href="ec_override.c.html#82">references</a> == 0) {</div><div id="78" class="line none">   78             <a href="ec_override.c.html#210">EC_KEY_free</a>(<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;ec_key);</div><div id="79" class="line none">   79             free(<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>);</div><div id="80" class="line none">   80         }</div><div id="81" class="line none">   81     }</div><div id="82" class="line none">   82 }</div><div id="83" class="line none">   83 </div><div id="84" class="line none">   84 /* Abstraction of the EVP_PKEY_CTX struct */</div><div id="85" class="line none">   85 struct <a href="../../include/openssl/ossl_typ.h.html#35">evp_pkey_ctx_st</a> {</div><div id="86" class="line none">   86     bool <a href="evp_override.c.html#86">is_initialized_for_signing</a>;</div><div id="87" class="line none">   87     bool <a href="evp_override.c.html#87">is_initialized_for_derivation</a>;</div><div id="88" class="line none">   88     bool <a href="evp_override.c.html#88">is_initialized_for_encryption</a>;</div><div id="89" class="line none">   89     bool <a href="evp_override.c.html#89">is_initialized_for_decryption</a>;</div><div id="90" class="line none">   90     int <a href="evp_override.c.html#90">rsa_pad</a>;</div><div id="91" class="line none">   91     <a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>;</div><div id="92" class="line none">   92 };</div><div id="93" class="line none">   93 </div><div id="94" class="line none">   94 /*</div><div id="95" class="line none">   95  * Description: The EVP_PKEY_CTX_new() function allocates public key algorithm context using the algorithm specified in</div><div id="96" class="line none">   96  * pkey and ENGINE e. Return values: EVP_PKEY_CTX_new() returns either the newly allocated EVP_PKEY_CTX structure of</div><div id="97" class="line none">   97  * NULL if an error occurred.</div><div id="98" class="line none">   98  */</div><div id="99" class="line none">   99 <a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="evp_override.c.html#99">EVP_PKEY_CTX_new</a>(<a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>, <a href="../../include/openssl/ossl_typ.h.html#44">ENGINE</a> *e) {</div><div id="100" class="line none">  100     assert(<a href="evp_override.c.html#994">evp_pkey_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>));</div><div id="101" class="line none">  101     assert(!e);  // Assuming is always called with e == NULL</div><div id="102" class="line none">  102 </div><div id="103" class="line none">  103     <a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> = <a href="../../aws-c-common/verification/cbmc/sources/proof_allocators.c.html#76">can_fail_malloc</a>(sizeof(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a>));</div><div id="104" class="line none">  104 </div><div id="105" class="line none">  105     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="106" class="line none">  106         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#86">is_initialized_for_signing</a>    = false;</div><div id="107" class="line none">  107         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#87">is_initialized_for_derivation</a> = false;</div><div id="108" class="line none">  108         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#88">is_initialized_for_encryption</a> = false;</div><div id="109" class="line none">  109         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#89">is_initialized_for_decryption</a> = false;</div><div id="110" class="line none">  110         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>                          = <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>;</div><div id="111" class="line none">  111         <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;<a href="ec_override.c.html#82">references</a> += 1;</div><div id="112" class="line none">  112     }</div><div id="113" class="line none">  113 </div><div id="114" class="line none">  114     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>;</div><div id="115" class="line none">  115 }</div><div id="116" class="line none">  116 </div><div id="117" class="line none">  117 /*</div><div id="118" class="line none">  118  * Description: The EVP_PKEY_CTX_new_id() function allocates public key algorithm</div><div id="119" class="line none">  119  * context using the algorithm specified by id and ENGINE e. It is normally used when no EVP_PKEY structure is</div><div id="120" class="line none">  120  * associated with the operations, for example during parameter generation of key generation for some algorithms. Return</div><div id="121" class="line none">  121  * values: EVP_PKEY_CTX_new_id() returns either the newly allocated EVP_PKEY_CTX structure of NULL if an error occurred.</div><div id="122" class="line none">  122  */</div><div id="123" class="line none">  123 <a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="evp_override.c.html#123">EVP_PKEY_CTX_new_id</a>(int id, <a href="../../include/openssl/ossl_typ.h.html#44">ENGINE</a> *e) {</div><div id="124" class="line none">  124     // assert(!e);  // Assuming is always called with e == NULL</div><div id="125" class="line none">  125 </div><div id="126" class="line hit">  126     <a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> = <a href="../../aws-c-common/verification/cbmc/sources/proof_allocators.c.html#76">can_fail_malloc</a>(sizeof(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a>));</div><div id="127" class="line none">  127 </div><div id="128" class="line hit">  128     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="129" class="line hit">  129         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#86">is_initialized_for_signing</a>    = false;</div><div id="130" class="line hit">  130         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#87">is_initialized_for_derivation</a> = false;</div><div id="131" class="line hit">  131         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#88">is_initialized_for_encryption</a> = false;</div><div id="132" class="line hit">  132         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#89">is_initialized_for_decryption</a> = false;</div><div id="133" class="line hit">  133         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>                          = NULL;</div><div id="134" class="line none">  134     }</div><div id="135" class="line none">  135 </div><div id="136" class="line hit">  136     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>;</div><div id="137" class="line hit">  137 }</div><div id="138" class="line none">  138 </div><div id="139" class="line none">  139 /* Description: The EVP_PKEY_derive_init() function initializes a public key algorithm context using key pkey</div><div id="140" class="line none">  140  * for shared secret derivation. EVP_PKEY_derive_init() returns 1 for success and 0 or a negative</div><div id="141" class="line none">  141  * value for failure. In particular a return value of -2 indicates the operation is not supported by the public key</div><div id="142" class="line none">  142  * algorithm.</div><div id="143" class="line none">  143  */</div><div id="144" class="line none">  144 int <a href="evp_override.c.html#144">EVP_PKEY_derive_init</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="145" class="line hit">  145     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>);</div><div id="146" class="line hit">  146     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="147" class="line hit">  147         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#87">is_initialized_for_derivation</a> = true;</div><div id="148" class="line hit">  148         return 1;</div><div id="149" class="line none">  149     }</div><div id="150" class="line none">  150 </div><div id="151" class="line hit">  151     int rv;</div><div id="152" class="line hit">  152     __CPROVER_assume(rv &lt;= 0);</div><div id="153" class="line hit">  153     return rv;</div><div id="154" class="line hit">  154 }</div><div id="155" class="line none">  155 </div><div id="156" class="line none">  156 /*</div><div id="157" class="line none">  157  * Description: The EVP_PKEY_sign_init() function initializes a public key algorithm context using key pkey for a</div><div id="158" class="line none">  158  * signing operation. Return values: EVP_PKEY_sign_init() and EVP_PKEY_sign() return 1 for success and 0 or a negative</div><div id="159" class="line none">  159  * value for failure. In particular a return value of -2 indicates the operation is not supported by the public key</div><div id="160" class="line none">  160  * algorithm.</div><div id="161" class="line none">  161  */</div><div id="162" class="line none">  162 int <a href="evp_override.c.html#162">EVP_PKEY_sign_init</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="163" class="line none">  163     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>);</div><div id="164" class="line none">  164     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>);</div><div id="165" class="line none">  165 </div><div id="166" class="line none">  166     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="167" class="line none">  167         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#86">is_initialized_for_signing</a> = true;</div><div id="168" class="line none">  168         return 1;</div><div id="169" class="line none">  169     }</div><div id="170" class="line none">  170 </div><div id="171" class="line none">  171     int rv;</div><div id="172" class="line none">  172     __CPROVER_assume(rv &lt;= 0);</div><div id="173" class="line none">  173     return rv;</div><div id="174" class="line none">  174 }</div><div id="175" class="line none">  175 </div><div id="176" class="line none">  176 /*</div><div id="177" class="line none">  177  * Description: The EVP_PKEY_sign() function performs a public key signing operation using ctx. The data to be signed is</div><div id="178" class="line none">  178  * specified using the tbs and tbslen parameters. If sig is NULL then the maximum size of the output buffer is written</div><div id="179" class="line none">  179  * to the siglen parameter. If sig is not NULL then before the call the siglen parameter should contain the length of</div><div id="180" class="line none">  180  * the sig buffer, if the call is successful the signature is written to sig and the amount of data written to siglen.</div><div id="181" class="line none">  181  * Return values: EVP_PKEY_sign_init() and EVP_PKEY_sign() return 1 for success and 0 or a negative value for failure.</div><div id="182" class="line none">  182  * In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</div><div id="183" class="line none">  183  */</div><div id="184" class="line none">  184 int <a href="evp_override.c.html#184">EVP_PKEY_sign</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *sig, size_t *siglen, const unsigned char *tbs, size_t tbslen) {</div><div id="185" class="line none">  185     assert(<a href="evp_override.c.html#1020">evp_pkey_ctx_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>));</div><div id="186" class="line none">  186     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#86">is_initialized_for_signing</a> == true);</div><div id="187" class="line none">  187     assert(siglen);</div><div id="188" class="line none">  188     assert(!sig || (*siglen &gt;= <a href="ec_override.c.html#442">max_signature_size</a>() &amp;&amp; AWS_MEM_IS_WRITABLE(sig, *siglen)));</div><div id="189" class="line none">  189     assert(tbs);</div><div id="190" class="line none">  190     assert(AWS_MEM_IS_READABLE(tbs, tbslen));</div><div id="191" class="line none">  191 </div><div id="192" class="line none">  192     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="193" class="line none">  193         int rv;</div><div id="194" class="line none">  194         __CPROVER_assume(rv &lt;= 0);</div><div id="195" class="line none">  195         return rv;</div><div id="196" class="line none">  196     }</div><div id="197" class="line none">  197 </div><div id="198" class="line none">  198     // Signature size is nondeterministic but fixed. See ec_override.c for details.</div><div id="199" class="line none">  199     size_t max_required_size = <a href="ec_override.c.html#442">max_signature_size</a>();</div><div id="200" class="line none">  200 </div><div id="201" class="line none">  201     if (!sig) {</div><div id="202" class="line none">  202         *siglen = max_required_size;</div><div id="203" class="line none">  203     } else {</div><div id="204" class="line none">  204         size_t amount_of_data_written;</div><div id="205" class="line none">  205         __CPROVER_assume(amount_of_data_written &lt;= max_required_size);</div><div id="206" class="line none">  206         <a href="ec_override.c.html#486">write_unconstrained_data</a>(sig, amount_of_data_written);</div><div id="207" class="line none">  207         *siglen = amount_of_data_written;</div><div id="208" class="line none">  208     }</div><div id="209" class="line none">  209 </div><div id="210" class="line none">  210     return 1;</div><div id="211" class="line none">  211 }</div><div id="212" class="line none">  212 </div><div id="213" class="line none">  213 /*</div><div id="214" class="line none">  214  * Description: The function EVP_PKEY_CTX_ctrl() sends a control operation to the context ctx.</div><div id="215" class="line none">  215  * The key type used must match keytype if it is not -1. The parameter optype is a mask indicating which operations</div><div id="216" class="line none">  216  * the control can be applied to. The control command is indicated in cmd and any additional arguments in p1 and p2.</div><div id="217" class="line none">  217  * EVP_PKEY_CTX_ctrl() and its macros return a positive value for success and 0 or a negative value for failure.</div><div id="218" class="line none">  218  * In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</div><div id="219" class="line none">  219  */</div><div id="220" class="line none">  220 int <a href="evp_override.c.html#220">EVP_PKEY_CTX_ctrl</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, int keytype, int optype, int cmd, int p1, void *p2) {</div><div id="221" class="line hit">  221     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="222" class="line hit">  222     assert(keytype == -1);  // Is this ever false?</div><div id="223" class="line hit">  223     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="224" class="line hit">  224         return 1;</div><div id="225" class="line none">  225     }</div><div id="226" class="line hit">  226     int rv;</div><div id="227" class="line hit">  227     __CPROVER_assume(rv &lt;= 0);</div><div id="228" class="line hit">  228     return rv;</div><div id="229" class="line hit">  229 }</div><div id="230" class="line none">  230 </div><div id="231" class="line none">  231 /*</div><div id="232" class="line none">  232  * Description: The EVP_PKEY_derive() derives a shared secret using ctx. If key is NULL then the maximum size of the</div><div id="233" class="line none">  233  * output buffer is written to the keylen parameter. If key is not NULL then before the call the keylen parameter should</div><div id="234" class="line none">  234  * contain the length of the key buffer, if the call is successful the shared secret is written to key and the amount of</div><div id="235" class="line none">  235  * data written to keylen.</div><div id="236" class="line none">  236  */</div><div id="237" class="line none">  237 int <a href="evp_override.c.html#237">EVP_PKEY_derive</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>, size_t *keylen) {</div><div id="238" class="line none">  238     /* TODO: assert(evp_pkey_ctx_is_valid(ctx)); */</div><div id="239" class="line hit">  239     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="240" class="line hit">  240     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#87">is_initialized_for_derivation</a> == true);</div><div id="241" class="line hit">  241     assert(keylen);</div><div id="242" class="line none">  242     // Derivation size is nondeterministic but fixed. See ec_override.c for details.</div><div id="243" class="line hit">  243     size_t max_required_size = <a href="ec_override.c.html#455">max_derivation_size</a>();</div><div id="244" class="line none">  244 </div><div id="245" class="line hit">  245     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="246" class="line hit">  246         int rv;</div><div id="247" class="line hit">  247         __CPROVER_assume(rv &lt;= 0);</div><div id="248" class="line hit">  248         return rv;</div><div id="249" class="line none">  249     }</div><div id="250" class="line none">  250 </div><div id="251" class="line hit">  251     if (!<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>) {</div><div id="252" class="line hit">  252         *keylen = max_required_size;</div><div id="253" class="line none">  253     } else {</div><div id="254" class="line hit">  254         size_t amount_of_data_written;</div><div id="255" class="line hit">  255         __CPROVER_assume(amount_of_data_written &lt;= *keylen);</div><div id="256" class="line hit">  256         <a href="ec_override.c.html#486">write_unconstrained_data</a>(<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>, amount_of_data_written);</div><div id="257" class="line hit">  257         *keylen = amount_of_data_written;</div><div id="258" class="line hit">  258     }</div><div id="259" class="line none">  259 </div><div id="260" class="line hit">  260     return 1;</div><div id="261" class="line hit">  261 }</div><div id="262" class="line none">  262 </div><div id="263" class="line none">  263 /*</div><div id="264" class="line none">  264  * The EVP_PKEY_encrypt_init() function initializes a public key algorithm context using key pkey for an encryption</div><div id="265" class="line none">  265  * operation. EVP_PKEY_encrypt_init() and EVP_PKEY_encrypt() return 1 for success and 0 or a negative value for failure.</div><div id="266" class="line none">  266  * In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</div><div id="267" class="line none">  267  */</div><div id="268" class="line none">  268 int <a href="evp_override.c.html#268">EVP_PKEY_encrypt_init</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="269" class="line none">  269     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="270" class="line none">  270     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a> != NULL);</div><div id="271" class="line none">  271     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="272" class="line none">  272         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#88">is_initialized_for_encryption</a> = true;</div><div id="273" class="line none">  273         return 1;</div><div id="274" class="line none">  274     }</div><div id="275" class="line none">  275     int rv;</div><div id="276" class="line none">  276     __CPROVER_assume(rv &lt;= 0);</div><div id="277" class="line none">  277     return rv;</div><div id="278" class="line none">  278 }</div><div id="279" class="line none">  279 </div><div id="280" class="line none">  280 /*</div><div id="281" class="line none">  281  * The EVP_PKEY_decrypt_init() function initializes a public key algorithm context using key pkey for a decryption</div><div id="282" class="line none">  282  * operation. EVP_PKEY_decrypt_init() and EVP_PKEY_decrypt() return 1 for success and 0 or a negative value for failure.</div><div id="283" class="line none">  283  * In particular a return value of -2 indicates the operation is not supported by the public key algorithm.</div><div id="284" class="line none">  284  */</div><div id="285" class="line none">  285 int <a href="evp_override.c.html#285">EVP_PKEY_decrypt_init</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="286" class="line none">  286     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="287" class="line none">  287     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a> != NULL);</div><div id="288" class="line none">  288     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="289" class="line none">  289         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#89">is_initialized_for_decryption</a> = true;</div><div id="290" class="line none">  290         return 1;</div><div id="291" class="line none">  291     }</div><div id="292" class="line none">  292     int rv;</div><div id="293" class="line none">  293     __CPROVER_assume(rv &lt;= 0);</div><div id="294" class="line none">  294     return rv;</div><div id="295" class="line none">  295 }</div><div id="296" class="line none">  296 </div><div id="297" class="line none">  297 /*</div><div id="298" class="line none">  298  * The macro EVP_PKEY_CTX_set_rsa_padding() sets the RSA padding mode for ctx. The pad parameter can take the value</div><div id="299" class="line none">  299  * RSA_PKCS1_PADDING for PKCS#1 padding, RSA_SSLV23_PADDING for SSLv23 padding, RSA_NO_PADDING for no padding,</div><div id="300" class="line none">  300  * RSA_PKCS1_OAEP_PADDING for OAEP padding (encrypt and decrypt only), RSA_X931_PADDING for X9.31 padding (signature</div><div id="301" class="line none">  301  * operations only) and RSA_PKCS1_PSS_PADDING (sign and verify only).</div><div id="302" class="line none">  302  *</div><div id="303" class="line none">  303  */</div><div id="304" class="line none">  304 int <a href="evp_override.c.html#304">EVP_PKEY_CTX_set_rsa_padding</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, int pad) {</div><div id="305" class="line none">  305     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="306" class="line none">  306     assert(</div><div id="307" class="line none">  307         pad == RSA_PKCS1_PADDING || pad == RSA_SSLV23_PADDING || pad == RSA_NO_PADDING ||</div><div id="308" class="line none">  308         pad == RSA_PKCS1_OAEP_PADDING || pad == RSA_X931_PADDING || pad == RSA_PKCS1_PSS_PADDING);</div><div id="309" class="line none">  309     assert(<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/utils.h.html#19">IMPLIES</a>(pad == RSA_X931_PADDING, <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#86">is_initialized_for_signing</a>));</div><div id="310" class="line none">  310     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#90">rsa_pad</a> = pad;</div><div id="311" class="line none">  311     int rv;</div><div id="312" class="line none">  312     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="313" class="line none">  313     return rv;</div><div id="314" class="line none">  314 }</div><div id="315" class="line none">  315 /*</div><div id="316" class="line none">  316  * The EVP_PKEY_CTX_set_rsa_oaep_md() macro sets the message digest type used in RSA OAEP to md.</div><div id="317" class="line none">  317  * The padding mode must have been set to RSA_PKCS1_OAEP_PADDING.</div><div id="318" class="line none">  318  */</div><div id="319" class="line none">  319 int <a href="evp_override.c.html#319">EVP_PKEY_CTX_set_rsa_oaep_md</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *md) {</div><div id="320" class="line none">  320     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="321" class="line none">  321     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#90">rsa_pad</a> == RSA_PKCS1_OAEP_PADDING);</div><div id="322" class="line none">  322     int rv;</div><div id="323" class="line none">  323     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="324" class="line none">  324     return rv;</div><div id="325" class="line none">  325 }</div><div id="326" class="line none">  326 </div><div id="327" class="line none">  327 /*</div><div id="328" class="line none">  328  * The EVP_PKEY_CTX_set_rsa_mgf1_md() macro sets the MGF1 digest for RSA padding schemes to md.</div><div id="329" class="line none">  329  * If not explicitly set the signing digest is used. The padding mode must have been set to RSA_PKCS1_OAEP_PADDING or</div><div id="330" class="line none">  330  * RSA_PKCS1_PSS_PADDING.</div><div id="331" class="line none">  331  */</div><div id="332" class="line none">  332 int <a href="evp_override.c.html#332">EVP_PKEY_CTX_set_rsa_mgf1_md</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *md) {</div><div id="333" class="line none">  333     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="334" class="line none">  334     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#90">rsa_pad</a> == RSA_PKCS1_OAEP_PADDING || <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#90">rsa_pad</a> == RSA_PKCS1_PSS_PADDING);</div><div id="335" class="line none">  335     int rv;</div><div id="336" class="line none">  336     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="337" class="line none">  337     return rv;</div><div id="338" class="line none">  338 }</div><div id="339" class="line none">  339 </div><div id="340" class="line none">  340 /*</div><div id="341" class="line none">  341  * The EVP_PKEY_encrypt() function performs a public key encryption operation using ctx.</div><div id="342" class="line none">  342  * The data to be encrypted is specified using the in and inlen parameters. If out is NULL then the maximum size of the</div><div id="343" class="line none">  343  * output buffer is written to the outlen parameter. If out is not NULL then before the call the outlen parameter should</div><div id="344" class="line none">  344  * contain the length of the out buffer, if the call is successful the encrypted data is written to out and the amount</div><div id="345" class="line none">  345  * of data written to outlen.</div><div id="346" class="line none">  346  */</div><div id="347" class="line none">  347 int <a href="evp_override.c.html#347">EVP_PKEY_encrypt</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *out, size_t *outlen, const unsigned char *in, size_t inlen) {</div><div id="348" class="line none">  348     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="349" class="line none">  349     // Encyption size is nondeterministic but fixed. See ec_override.c for details.</div><div id="350" class="line none">  350     size_t max_required_size = <a href="ec_override.c.html#468">max_encryption_size</a>();</div><div id="351" class="line none">  351 </div><div id="352" class="line none">  352     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="353" class="line none">  353         int rv;</div><div id="354" class="line none">  354         __CPROVER_assume(rv &lt;= 0);</div><div id="355" class="line none">  355         return rv;</div><div id="356" class="line none">  356     }</div><div id="357" class="line none">  357 </div><div id="358" class="line none">  358     if (!out) {</div><div id="359" class="line none">  359         *outlen = max_required_size;</div><div id="360" class="line none">  360     } else {</div><div id="361" class="line none">  361         size_t amount_of_data_written;</div><div id="362" class="line none">  362         __CPROVER_assume(amount_of_data_written &lt;= *outlen);</div><div id="363" class="line none">  363         <a href="ec_override.c.html#486">write_unconstrained_data</a>(out, amount_of_data_written);</div><div id="364" class="line none">  364         *outlen = amount_of_data_written;</div><div id="365" class="line none">  365     }</div><div id="366" class="line none">  366 </div><div id="367" class="line none">  367     return 1;</div><div id="368" class="line none">  368 }</div><div id="369" class="line none">  369 </div><div id="370" class="line none">  370 /*</div><div id="371" class="line none">  371  * The EVP_PKEY_decrypt() function performs a public key decryption operation using ctx. The data to be decrypted is</div><div id="372" class="line none">  372  * specified using the in and inlen parameters. If out is NULL then the maximum size of the output buffer is written to</div><div id="373" class="line none">  373  * the outlen parameter. If out is not NULL then before the call the outlen parameter should contain the length of the</div><div id="374" class="line none">  374  * out buffer, if the call is successful the decrypted data is written to out and the amount of data written to outlen.</div><div id="375" class="line none">  375  */</div><div id="376" class="line none">  376 int <a href="evp_override.c.html#376">EVP_PKEY_decrypt</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *out, size_t *outlen, const unsigned char *in, size_t inlen) {</div><div id="377" class="line none">  377     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="378" class="line none">  378     // Decryption size is nondeterministic but fixed. See ec_override.c for details.</div><div id="379" class="line none">  379     size_t max_required_size = <a href="ec_override.c.html#481">max_decryption_size</a>();</div><div id="380" class="line none">  380 </div><div id="381" class="line none">  381     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="382" class="line none">  382         int rv;</div><div id="383" class="line none">  383         __CPROVER_assume(rv &lt;= 0);</div><div id="384" class="line none">  384         return rv;</div><div id="385" class="line none">  385     }</div><div id="386" class="line none">  386 </div><div id="387" class="line none">  387     if (!out) {</div><div id="388" class="line none">  388         *outlen = max_required_size;</div><div id="389" class="line none">  389     } else {</div><div id="390" class="line none">  390         size_t amount_of_data_written;</div><div id="391" class="line none">  391         __CPROVER_assume(amount_of_data_written &lt;= *outlen);</div><div id="392" class="line none">  392         <a href="ec_override.c.html#486">write_unconstrained_data</a>(out, amount_of_data_written);</div><div id="393" class="line none">  393         *outlen = amount_of_data_written;</div><div id="394" class="line none">  394     }</div><div id="395" class="line none">  395 </div><div id="396" class="line none">  396     return 1;</div><div id="397" class="line none">  397 }</div><div id="398" class="line none">  398 </div><div id="399" class="line none">  399 /*</div><div id="400" class="line none">  400  *EVP_PKEY_CTX_free() frees up the context ctx. If ctx is NULL, nothing is done.</div><div id="401" class="line none">  401  */</div><div id="402" class="line none">  402 void <a href="evp_override.c.html#402">EVP_PKEY_CTX_free</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="403" class="line hit">  403     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="404" class="line hit">  404         free(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>);</div><div id="405" class="line none">  405     }</div><div id="406" class="line hit">  406 }</div><div id="407" class="line none">  407 </div><div id="408" class="line none">  408 enum <a href="evp_override.c.html#408">evp_aes</a> { <a href="evp_override.c.html#408">EVP_AES_128_GCM</a>, <a href="evp_override.c.html#408">EVP_AES_192_GCM</a>, <a href="evp_override.c.html#408">EVP_AES_256_GCM</a> };</div><div id="409" class="line none">  409 </div><div id="410" class="line none">  410 /* Abstraction of the EVP_CIPHER struct */</div><div id="411" class="line none">  411 struct <a href="../../include/openssl/ossl_typ.h.html#38">evp_cipher_st</a> {</div><div id="412" class="line none">  412     enum <a href="evp_override.c.html#408">evp_aes</a> <a href="evp_override.c.html#412">from</a>;</div><div id="413" class="line none">  413     size_t <a href="evp_override.c.html#413">block_size</a>;</div><div id="414" class="line none">  414 };</div><div id="415" class="line none">  415 </div><div id="416" class="line none">  416 /*</div><div id="417" class="line none">  417  * Description: AES for 128, 192 and 256 bit keys in Galois Counter Mode (GCM). These ciphers require additional control</div><div id="418" class="line none">  418  * operations to function correctly, see the "AEAD Interface" in EVP_EncryptInit(3) section for details. Return values:</div><div id="419" class="line none">  419  * These functions return an EVP_CIPHER structure that contains the implementation of the symmetric cipher.</div><div id="420" class="line none">  420  */</div><div id="421" class="line none">  421 const <a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> *<a href="evp_override.c.html#421">EVP_aes_128_gcm</a>(void) {</div><div id="422" class="line none">  422     static const <a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> <a href="evp_override.c.html#437">cipher</a> = { <a href="evp_override.c.html#408">EVP_AES_128_GCM</a>, 128 };</div><div id="423" class="line none">  423     return &amp;<a href="evp_override.c.html#437">cipher</a>;</div><div id="424" class="line none">  424 }</div><div id="425" class="line none">  425 const <a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> *<a href="evp_override.c.html#425">EVP_aes_192_gcm</a>(void) {</div><div id="426" class="line none">  426     static const <a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> <a href="evp_override.c.html#437">cipher</a> = { <a href="evp_override.c.html#408">EVP_AES_192_GCM</a>, 128 };</div><div id="427" class="line none">  427     return &amp;<a href="evp_override.c.html#437">cipher</a>;</div><div id="428" class="line none">  428 }</div><div id="429" class="line none">  429 const <a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> *<a href="evp_override.c.html#429">EVP_aes_256_gcm</a>(void) {</div><div id="430" class="line none">  430     static const <a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> <a href="evp_override.c.html#437">cipher</a> = { <a href="evp_override.c.html#408">EVP_AES_256_GCM</a>, 128 };</div><div id="431" class="line none">  431     return &amp;<a href="evp_override.c.html#437">cipher</a>;</div><div id="432" class="line none">  432 }</div><div id="433" class="line none">  433 </div><div id="434" class="line none">  434 /* Abstraction of the EVP_CIPHER_CTX struct */</div><div id="435" class="line none">  435 </div><div id="436" class="line none">  436 struct <a href="../../include/openssl/ossl_typ.h.html#39">evp_cipher_ctx_st</a> {</div><div id="437" class="line none">  437     <a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> *<a href="evp_override.c.html#437">cipher</a>;</div><div id="438" class="line none">  438     int <a href="evp_override.c.html#438">encrypt</a>;</div><div id="439" class="line none">  439     int <a href="../../../../include/aws/cryptosdk/cipher.h.html#77">iv_len</a>;           // default: DEFAULT_IV_LEN.</div><div id="440" class="line none">  440     bool <a href="evp_override.c.html#440">iv_set</a>;          // boolean marks if iv has been set. Default:false.</div><div id="441" class="line none">  441     bool <a href="evp_override.c.html#441">padding</a>;         // boolean marks if padding is enabled. Default:true.</div><div id="442" class="line none">  442     bool <a href="evp_override.c.html#442">data_processed</a>;  // boolean marks if has encrypt/decrypt final has been called. Default:false.</div><div id="443" class="line none">  443     int <a href="evp_override.c.html#443">data_remaining</a>;   // how much is left to be encrypted/decrypted. Default: 0.</div><div id="444" class="line none">  444 };</div><div id="445" class="line none">  445 </div><div id="446" class="line none">  446 /*</div><div id="447" class="line none">  447  * EVP_CIPHER_CTX_new() creates a cipher context.</div><div id="448" class="line none">  448  */</div><div id="449" class="line none">  449 <a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="evp_override.c.html#449">EVP_CIPHER_CTX_new</a>() {</div><div id="450" class="line none">  450     <a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *cipher_ctx = <a href="../../aws-c-common/verification/cbmc/sources/proof_allocators.c.html#76">can_fail_malloc</a>(sizeof(<a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a>));</div><div id="451" class="line none">  451     if (cipher_ctx) {</div><div id="452" class="line none">  452         cipher_ctx-&gt;<a href="../../../../include/aws/cryptosdk/cipher.h.html#77">iv_len</a>         = <a href="evp_override.c.html#24">DEFAULT_IV_LEN</a>;</div><div id="453" class="line none">  453         cipher_ctx-&gt;<a href="evp_override.c.html#440">iv_set</a>         = false;</div><div id="454" class="line none">  454         cipher_ctx-&gt;<a href="evp_override.c.html#441">padding</a>        = true;</div><div id="455" class="line none">  455         cipher_ctx-&gt;<a href="evp_override.c.html#442">data_processed</a> = false;</div><div id="456" class="line none">  456         cipher_ctx-&gt;<a href="evp_override.c.html#443">data_remaining</a> = 0;</div><div id="457" class="line none">  457         cipher_ctx-&gt;<a href="evp_override.c.html#437">cipher</a>         = NULL;</div><div id="458" class="line none">  458     }</div><div id="459" class="line none">  459     return cipher_ctx;</div><div id="460" class="line none">  460 }</div><div id="461" class="line none">  461 </div><div id="462" class="line none">  462 /*</div><div id="463" class="line none">  463  * EVP_CipherInit_ex(), EVP_CipherUpdate() and EVP_CipherFinal_ex() are functions that can be used for</div><div id="464" class="line none">  464  * decryption or encryption. The operation performed depends on the value of the enc parameter.</div><div id="465" class="line none">  465  * It should be set to 1 for encryption, 0 for decryption and -1 to leave the value unchanged (the actual value of 'enc'</div><div id="466" class="line none">  466  * being supplied in a previous call). Return 1 for success and 0 for failure.</div><div id="467" class="line none">  467  */</div><div id="468" class="line none">  468 int <a href="evp_override.c.html#468">EVP_CipherInit_ex</a>(</div><div id="469" class="line none">  469     <a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>,</div><div id="470" class="line none">  470     const <a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> *<a href="evp_override.c.html#437">cipher</a>,</div><div id="471" class="line none">  471     <a href="../../include/openssl/ossl_typ.h.html#44">ENGINE</a> *<a href="../../aws-c-common/include/aws/common/allocator.h.html#22">impl</a>,</div><div id="472" class="line none">  472     const unsigned char *<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>,</div><div id="473" class="line none">  473     const unsigned char *<a href="../../../../include/aws/cryptosdk/private/header.h.html#31">iv</a>,</div><div id="474" class="line none">  474     int enc) {</div><div id="475" class="line none">  475     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="476" class="line none">  476     assert(enc == 0 || enc == 1 || enc == -1);</div><div id="477" class="line none">  477     if (enc != -1) {</div><div id="478" class="line none">  478         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#438">encrypt</a> = enc;</div><div id="479" class="line none">  479     }</div><div id="480" class="line none">  480     if (<a href="evp_override.c.html#437">cipher</a>) {</div><div id="481" class="line none">  481         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#437">cipher</a> = <a href="evp_override.c.html#437">cipher</a>;</div><div id="482" class="line none">  482     }</div><div id="483" class="line none">  483     if (<a href="../../../../include/aws/cryptosdk/private/header.h.html#31">iv</a>) {</div><div id="484" class="line none">  484         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#440">iv_set</a> = true;</div><div id="485" class="line none">  485     }</div><div id="486" class="line none">  486     int rv;</div><div id="487" class="line none">  487     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="488" class="line none">  488     return rv;</div><div id="489" class="line none">  489 }</div><div id="490" class="line none">  490 </div><div id="491" class="line none">  491 /*</div><div id="492" class="line none">  492  * EVP_CIPHER_CTX_ctrl() allows various cipher specific parameters to be determined and set.</div><div id="493" class="line none">  493  */</div><div id="494" class="line none">  494 int <a href="evp_override.c.html#494">EVP_CIPHER_CTX_ctrl</a>(<a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, int type, int arg, void *<a href="../../aws-c-common/include/aws/common/byte_buf.h.html#41">ptr</a>) {</div><div id="495" class="line none">  495     if (type == EVP_CTRL_GCM_SET_IVLEN || type == EVP_CTRL_AEAD_SET_IVLEN) {</div><div id="496" class="line none">  496         assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#440">iv_set</a> == false);</div><div id="497" class="line none">  497         /* iv length must be positive */</div><div id="498" class="line none">  498         assert(arg &gt; 0);</div><div id="499" class="line none">  499         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../include/aws/cryptosdk/cipher.h.html#77">iv_len</a> = arg;</div><div id="500" class="line none">  500     }</div><div id="501" class="line none">  501 </div><div id="502" class="line none">  502     /* Only legal when encrypting data. */</div><div id="503" class="line none">  503     assert(<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/utils.h.html#19">IMPLIES</a>(type == EVP_CTRL_GCM_GET_TAG, <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#438">encrypt</a> == 1));</div><div id="504" class="line none">  504     assert(<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/utils.h.html#19">IMPLIES</a>(type == EVP_CTRL_GCM_GET_TAG, <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#442">data_processed</a> == true));</div><div id="505" class="line none">  505     /* Need to be able to write taglen (arg) bytes to buffer ptr. */</div><div id="506" class="line none">  506     assert(<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/utils.h.html#19">IMPLIES</a>(type == EVP_CTRL_GCM_GET_TAG, AWS_MEM_IS_WRITABLE(<a href="../../aws-c-common/include/aws/common/byte_buf.h.html#41">ptr</a>, arg)));</div><div id="507" class="line none">  507 </div><div id="508" class="line none">  508     /* Only legal when decrypting data. */</div><div id="509" class="line none">  509     assert(<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/utils.h.html#19">IMPLIES</a>(type == EVP_CTRL_GCM_SET_TAG, <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#438">encrypt</a> == 0));</div><div id="510" class="line none">  510     /* Need to be able to write taglen (arg) bytes to buffer ptr. */</div><div id="511" class="line none">  511     assert(<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/utils.h.html#19">IMPLIES</a>(type == EVP_CTRL_GCM_SET_TAG, AWS_MEM_IS_WRITABLE(<a href="../../aws-c-common/include/aws/common/byte_buf.h.html#41">ptr</a>, arg)));</div><div id="512" class="line none">  512 </div><div id="513" class="line none">  513     int rv;</div><div id="514" class="line none">  514     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="515" class="line none">  515     return rv;</div><div id="516" class="line none">  516 }</div><div id="517" class="line none">  517 </div><div id="518" class="line none">  518 /*</div><div id="519" class="line none">  519  * EVP_CIPHER_CTX_free() clears all information from a cipher context and free up any allocated memory associate with</div><div id="520" class="line none">  520  * it, including ctx itself. This function should be called after all operations using a cipher are complete so</div><div id="521" class="line none">  521  * sensitive information does not remain in memory.</div><div id="522" class="line none">  522  */</div><div id="523" class="line none">  523 void <a href="evp_override.c.html#523">EVP_CIPHER_CTX_free</a>(<a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="524" class="line none">  524     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="525" class="line none">  525         free(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>);</div><div id="526" class="line none">  526     }</div><div id="527" class="line none">  527 }</div><div id="528" class="line none">  528 </div><div id="529" class="line none">  529 /*</div><div id="530" class="line none">  530  * EVP_EncryptInit_ex() sets up cipher context ctx for encryption with cipher type from ENGINE impl.</div><div id="531" class="line none">  531  * ctx must be created before calling this function. type is normally supplied by a function such as EVP_aes_256_cbc().</div><div id="532" class="line none">  532  * If impl is NULL then the default implementation is used. key is the symmetric key to use and iv is the IV to use (if</div><div id="533" class="line none">  533  * necessary), the actual number of bytes used for the key and IV depends on the cipher. It is possible to set all</div><div id="534" class="line none">  534  * parameters to NULL except type in an initial call and supply the remaining parameters in subsequent calls, all of</div><div id="535" class="line none">  535  * which have type set to NULL. This is done when the default cipher parameters are not appropriate.</div><div id="536" class="line none">  536  */</div><div id="537" class="line none">  537 int <a href="evp_override.c.html#537">EVP_EncryptInit_ex</a>(</div><div id="538" class="line none">  538     <a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, const <a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> *type, <a href="../../include/openssl/ossl_typ.h.html#44">ENGINE</a> *<a href="../../aws-c-common/include/aws/common/allocator.h.html#22">impl</a>, const unsigned char *<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>, const unsigned char *<a href="../../../../include/aws/cryptosdk/private/header.h.html#31">iv</a>) {</div><div id="539" class="line none">  539     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="540" class="line none">  540     assert(type != NULL);</div><div id="541" class="line none">  541     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#438">encrypt</a> = 1;</div><div id="542" class="line none">  542     int rv;</div><div id="543" class="line none">  543     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="544" class="line none">  544     return rv;</div><div id="545" class="line none">  545 }</div><div id="546" class="line none">  546 </div><div id="547" class="line none">  547 /*</div><div id="548" class="line none">  548  * EVP_DecryptInit_ex() is the corresponding decryption operation.</div><div id="549" class="line none">  549  */</div><div id="550" class="line none">  550 int <a href="evp_override.c.html#550">EVP_DecryptInit_ex</a>(</div><div id="551" class="line none">  551     <a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, const <a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> *type, <a href="../../include/openssl/ossl_typ.h.html#44">ENGINE</a> *<a href="../../aws-c-common/include/aws/common/allocator.h.html#22">impl</a>, const unsigned char *<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>, const unsigned char *<a href="../../../../include/aws/cryptosdk/private/header.h.html#31">iv</a>) {</div><div id="552" class="line none">  552     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="553" class="line none">  553     assert(type != NULL);</div><div id="554" class="line none">  554     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#438">encrypt</a> = 0;</div><div id="555" class="line none">  555     int rv;</div><div id="556" class="line none">  556     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="557" class="line none">  557     return rv;</div><div id="558" class="line none">  558 }</div><div id="559" class="line none">  559 </div><div id="560" class="line none">  560 /*</div><div id="561" class="line none">  561  * EVP_CipherInit_ex(), EVP_CipherUpdate() and EVP_CipherFinal_ex() are functions that can be used for decryption</div><div id="562" class="line none">  562  * or encryption. The operation performed depends on the value of the enc parameter. It should be set to 1 for</div><div id="563" class="line none">  563  * encryption, 0 for decryption and -1 to leave the value unchanged (the actual value of 'enc' being supplied in a</div><div id="564" class="line none">  564  * previous call). Return 1 for success and 0 for failure.</div><div id="565" class="line none">  565  * To specify any additional authenticated data (AAD) a call to EVP_CipherUpdate(), EVP_EncryptUpdate() or</div><div id="566" class="line none">  566  * EVP_DecryptUpdate() should be made with the output parameter out set to NULL.</div><div id="567" class="line none">  567  */</div><div id="568" class="line none">  568 int <a href="evp_override.c.html#568">EVP_CipherUpdate</a>(<a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *out, int *outl, const unsigned char *in, int inl) {</div><div id="569" class="line none">  569     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="570" class="line none">  570     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#438">encrypt</a>) {</div><div id="571" class="line none">  571         return <a href="evp_override.c.html#583">EVP_EncryptUpdate</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, out, outl, in, inl);</div><div id="572" class="line none">  572     } else</div><div id="573" class="line none">  573         return <a href="evp_override.c.html#619">EVP_DecryptUpdate</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, out, outl, in, inl);</div><div id="574" class="line none">  574 }</div><div id="575" class="line none">  575 </div><div id="576" class="line none">  576 /*</div><div id="577" class="line none">  577  * EVP_EncryptUpdate() encrypts inl bytes from the buffer in and writes the encrypted version to out.</div><div id="578" class="line none">  578  * This function can be called multiple times to encrypt successive blocks of data. The amount of data written depends</div><div id="579" class="line none">  579  * on the block alignment of the encrypted data: as a result the amount of data written may be anything from zero bytes</div><div id="580" class="line none">  580  * to (inl + cipher_block_size - 1) so out should contain sufficient room. The actual number of bytes written is placed</div><div id="581" class="line none">  581  * in outl. It also checks if in and out are partially overlapping, and if they are 0 is returned to indicate failure.</div><div id="582" class="line none">  582  */</div><div id="583" class="line none">  583 int <a href="evp_override.c.html#583">EVP_EncryptUpdate</a>(<a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *out, int *outl, const unsigned char *in, int inl) {</div><div id="584" class="line none">  584     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="585" class="line none">  585     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#442">data_processed</a> == false);</div><div id="586" class="line none">  586     int rv;</div><div id="587" class="line none">  587     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="588" class="line none">  588     if (out == NULL) {  // specifying aad</div><div id="589" class="line none">  589         return rv;</div><div id="590" class="line none">  590     }</div><div id="591" class="line none">  591     size_t out_size;</div><div id="592" class="line none">  592     __CPROVER_assume(out_size &gt;= 0);</div><div id="593" class="line none">  593     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#437">cipher</a>) {</div><div id="594" class="line none">  594         __CPROVER_assume(out_size &lt;= inl - 1);</div><div id="595" class="line none">  595     } else {</div><div id="596" class="line none">  596         __CPROVER_assume(out_size &lt;= inl);</div><div id="597" class="line none">  597         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#443">data_remaining</a> = inl - out_size;</div><div id="598" class="line none">  598     }</div><div id="599" class="line none">  599     /*</div><div id="600" class="line none">  600      * This check is redundant with the following AWS_MEM_IS_WRITABLE.</div><div id="601" class="line none">  601      * AWS_MEM_IS_WRITABLE is a macro for __CPROVER_w_ok primitive, which</div><div id="602" class="line none">  602      * should return true if out is writable upt to out_size bytes;</div><div id="603" class="line none">  603      * however, AWS_MEM_IS_WRITABLE has been replaced by a simple nullness check for now.</div><div id="604" class="line none">  604      * Thus, we also include an additional check using __CPROVER_OBJECT_SIZE.</div><div id="605" class="line none">  605      */</div><div id="606" class="line none">  606     assert(__CPROVER_OBJECT_SIZE(out) &gt;= out_size);</div><div id="607" class="line none">  607     assert(AWS_MEM_IS_WRITABLE(out, out_size));</div><div id="608" class="line none">  608     *outl = out_size;</div><div id="609" class="line none">  609     return rv;</div><div id="610" class="line none">  610 }</div><div id="611" class="line none">  611 </div><div id="612" class="line none">  612 /*</div><div id="613" class="line none">  613  * EVP_DecryptUpdate() is the corresponding decryption operation.</div><div id="614" class="line none">  614  * EVP_DecryptFinal() will return an error code if padding is enabled and the final block is not correctly formatted.</div><div id="615" class="line none">  615  * The parameters and restrictions are identical to the encryption operations except that if padding is enabled the</div><div id="616" class="line none">  616  * decrypted data buffer out passed to EVP_DecryptUpdate() should have sufficient room for (inl + cipher_block_size)</div><div id="617" class="line none">  617  * bytes unless the cipher block size is 1 in which case inl bytes is sufficient.</div><div id="618" class="line none">  618  */</div><div id="619" class="line none">  619 int <a href="evp_override.c.html#619">EVP_DecryptUpdate</a>(<a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *out, int *outl, const unsigned char *in, int inl) {</div><div id="620" class="line none">  620     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="621" class="line none">  621     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#442">data_processed</a> == false);</div><div id="622" class="line none">  622     int rv;</div><div id="623" class="line none">  623     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="624" class="line none">  624     if (out == NULL) {  // specifying aad</div><div id="625" class="line none">  625         return rv;</div><div id="626" class="line none">  626     }</div><div id="627" class="line none">  627     size_t out_size;</div><div id="628" class="line none">  628     __CPROVER_assume(out_size &gt;= 0);</div><div id="629" class="line none">  629     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#437">cipher</a>) {</div><div id="630" class="line none">  630         if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#441">padding</a>) {</div><div id="631" class="line none">  631             __CPROVER_assume(out_size &lt;= inl);</div><div id="632" class="line none">  632         }</div><div id="633" class="line none">  633     } else {</div><div id="634" class="line none">  634         __CPROVER_assume(out_size &lt;= inl);</div><div id="635" class="line none">  635         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#443">data_remaining</a> = inl - out_size;</div><div id="636" class="line none">  636     }</div><div id="637" class="line none">  637     /*</div><div id="638" class="line none">  638      * This check is redundant with the following AWS_MEM_IS_WRITABLE.</div><div id="639" class="line none">  639      * AWS_MEM_IS_WRITABLE is a macro for __CPROVER_w_ok primitive, which</div><div id="640" class="line none">  640      * should return true if out is writable upt to out_size bytes;</div><div id="641" class="line none">  641      * however, AWS_MEM_IS_WRITABLE has been replaced by a simple nullness check for now.</div><div id="642" class="line none">  642      * Thus, we also include an additional check using __CPROVER_OBJECT_SIZE.</div><div id="643" class="line none">  643      */</div><div id="644" class="line none">  644     assert(__CPROVER_OBJECT_SIZE(out) &gt;= out_size);</div><div id="645" class="line none">  645     assert(AWS_MEM_IS_WRITABLE(out, out_size));</div><div id="646" class="line none">  646     *outl = out_size;</div><div id="647" class="line none">  647     return rv;</div><div id="648" class="line none">  648 }</div><div id="649" class="line none">  649 </div><div id="650" class="line none">  650 /*</div><div id="651" class="line none">  651  * If padding is enabled (the default) then EVP_EncryptFinal_ex() encrypts the "final" data, that is any data that</div><div id="652" class="line none">  652  * remains in a partial block. It uses standard block padding (aka PKCS padding).</div><div id="653" class="line none">  653  * The encrypted final data is written to out which should have sufficient space for one cipher block.</div><div id="654" class="line none">  654  * The number of bytes written is placed in outl. After this function is called the encryption operation is finished and</div><div id="655" class="line none">  655  * no further calls to EVP_EncryptUpdate() should be made.</div><div id="656" class="line none">  656  */</div><div id="657" class="line none">  657 int <a href="evp_override.c.html#657">EVP_EncryptFinal_ex</a>(<a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *out, int *outl) {</div><div id="658" class="line none">  658     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="659" class="line none">  659     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#441">padding</a> == true) {</div><div id="660" class="line none">  660         *outl = <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#443">data_remaining</a>;</div><div id="661" class="line none">  661         assert(AWS_MEM_IS_WRITABLE(out, <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#443">data_remaining</a>));</div><div id="662" class="line none">  662     }</div><div id="663" class="line none">  663     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#442">data_processed</a> = true;</div><div id="664" class="line none">  664     int rv;</div><div id="665" class="line none">  665     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="666" class="line none">  666     return rv;</div><div id="667" class="line none">  667 }</div><div id="668" class="line none">  668 /*</div><div id="669" class="line none">  669  * EVP_DecryptFinal_ex() is the corresponding decryption operation.</div><div id="670" class="line none">  670  * EVP_DecryptFinal() will return an error code if padding is enabled and the final block is not correctly formatted.</div><div id="671" class="line none">  671  * The parameters and restrictions are identical to the encryption operations except that if padding is enabled the</div><div id="672" class="line none">  672  * decrypted data buffer out passed to EVP_DecryptUpdate() should have sufficient room for (inl + cipher_block_size)</div><div id="673" class="line none">  673  * bytes unless the cipher block size is 1 in which case inl bytes is sufficient.</div><div id="674" class="line none">  674  */</div><div id="675" class="line none">  675 int <a href="evp_override.c.html#675">EVP_DecryptFinal_ex</a>(<a href="../../include/openssl/ossl_typ.h.html#39">EVP_CIPHER_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *outm, int *outl) {</div><div id="676" class="line none">  676     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> != NULL);</div><div id="677" class="line none">  677     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#441">padding</a> == true) {</div><div id="678" class="line none">  678         *outl = <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#443">data_remaining</a>;</div><div id="679" class="line none">  679         assert(AWS_MEM_IS_WRITABLE(outm, <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#443">data_remaining</a>));</div><div id="680" class="line none">  680     }</div><div id="681" class="line none">  681     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="evp_override.c.html#442">data_processed</a> = true;</div><div id="682" class="line none">  682     int rv;</div><div id="683" class="line none">  683     __CPROVER_assume(rv == 0 || rv == 1);</div><div id="684" class="line none">  684     return rv;</div><div id="685" class="line none">  685 }</div><div id="686" class="line none">  686 </div><div id="687" class="line none">  687 enum <a href="evp_override.c.html#687">evp_sha</a> { <a href="evp_override.c.html#687">EVP_SHA256</a>, <a href="evp_override.c.html#687">EVP_SHA384</a>, <a href="evp_override.c.html#687">EVP_SHA512</a> };</div><div id="688" class="line none">  688 </div><div id="689" class="line none">  689 /* Abstraction of the EVP_MD struct */</div><div id="690" class="line none">  690 struct <a href="../../include/openssl/ossl_typ.h.html#40">evp_md_st</a> {</div><div id="691" class="line none">  691     enum <a href="evp_override.c.html#687">evp_sha</a> <a href="evp_override.c.html#412">from</a>;</div><div id="692" class="line none">  692     size_t <a href="../../aws-c-common/include/aws/common/private/hash_table_impl.h.html#35">size</a>;</div><div id="693" class="line none">  693 };</div><div id="694" class="line none">  694 </div><div id="695" class="line none">  695 /*</div><div id="696" class="line none">  696  * Description: The SHA-2 SHA-224, SHA-256, SHA-512/224, SHA512/256, SHA-384 and SHA-512 algorithms, which generate 224,</div><div id="697" class="line none">  697  * 256, 224, 256, 384 and 512 bits respectively of output from a given input. Return values: These functions return a</div><div id="698" class="line none">  698  * EVP_MD structure that contains the implementation of the symmetric cipher.</div><div id="699" class="line none">  699  */</div><div id="700" class="line none">  700 const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *<a href="evp_override.c.html#700">EVP_sha256</a>() {</div><div id="701" class="line none">  701     static const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> md = { <a href="evp_override.c.html#687">EVP_SHA256</a>, 32 };</div><div id="702" class="line hit">  702     return &amp;md;</div><div id="703" class="line hit">  703 }</div><div id="704" class="line none">  704 const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *<a href="evp_override.c.html#704">EVP_sha384</a>() {</div><div id="705" class="line none">  705     static const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> md = { <a href="evp_override.c.html#687">EVP_SHA384</a>, 48 };</div><div id="706" class="line hit">  706     return &amp;md;</div><div id="707" class="line hit">  707 }</div><div id="708" class="line none">  708 const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *<a href="evp_override.c.html#708">EVP_sha512</a>() {</div><div id="709" class="line none">  709     static const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> md = { <a href="evp_override.c.html#687">EVP_SHA512</a>, 64 };</div><div id="710" class="line hit">  710     return &amp;md;</div><div id="711" class="line hit">  711 }</div><div id="712" class="line none">  712 </div><div id="713" class="line none">  713 /* Description: Return the size of the message digest when passed an EVP_MD or an EVP_MD_CTX structure, i.e. the size of</div><div id="714" class="line none">  714  * the hash.</div><div id="715" class="line none">  715  */</div><div id="716" class="line none">  716 int <a href="evp_override.c.html#716">EVP_MD_size</a>(const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *md) {</div><div id="717" class="line missed">  717     if (md-&gt;<a href="evp_override.c.html#412">from</a> == <a href="evp_override.c.html#687">EVP_SHA256</a>) {</div><div id="718" class="line missed">  718         return 256;</div><div id="719" class="line none">  719     }</div><div id="720" class="line missed">  720     if (md-&gt;<a href="evp_override.c.html#412">from</a> == <a href="evp_override.c.html#687">EVP_SHA384</a>) {</div><div id="721" class="line missed">  721         return 384;</div><div id="722" class="line none">  722     }</div><div id="723" class="line missed">  723     return 512;</div><div id="724" class="line missed">  724 }</div><div id="725" class="line none">  725 </div><div id="726" class="line none">  726 /*</div><div id="727" class="line none">  727  * Description: Allocates and returns a digest context.</div><div id="728" class="line none">  728  */</div><div id="729" class="line none">  729 <a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="evp_override.c.html#729">EVP_MD_CTX_new</a>() {</div><div id="730" class="line none">  730     <a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a> = <a href="../../aws-c-common/verification/cbmc/sources/proof_allocators.c.html#76">can_fail_malloc</a>(sizeof(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a>));</div><div id="731" class="line none">  731 </div><div id="732" class="line none">  732     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="733" class="line none">  733         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a> = false;</div><div id="734" class="line none">  734         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>           = NULL;</div><div id="735" class="line none">  735         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;digest_size    = 0;</div><div id="736" class="line none">  736     }</div><div id="737" class="line none">  737 </div><div id="738" class="line none">  738     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>;</div><div id="739" class="line none">  739 }</div><div id="740" class="line none">  740 </div><div id="741" class="line none">  741 /*</div><div id="742" class="line none">  742  * Description: Return the size of the message digest when passed an EVP_MD or an EVP_MD_CTX structure, i.e. the size of</div><div id="743" class="line none">  743  * the hash. Return values: Returns the digest or block size in bytes.</div><div id="744" class="line none">  744  */</div><div id="745" class="line none">  745 int <a href="evp_override.c.html#745">EVP_MD_CTX_size</a>(const <a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="746" class="line none">  746     assert(<a href="evp_override.c.html#1035">evp_md_ctx_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>));</div><div id="747" class="line none">  747     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;digest_size;</div><div id="748" class="line none">  748 }</div><div id="749" class="line none">  749 </div><div id="750" class="line none">  750 /*</div><div id="751" class="line none">  751  * Description: Cleans up digest context ctx and frees up the space allocated to it.</div><div id="752" class="line none">  752  */</div><div id="753" class="line none">  753 void <a href="evp_override.c.html#753">EVP_MD_CTX_free</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="754" class="line none">  754     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="755" class="line none">  755         <a href="evp_override.c.html#74">EVP_PKEY_free</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>);</div><div id="756" class="line none">  756         free(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>);</div><div id="757" class="line none">  757     }</div><div id="758" class="line none">  758 }</div><div id="759" class="line none">  759 </div><div id="760" class="line none">  760 /*</div><div id="761" class="line none">  761  * Description: Sets up digest context ctx to use a digest type from ENGINE impl. type will typically be supplied by</div><div id="762" class="line none">  762  * a function such as EVP_sha1(). If impl is NULL then the default implementation of digest type is used. Return</div><div id="763" class="line none">  763  * values: Returns 1 for success and 0 for failure.</div><div id="764" class="line none">  764  */</div><div id="765" class="line none">  765 int <a href="evp_override.c.html#765">EVP_DigestInit_ex</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *type, <a href="../../include/openssl/ossl_typ.h.html#44">ENGINE</a> *<a href="../../aws-c-common/include/aws/common/allocator.h.html#22">impl</a>) {</div><div id="766" class="line none">  766     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>);</div><div id="767" class="line none">  767     assert(!<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a>);</div><div id="768" class="line none">  768     assert(<a href="evp_override.c.html#1029">evp_md_is_valid</a>(type));</div><div id="769" class="line none">  769     assert(!<a href="../../aws-c-common/include/aws/common/allocator.h.html#22">impl</a>);  // Assuming that this function is always called in ESDK with impl == NULL</div><div id="770" class="line none">  770 </div><div id="771" class="line none">  771     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) return 0;</div><div id="772" class="line none">  772 </div><div id="773" class="line none">  773     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a> = true;</div><div id="774" class="line none">  774     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;digest_size    = type-&gt;<a href="../../aws-c-common/include/aws/common/private/hash_table_impl.h.html#35">size</a>;</div><div id="775" class="line none">  775 </div><div id="776" class="line none">  776     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a>;</div><div id="777" class="line none">  777 }</div><div id="778" class="line none">  778 </div><div id="779" class="line none">  779 /*</div><div id="780" class="line none">  780  * Description: Behaves in the same way as EVP_DigestInit_ex() except it always uses the default digest implementation.</div><div id="781" class="line none">  781  * Return value: Returns 1 for success and 0 for failure.</div><div id="782" class="line none">  782  */</div><div id="783" class="line none">  783 int <a href="evp_override.c.html#783">EVP_DigestInit</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *type) {</div><div id="784" class="line none">  784     return <a href="evp_override.c.html#765">EVP_DigestInit_ex</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, type, NULL);</div><div id="785" class="line none">  785 }</div><div id="786" class="line none">  786 </div><div id="787" class="line none">  787 /*</div><div id="788" class="line none">  788  * Description: Hashes cnt bytes of data at d into the digest context ctx. This function can be called several times</div><div id="789" class="line none">  789  * on the same ctx to hash additional data. Return values: Returns 1 for success and 0 for failure.</div><div id="790" class="line none">  790  */</div><div id="791" class="line none">  791 int <a href="evp_override.c.html#791">EVP_DigestUpdate</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, const void *d, size_t cnt) {</div><div id="792" class="line none">  792     assert(<a href="evp_override.c.html#1035">evp_md_ctx_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>));</div><div id="793" class="line none">  793     assert(d);</div><div id="794" class="line none">  794     assert(AWS_MEM_IS_READABLE(d, cnt));</div><div id="795" class="line none">  795 </div><div id="796" class="line none">  796     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="797" class="line none">  797         <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a> = false;</div><div id="798" class="line none">  798         return 0;</div><div id="799" class="line none">  799     }</div><div id="800" class="line none">  800 </div><div id="801" class="line none">  801     return 1;</div><div id="802" class="line none">  802 }</div><div id="803" class="line none">  803 </div><div id="804" class="line none">  804 /*</div><div id="805" class="line none">  805  * Description: Retrieves the digest value from ctx and places it in md. If the s parameter is not NULL then the</div><div id="806" class="line none">  806  * number of bytes of data written (i.e. the length of the digest) will be written to the integer at s, at most</div><div id="807" class="line none">  807  * EVP_MAX_MD_SIZE bytes will be written. After calling EVP_DigestFinal_ex() no additional calls to</div><div id="808" class="line none">  808  * EVP_DigestUpdate() can be made, but EVP_DigestInit_ex() can be called to initialize a new digest operation.</div><div id="809" class="line none">  809  * Return values: Returns 1 for success and 0 for failure.</div><div id="810" class="line none">  810  */</div><div id="811" class="line none">  811 int <a href="evp_override.c.html#811">EVP_DigestFinal_ex</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *md, unsigned int *<a href="ec_override.c.html#283">s</a>) {</div><div id="812" class="line none">  812     assert(<a href="evp_override.c.html#1035">evp_md_ctx_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>));</div><div id="813" class="line none">  813     assert(md);</div><div id="814" class="line none">  814     assert(AWS_MEM_IS_WRITABLE(md, <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;digest_size));</div><div id="815" class="line none">  815     // s can be NULL</div><div id="816" class="line none">  816 </div><div id="817" class="line none">  817     <a href="ec_override.c.html#486">write_unconstrained_data</a>(md, <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;digest_size);</div><div id="818" class="line none">  818     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a> = false;</div><div id="819" class="line none">  819 </div><div id="820" class="line none">  820     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) {</div><div id="821" class="line none">  821         // Something went wrong, can't guarantee *s will have the correct value</div><div id="822" class="line none">  822         unsigned int garbage;</div><div id="823" class="line none">  823         if (<a href="ec_override.c.html#283">s</a>) *<a href="ec_override.c.html#283">s</a> = garbage;</div><div id="824" class="line none">  824         return 0;</div><div id="825" class="line none">  825     }</div><div id="826" class="line none">  826 </div><div id="827" class="line none">  827     if (<a href="ec_override.c.html#283">s</a>) *<a href="ec_override.c.html#283">s</a> = <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;digest_size;</div><div id="828" class="line none">  828 </div><div id="829" class="line none">  829     return 1;</div><div id="830" class="line none">  830 }</div><div id="831" class="line none">  831 </div><div id="832" class="line none">  832 /*</div><div id="833" class="line none">  833  * Description: Similar to EVP_DigestFinal_ex() except the digest context ctx is automatically cleaned up.</div><div id="834" class="line none">  834  * Return values: Returns 1 for success and 0 for failure.</div><div id="835" class="line none">  835  */</div><div id="836" class="line none">  836 int <a href="evp_override.c.html#836">EVP_DigestFinal</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *md, unsigned int *<a href="ec_override.c.html#283">s</a>) {</div><div id="837" class="line none">  837     int ret;</div><div id="838" class="line none">  838     ret = <a href="evp_override.c.html#811">EVP_DigestFinal_ex</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, md, <a href="ec_override.c.html#283">s</a>);</div><div id="839" class="line none">  839     // Context is "cleaned up", but not sure how this restricts future operations</div><div id="840" class="line none">  840     // Assuming that EVP_PKEY is not freed, and that EVP_MD_CTX_free still needs to be called</div><div id="841" class="line none">  841     return ret;</div><div id="842" class="line none">  842 }</div><div id="843" class="line none">  843 </div><div id="844" class="line none">  844 /*</div><div id="845" class="line none">  845  * Description: EVP_DigestVerifyInit() sets up verification context ctx to use digest type from ENGINE e and public key</div><div id="846" class="line none">  846  * pkey. ctx must be created with EVP_MD_CTX_new() before calling this function. If pctx is not NULL, the EVP_PKEY_CTX</div><div id="847" class="line none">  847  * of the verification operation will be written to *pctx: this can be used to set alternative verification options.</div><div id="848" class="line none">  848  * Note that any existing value in *pctx is overwritten. The EVP_PKEY_CTX value returned must not be freed directly by</div><div id="849" class="line none">  849  * the application if ctx is not assigned an EVP_PKEY_CTX value before being passed to EVP_DigestVerifyInit() (which</div><div id="850" class="line none">  850  * means the EVP_PKEY_CTX is created inside EVP_DigestVerifyInit() and it will be freed automatically when the</div><div id="851" class="line none">  851  * EVP_MD_CTX is freed).</div><div id="852" class="line none">  852  * Return values: EVP_DigestVerifyInit() EVP_DigestVerifyUpdate() return 1 for success and 0 for</div><div id="853" class="line none">  853  * failure.</div><div id="854" class="line none">  854  */</div><div id="855" class="line none">  855 int <a href="evp_override.c.html#855">EVP_DigestVerifyInit</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, <a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> **pctx, const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *type, <a href="../../include/openssl/ossl_typ.h.html#44">ENGINE</a> *e, <a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>) {</div><div id="856" class="line none">  856     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>);</div><div id="857" class="line none">  857     assert(!<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a>);</div><div id="858" class="line none">  858     assert(!pctx);  // Assuming that this function is always called in ESDK with pctx == NULL</div><div id="859" class="line none">  859     assert(<a href="evp_override.c.html#1029">evp_md_is_valid</a>(type));</div><div id="860" class="line none">  860     assert(!e);  // Assuming that this function is always called in ESDK with e == NULL</div><div id="861" class="line none">  861     assert(<a href="evp_override.c.html#994">evp_pkey_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>));</div><div id="862" class="line none">  862 </div><div id="863" class="line none">  863     if (<a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#15">nondet_bool</a>()) return 0;</div><div id="864" class="line none">  864 </div><div id="865" class="line none">  865     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a> = true;</div><div id="866" class="line none">  866     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>           = <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>;</div><div id="867" class="line none">  867     <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;<a href="ec_override.c.html#82">references</a> += 1;</div><div id="868" class="line none">  868     <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;digest_size = type-&gt;<a href="../../aws-c-common/include/aws/common/private/hash_table_impl.h.html#35">size</a>;</div><div id="869" class="line none">  869 </div><div id="870" class="line none">  870     return 1;</div><div id="871" class="line none">  871 }</div><div id="872" class="line none">  872 </div><div id="873" class="line none">  873 /*</div><div id="874" class="line none">  874  * Description: EVP_DigestVerifyFinal() verifies the data in ctx against the signature in sig of length siglen.</div><div id="875" class="line none">  875  * Return values: EVP_DigestVerifyFinal() and EVP_DigestVerify() return 1 for success; any other value indicates</div><div id="876" class="line none">  876  * failure. A return value of zero indicates that the signature did not verify successfully (that is, tbs did not match</div><div id="877" class="line none">  877  * the original data or the signature had an invalid form), while other values indicate a more serious error (and</div><div id="878" class="line none">  878  * sometimes also indicate an invalid signature form).</div><div id="879" class="line none">  879  */</div><div id="880" class="line none">  880 int <a href="evp_override.c.html#880">EVP_DigestVerifyFinal</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, const unsigned char *sig, size_t siglen) {</div><div id="881" class="line none">  881     assert(<a href="evp_override.c.html#1035">evp_md_ctx_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>));</div><div id="882" class="line none">  882     assert(sig);</div><div id="883" class="line none">  883     assert(AWS_MEM_IS_READABLE(sig, siglen));</div><div id="884" class="line none">  884 </div><div id="885" class="line none">  885     // Since this operation only performs verification, none of the arguments are modified</div><div id="886" class="line none">  886 </div><div id="887" class="line none">  887     return <a href="../../aws-c-common/verification/cbmc/include/proof_helpers/nondet.h.html#16">nondet_int</a>();</div><div id="888" class="line none">  888 }</div><div id="889" class="line none">  889 </div><div id="890" class="line none">  890 /* Abstraction of the HMAC_CTX struct has been moved to hmcac.h*/</div><div id="891" class="line none">  891 </div><div id="892" class="line none">  892 /*</div><div id="893" class="line none">  893  * Description: HMAC_CTX_init() initialises a HMAC_CTX before first use. It must be called.</div><div id="894" class="line none">  894  */</div><div id="895" class="line none">  895 void <a href="evp_override.c.html#895">HMAC_CTX_init</a>(<a href="../../include/openssl/ossl_typ.h.html#36">HMAC_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="896" class="line none">  896     <a href="../../include/openssl/ossl_typ.h.html#36">HMAC_CTX</a> *ctx_new = <a href="../../aws-c-common/verification/cbmc/sources/proof_allocators.c.html#76">can_fail_malloc</a>(sizeof(<a href="../../include/openssl/ossl_typ.h.html#36">HMAC_CTX</a>));</div><div id="897" class="line none">  897     __CPROVER_assume(ctx_new);  // cannot be null</div><div id="898" class="line none">  898     ctx_new-&gt;<a href="bn_override.c.html#26">is_initialized</a> = true;</div><div id="899" class="line none">  899     ctx_new-&gt;md             = malloc(sizeof(<a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a>));</div><div id="900" class="line none">  900     *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>                    = *ctx_new;</div><div id="901" class="line none">  901 }</div><div id="902" class="line none">  902 </div><div id="903" class="line none">  903 /*</div><div id="904" class="line none">  904 HMAC() computes the message authentication code of the n bytes at d using the hash function evp_md and the</div><div id="905" class="line none">  905 key key which is key_len bytes long.</div><div id="906" class="line none">  906 It places the result in md (which must have space for the output of the hash function,</div><div id="907" class="line none">  907 which is no more than EVP_MAX_MD_SIZE bytes). If md is NULL, the digest is placed in a static array.</div><div id="908" class="line none">  908 The size of the output is placed in md_len, unless it is NULL.</div><div id="909" class="line none">  909 Note: passing a NULL value for md to use the static array is not thread safe.</div><div id="910" class="line none">  910 */</div><div id="911" class="line none">  911 </div><div id="912" class="line none">  912 unsigned char *<a href="evp_override.c.html#912">HMAC</a>(</div><div id="913" class="line none">  913     const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *evp_md,</div><div id="914" class="line none">  914     const void *<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>,</div><div id="915" class="line none">  915     int key_len,</div><div id="916" class="line none">  916     const unsigned char *d,</div><div id="917" class="line none">  917     size_t n,</div><div id="918" class="line none">  918     unsigned char *md,</div><div id="919" class="line none">  919     unsigned int *md_len) {</div><div id="920" class="line none">  920     assert(evp_md != NULL);</div><div id="921" class="line none">  921     size_t amount_of_data_written;</div><div id="922" class="line none">  922     __CPROVER_assume(amount_of_data_written &lt;= EVP_MAX_MD_SIZE);</div><div id="923" class="line none">  923     if (md != NULL) {</div><div id="924" class="line none">  924         <a href="ec_override.c.html#486">write_unconstrained_data</a>(md, amount_of_data_written);</div><div id="925" class="line none">  925         *md_len = amount_of_data_written;</div><div id="926" class="line none">  926         return md;</div><div id="927" class="line none">  927     }</div><div id="928" class="line none">  928     // create a static array to return the result</div><div id="929" class="line none">  929     unsigned char *res = malloc(sizeof(unsigned char) * (amount_of_data_written + 1));</div><div id="930" class="line none">  930     <a href="ec_override.c.html#486">write_unconstrained_data</a>(res, amount_of_data_written);</div><div id="931" class="line none">  931     return res;</div><div id="932" class="line none">  932 }</div><div id="933" class="line none">  933 </div><div id="934" class="line none">  934 /*</div><div id="935" class="line none">  935 * HMAC_Init_ex() initializes or reuses a HMAC_CTX structure to use the hash function evp_md and key key.</div><div id="936" class="line none">  936 * If both are NULL (or evp_md is the same as the previous digest used by ctx and key is NULL) the existing key is</div><div id="937" class="line none">  937 reused.</div><div id="938" class="line none">  938 * ctx must have been created with HMAC_CTX_new() before the first use of an HMAC_CTX in this function.</div><div id="939" class="line none">  939 * N.B. HMAC_Init() had this undocumented behaviour in previous versions of OpenSSL - failure to switch to HMAC_Init_ex()</div><div id="940" class="line none">  940 in</div><div id="941" class="line none">  941 * programs that expect it will cause them to stop working.</div><div id="942" class="line none">  942 </div><div id="943" class="line none">  943 * NB: if HMAC_Init_ex() is called with key NULL and evp_md is not the same as the previous digest used by ctx then an</div><div id="944" class="line none">  944 * error is returned because reuse of an existing key with a different digest is not supported.</div><div id="945" class="line none">  945 *</div><div id="946" class="line none">  946 * Return 1 for success or 0 if an error occurred.</div><div id="947" class="line none">  947 */</div><div id="948" class="line none">  948 int <a href="evp_override.c.html#948">HMAC_Init_ex</a>(<a href="../../include/openssl/ossl_typ.h.html#36">HMAC_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, const void *<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a>, int <a href="../../aws-c-common/include/aws/common/byte_buf.h.html#27">len</a>, const <a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *md, <a href="../../include/openssl/ossl_typ.h.html#44">ENGINE</a> *<a href="../../aws-c-common/include/aws/common/allocator.h.html#22">impl</a>) {</div><div id="949" class="line none">  949     assert(<a href="evp_override.c.html#989">hmac_ctx_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>));</div><div id="950" class="line none">  950     if (md != NULL) {</div><div id="951" class="line none">  951         if (<a href="../../aws-c-common/include/aws/common/hash_table.h.html#64">key</a> != NULL) {</div><div id="952" class="line none">  952             <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;md = md;</div><div id="953" class="line none">  953         }</div><div id="954" class="line none">  954     }</div><div id="955" class="line none">  955     int rv;</div><div id="956" class="line none">  956     __CPROVER_assume(rv == 1 || rv == 0);</div><div id="957" class="line none">  957     return rv;</div><div id="958" class="line none">  958 }</div><div id="959" class="line none">  959 </div><div id="960" class="line none">  960 /*</div><div id="961" class="line none">  961  * HMAC_Update() can be called repeatedly with chunks of the message to be authenticated (len bytes at data).</div><div id="962" class="line none">  962  * Return 1 for success or 0 if an error occurred.</div><div id="963" class="line none">  963  */</div><div id="964" class="line none">  964 int <a href="evp_override.c.html#964">HMAC_Update</a>(<a href="../../include/openssl/ossl_typ.h.html#36">HMAC_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, const unsigned char *<a href="../../aws-c-common/include/aws/common/array_list.h.html#20">data</a>, size_t <a href="../../aws-c-common/include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="965" class="line none">  965     assert(<a href="evp_override.c.html#989">hmac_ctx_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>));</div><div id="966" class="line none">  966     int rv;</div><div id="967" class="line none">  967     __CPROVER_assume(rv == 1 || rv == 0);</div><div id="968" class="line none">  968     return rv;</div><div id="969" class="line none">  969 }</div><div id="970" class="line none">  970 </div><div id="971" class="line none">  971 /*</div><div id="972" class="line none">  972  *HMAC_Final() places the message authentication code in md, which must have space for the hash function output.</div><div id="973" class="line none">  973  */</div><div id="974" class="line none">  974 int <a href="evp_override.c.html#974">HMAC_Final</a>(<a href="../../include/openssl/ossl_typ.h.html#36">HMAC_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, unsigned char *md, unsigned int *<a href="../../aws-c-common/include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="975" class="line none">  975     assert(<a href="evp_override.c.html#989">hmac_ctx_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>));</div><div id="976" class="line none">  976     assert(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;md != NULL);</div><div id="977" class="line none">  977     int md_size = <a href="evp_override.c.html#716">EVP_MD_size</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;md);</div><div id="978" class="line none">  978     AWS_MEM_IS_WRITABLE(md, md_size);</div><div id="979" class="line none">  979     *<a href="../../aws-c-common/include/aws/common/byte_buf.h.html#27">len</a> = md_size;</div><div id="980" class="line none">  980     int rv;</div><div id="981" class="line none">  981     __CPROVER_assume(rv == 1 || rv == 0);</div><div id="982" class="line none">  982     __CPROVER_assume(AWS_MEM_IS_READABLE(md, md_size));</div><div id="983" class="line none">  983     return rv;</div><div id="984" class="line none">  984 }</div><div id="985" class="line none">  985 </div><div id="986" class="line none">  986 /* CBMC helper functions */</div><div id="987" class="line none">  987 </div><div id="988" class="line none">  988 /* Helper function for CBMC proofs: checks if HMAC_CTX is valid. */</div><div id="989" class="line none">  989 bool <a href="evp_override.c.html#989">hmac_ctx_is_valid</a>(<a href="../../include/openssl/ossl_typ.h.html#36">HMAC_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="990" class="line none">  990     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a> &amp;&amp; <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a>;</div><div id="991" class="line none">  991 }</div><div id="992" class="line none">  992 </div><div id="993" class="line none">  993 /* Helper function for CBMC proofs: checks if EVP_PKEY is valid. */</div><div id="994" class="line none">  994 bool <a href="evp_override.c.html#994">evp_pkey_is_valid</a>(<a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>) {</div><div id="995" class="line none">  995     return <a href="../../../../source/cipher_openssl.c.html#77">pkey</a> &amp;&amp; (<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;<a href="ec_override.c.html#82">references</a> &gt; 0) &amp;&amp; (<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;ec_key == NULL || <a href="ec_override.c.html#396">ec_key_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;ec_key));</div><div id="996" class="line none">  996 }</div><div id="997" class="line none">  997 </div><div id="998" class="line none">  998 /* Helper function for CBMC proofs: allocates EVP_PKEY nondeterministically. */</div><div id="999" class="line none">  999 <a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="evp_override.c.html#999">evp_pkey_nondet_alloc</a>() {</div><div id="1000" class="line none"> 1000     <a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a> = <a href="../../aws-c-common/verification/cbmc/sources/proof_allocators.c.html#76">can_fail_malloc</a>(sizeof(<a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a>));</div><div id="1001" class="line none"> 1001     return <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>;</div><div id="1002" class="line none"> 1002 }</div><div id="1003" class="line none"> 1003 </div><div id="1004" class="line none"> 1004 /* Helper function for CBMC proofs: returns the reference count. */</div><div id="1005" class="line none"> 1005 int <a href="evp_override.c.html#1005">evp_pkey_get_reference_count</a>(<a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>) {</div><div id="1006" class="line none"> 1006     return <a href="../../../../source/cipher_openssl.c.html#77">pkey</a> ? <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;<a href="ec_override.c.html#82">references</a> : 0;</div><div id="1007" class="line none"> 1007 }</div><div id="1008" class="line none"> 1008 </div><div id="1009" class="line none"> 1009 /* Helper function for CBMC proofs: set EC_KEY without incrementing the reference count. */</div><div id="1010" class="line none"> 1010 void <a href="evp_override.c.html#1010">evp_pkey_set0_ec_key</a>(<a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>, <a href="../../include/openssl/ossl_typ.h.html#33">EC_KEY</a> *ec) {</div><div id="1011" class="line none"> 1011     if (<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>) <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>-&gt;ec_key = ec;</div><div id="1012" class="line none"> 1012 }</div><div id="1013" class="line none"> 1013 </div><div id="1014" class="line none"> 1014 /* Helper function for CBMC proofs: frees the memory regardless of the reference count. */</div><div id="1015" class="line none"> 1015 void <a href="evp_override.c.html#1015">evp_pkey_unconditional_free</a>(<a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>) {</div><div id="1016" class="line none"> 1016     free(<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>);</div><div id="1017" class="line none"> 1017     // Does not free EC_KEY, since this is always done separately in our use cases</div><div id="1018" class="line none"> 1018 }</div><div id="1019" class="line none"> 1019 </div><div id="1020" class="line none"> 1020 bool <a href="evp_override.c.html#1020">evp_pkey_ctx_is_valid</a>(<a href="../../include/openssl/ossl_typ.h.html#35">EVP_PKEY_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="1021" class="line none"> 1021     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a> &amp;&amp; (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a> == NULL || <a href="evp_override.c.html#994">evp_pkey_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>));</div><div id="1022" class="line none"> 1022 }</div><div id="1023" class="line none"> 1023 </div><div id="1024" class="line none"> 1024 bool <a href="evp_override.c.html#1024">evp_cipher_is_valid</a>(<a href="../../include/openssl/ossl_typ.h.html#38">EVP_CIPHER</a> *<a href="evp_override.c.html#437">cipher</a>) {</div><div id="1025" class="line none"> 1025     return <a href="evp_override.c.html#437">cipher</a> &amp;&amp;</div><div id="1026" class="line none"> 1026            (<a href="evp_override.c.html#437">cipher</a>-&gt;<a href="evp_override.c.html#412">from</a> == <a href="evp_override.c.html#408">EVP_AES_128_GCM</a> || <a href="evp_override.c.html#437">cipher</a>-&gt;<a href="evp_override.c.html#412">from</a> == <a href="evp_override.c.html#408">EVP_AES_192_GCM</a> || <a href="evp_override.c.html#437">cipher</a>-&gt;<a href="evp_override.c.html#412">from</a> == <a href="evp_override.c.html#408">EVP_AES_256_GCM</a>);</div><div id="1027" class="line none"> 1027 }</div><div id="1028" class="line none"> 1028 </div><div id="1029" class="line none"> 1029 bool <a href="evp_override.c.html#1029">evp_md_is_valid</a>(<a href="../../include/openssl/ossl_typ.h.html#40">EVP_MD</a> *md) {</div><div id="1030" class="line none"> 1030     return md &amp;&amp; ((md-&gt;<a href="evp_override.c.html#412">from</a> == <a href="evp_override.c.html#687">EVP_SHA256</a> &amp;&amp; md-&gt;<a href="../../aws-c-common/include/aws/common/private/hash_table_impl.h.html#35">size</a> == 32) || (md-&gt;<a href="evp_override.c.html#412">from</a> == <a href="evp_override.c.html#687">EVP_SHA384</a> &amp;&amp; md-&gt;<a href="../../aws-c-common/include/aws/common/private/hash_table_impl.h.html#35">size</a> == 48) ||</div><div id="1031" class="line none"> 1031                   (md-&gt;<a href="evp_override.c.html#412">from</a> == <a href="evp_override.c.html#687">EVP_SHA512</a> &amp;&amp; md-&gt;<a href="../../aws-c-common/include/aws/common/private/hash_table_impl.h.html#35">size</a> == 64));</div><div id="1032" class="line none"> 1032 }</div><div id="1033" class="line none"> 1033 </div><div id="1034" class="line none"> 1034 /* Helper function for CBMC proofs: checks if EVP_MD_CTX is valid. */</div><div id="1035" class="line none"> 1035 bool <a href="evp_override.c.html#1035">evp_md_ctx_is_valid</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="1036" class="line none"> 1036     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a> &amp;&amp; <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a> &amp;&amp; <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;digest_size &lt;= EVP_MAX_MD_SIZE &amp;&amp;</div><div id="1037" class="line none"> 1037            (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a> == NULL || <a href="evp_override.c.html#994">evp_pkey_is_valid</a>(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>));</div><div id="1038" class="line none"> 1038 }</div><div id="1039" class="line none"> 1039 </div><div id="1040" class="line none"> 1040 /* Helper function for CBMC proofs: allocates EVP_MD_CTX nondeterministically. */</div><div id="1041" class="line none"> 1041 <a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="evp_override.c.html#1041">evp_md_ctx_nondet_alloc</a>() {</div><div id="1042" class="line none"> 1042     return <a href="../../aws-c-common/verification/cbmc/sources/proof_allocators.c.html#76">can_fail_malloc</a>(sizeof(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a>));</div><div id="1043" class="line none"> 1043 }</div><div id="1044" class="line none"> 1044 </div><div id="1045" class="line none"> 1045 /* Helper function for CBMC proofs: checks if EVP_MD_CTX is initialized. */</div><div id="1046" class="line none"> 1046 bool <a href="evp_override.c.html#1046">evp_md_ctx_is_initialized</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="1047" class="line none"> 1047     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="bn_override.c.html#26">is_initialized</a>;</div><div id="1048" class="line none"> 1048 }</div><div id="1049" class="line none"> 1049 </div><div id="1050" class="line none"> 1050 /* Helper function for CBMC proofs: returns digest size. */</div><div id="1051" class="line none"> 1051 size_t <a href="evp_override.c.html#1051">evp_md_ctx_get_digest_size</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="1052" class="line none"> 1052     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;digest_size;</div><div id="1053" class="line none"> 1053 }</div><div id="1054" class="line none"> 1054 </div><div id="1055" class="line none"> 1055 /* Helper function for CBMC proofs: get EVP_PKEY without incrementing the reference count. */</div><div id="1056" class="line none"> 1056 <a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="evp_override.c.html#1056">evp_md_ctx_get0_evp_pkey</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="1057" class="line none"> 1057     return <a href="../../../../source/cipher_openssl.c.html#78">ctx</a> ? <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a> : NULL;</div><div id="1058" class="line none"> 1058 }</div><div id="1059" class="line none"> 1059 </div><div id="1060" class="line none"> 1060 /* Helper function for CBMC proofs: set EVP_PKEY without incrementing the reference count. */</div><div id="1061" class="line none"> 1061 void <a href="evp_override.c.html#1061">evp_md_ctx_set0_evp_pkey</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>, <a href="../../include/openssl/ossl_typ.h.html#42">EVP_PKEY</a> *<a href="../../../../source/cipher_openssl.c.html#77">pkey</a>) {</div><div id="1062" class="line none"> 1062     if (<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) <a href="../../../../source/cipher_openssl.c.html#78">ctx</a>-&gt;<a href="../../../../source/cipher_openssl.c.html#77">pkey</a> = <a href="../../../../source/cipher_openssl.c.html#77">pkey</a>;</div><div id="1063" class="line none"> 1063 }</div><div id="1064" class="line none"> 1064 </div><div id="1065" class="line none"> 1065 /* Helper function for CBMC proofs: frees the memory of the ctx without freeing the EVP_PKEY. */</div><div id="1066" class="line none"> 1066 void <a href="evp_override.c.html#1066">evp_md_ctx_shallow_free</a>(<a href="../../include/openssl/ossl_typ.h.html#41">EVP_MD_CTX</a> *<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>) {</div><div id="1067" class="line none"> 1067     free(<a href="../../../../source/cipher_openssl.c.html#78">ctx</a>);</div><div id="1068" class="line none"> 1068     // Does not free EVP_KEY, since this is always done separately in our use cases</div><div id="1069" class="line none"> 1069 }</div>
</div>
</body>
</html>
