
<html>
<head>
<title>verification/cbmc/aws-c-common/include/aws/common/hash_table.h</title>
<link rel="stylesheet" type="text/css" href="../../../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 #ifndef <a href="hash_table.h.html#2">AWS_COMMON_HASH_TABLE_H</a></div><div id="2" class="line none">    2 #define <a href="hash_table.h.html#2">AWS_COMMON_HASH_TABLE_H</a></div><div id="3" class="line none">    3 </div><div id="4" class="line none">    4 /**</div><div id="5" class="line none">    5  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.</div><div id="6" class="line none">    6  * SPDX-License-Identifier: Apache-2.0.</div><div id="7" class="line none">    7  */</div><div id="8" class="line none">    8 </div><div id="9" class="line none">    9 #include &lt;aws/common/common.h&gt;</div><div id="10" class="line none">   10 </div><div id="11" class="line none">   11 #include &lt;stddef.h&gt;</div><div id="12" class="line none">   12 </div><div id="13" class="line none">   13 #define <a href="hash_table.h.html#13">AWS_COMMON_HASH_TABLE_ITER_CONTINUE</a> (1 &lt;&lt; 0)</div><div id="14" class="line none">   14 #define <a href="hash_table.h.html#14">AWS_COMMON_HASH_TABLE_ITER_DELETE</a> (1 &lt;&lt; 1)</div><div id="15" class="line none">   15 </div><div id="16" class="line none">   16 /**</div><div id="17" class="line none">   17  * Hash table data structure. This module provides an automatically resizing</div><div id="18" class="line none">   18  * hash table implementation for general purpose use. The hash table stores a</div><div id="19" class="line none">   19  * mapping between void * keys and values; it is expected that in most cases,</div><div id="20" class="line none">   20  * these will point to a structure elsewhere in the heap, instead of inlining a</div><div id="21" class="line none">   21  * key or value into the hash table element itself.</div><div id="22" class="line none">   22  *</div><div id="23" class="line none">   23  * Currently, this hash table implements a variant of robin hood hashing, but</div><div id="24" class="line none">   24  * we do not guarantee that this won't change in the future.</div><div id="25" class="line none">   25  *</div><div id="26" class="line none">   26  * Associated with each hash function are four callbacks:</div><div id="27" class="line none">   27  *</div><div id="28" class="line none">   28  *   hash_fn - A hash function from the keys to a uint64_t. It is critical that</div><div id="29" class="line none">   29  *      the hash function for a key does not change while the key is in the hash</div><div id="30" class="line none">   30  *      table; violating this results in undefined behavior. Collisions are</div><div id="31" class="line none">   31  *      tolerated, though naturally with reduced performance.</div><div id="32" class="line none">   32  *</div><div id="33" class="line none">   33  *   equals_fn - An equality comparison function. This function must be</div><div id="34" class="line none">   34  *      reflexive and consistent with hash_fn.</div><div id="35" class="line none">   35  *</div><div id="36" class="line none">   36  *   destroy_key_fn, destroy_value_fn - Optional callbacks invoked when the</div><div id="37" class="line none">   37  *      table is cleared or cleaned up and at the caller's option when an element</div><div id="38" class="line none">   38  *      is removed from the table. Either or both may be set to NULL, which</div><div id="39" class="line none">   39  *      has the same effect as a no-op destroy function.</div><div id="40" class="line none">   40  *</div><div id="41" class="line none">   41  * This datastructure can be safely moved between threads, subject to the</div><div id="42" class="line none">   42  * requirements of the underlying allocator. It is also safe to invoke</div><div id="43" class="line none">   43  * non-mutating operations on the hash table from multiple threads. A suitable</div><div id="44" class="line none">   44  * memory barrier must be used when transitioning from single-threaded mutating</div><div id="45" class="line none">   45  * usage to multithreaded usage.</div><div id="46" class="line none">   46  */</div><div id="47" class="line none">   47 struct <a href="hash_table.h.html#47">hash_table_state</a>; /* Opaque pointer */</div><div id="48" class="line none">   48 struct <a href="hash_table.h.html#48">aws_hash_table</a> {</div><div id="49" class="line none">   49     struct <a href="hash_table.h.html#47">hash_table_state</a> *<a href="hash_table.h.html#49">p_impl</a>;</div><div id="50" class="line none">   50 };</div><div id="51" class="line none">   51 </div><div id="52" class="line none">   52 /**</div><div id="53" class="line none">   53  * Represents an element in the hash table. Various operations on the hash</div><div id="54" class="line none">   54  * table may provide pointers to elements stored within the hash table;</div><div id="55" class="line none">   55  * generally, calling code may alter value, but must not alter key (or any</div><div id="56" class="line none">   56  * information used to compute key's hash code).</div><div id="57" class="line none">   57  *</div><div id="58" class="line none">   58  * Pointers to elements within the hash are invalidated whenever an operation</div><div id="59" class="line none">   59  * which may change the number of elements in the hash is invoked (i.e. put,</div><div id="60" class="line none">   60  * delete, clear, and clean_up), regardless of whether the number of elements</div><div id="61" class="line none">   61  * actually changes.</div><div id="62" class="line none">   62  */</div><div id="63" class="line none">   63 struct <a href="hash_table.h.html#63">aws_hash_element</a> {</div><div id="64" class="line none">   64     const void *<a href="hash_table.h.html#64">key</a>;</div><div id="65" class="line none">   65     void *<a href="atomics.h.html#17">value</a>;</div><div id="66" class="line none">   66 };</div><div id="67" class="line none">   67 </div><div id="68" class="line none">   68 enum <a href="hash_table.h.html#68">aws_hash_iter_status</a> {</div><div id="69" class="line none">   69     <a href="hash_table.h.html#69">AWS_HASH_ITER_STATUS_DONE</a>,</div><div id="70" class="line none">   70     <a href="hash_table.h.html#70">AWS_HASH_ITER_STATUS_DELETE_CALLED</a>,</div><div id="71" class="line none">   71     <a href="hash_table.h.html#71">AWS_HASH_ITER_STATUS_READY_FOR_USE</a>,</div><div id="72" class="line none">   72 };</div><div id="73" class="line none">   73 </div><div id="74" class="line none">   74 struct <a href="hash_table.h.html#74">aws_hash_iter</a> {</div><div id="75" class="line none">   75     const struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>;</div><div id="76" class="line none">   76     struct <a href="hash_table.h.html#63">aws_hash_element</a> <a href="private/hash_table_impl.h.html#14">element</a>;</div><div id="77" class="line none">   77     size_t <a href="hash_table.h.html#77">slot</a>;</div><div id="78" class="line none">   78     size_t <a href="hash_table.h.html#78">limit</a>;</div><div id="79" class="line none">   79     enum <a href="hash_table.h.html#68">aws_hash_iter_status</a> <a href="hash_table.h.html#79">status</a>;</div><div id="80" class="line none">   80     /*</div><div id="81" class="line none">   81      * Reserving extra fields for binary compatibility with future expansion of</div><div id="82" class="line none">   82      * iterator in case hash table implementation changes.</div><div id="83" class="line none">   83      */</div><div id="84" class="line none">   84     int <a href="hash_table.h.html#84">unused_0</a>;</div><div id="85" class="line none">   85     void *<a href="hash_table.h.html#85">unused_1</a>;</div><div id="86" class="line none">   86     void *<a href="hash_table.h.html#86">unused_2</a>;</div><div id="87" class="line none">   87 };</div><div id="88" class="line none">   88 </div><div id="89" class="line none">   89 /**</div><div id="90" class="line none">   90  * Prototype for a key hashing function pointer.</div><div id="91" class="line none">   91  */</div><div id="92" class="line none">   92 typedef uint64_t(<a href="hash_table.h.html#92">aws_hash_fn</a>)(const void *<a href="hash_table.h.html#64">key</a>);</div><div id="93" class="line none">   93 </div><div id="94" class="line none">   94 /**</div><div id="95" class="line none">   95  * Prototype for a hash table equality check function pointer.</div><div id="96" class="line none">   96  *</div><div id="97" class="line none">   97  * This type is usually used for a function that compares two hash table</div><div id="98" class="line none">   98  * keys, but note that the same type is used for a function that compares</div><div id="99" class="line none">   99  * two hash table values in aws_hash_table_eq.</div><div id="100" class="line none">  100  *</div><div id="101" class="line none">  101  * Equality functions used in a hash table must be reflexive (i.e., a == b if</div><div id="102" class="line none">  102  * and only if b == a), and must be consistent with the hash function in use.</div><div id="103" class="line none">  103  */</div><div id="104" class="line none">  104 typedef bool(<a href="hash_table.h.html#104">aws_hash_callback_eq_fn</a>)(const void *a, const void *b);</div><div id="105" class="line none">  105 </div><div id="106" class="line none">  106 /**</div><div id="107" class="line none">  107  * Prototype for a hash table key or value destructor function pointer.</div><div id="108" class="line none">  108  *</div><div id="109" class="line none">  109  * This function is used to destroy elements in the hash table when the</div><div id="110" class="line none">  110  * table is cleared or cleaned up.</div><div id="111" class="line none">  111  *</div><div id="112" class="line none">  112  * Note that functions which remove individual elements from the hash</div><div id="113" class="line none">  113  * table provide options of whether or not to invoke the destructors</div><div id="114" class="line none">  114  * on the key and value of a removed element.</div><div id="115" class="line none">  115  */</div><div id="116" class="line none">  116 typedef void(<a href="hash_table.h.html#116">aws_hash_callback_destroy_fn</a>)(void *key_or_value);</div><div id="117" class="line none">  117 </div><div id="118" class="line none">  118 AWS_EXTERN_C_BEGIN</div><div id="119" class="line none">  119 </div><div id="120" class="line none">  120 /**</div><div id="121" class="line none">  121  * Initializes a hash map with initial capacity for 'size' elements</div><div id="122" class="line none">  122  * without resizing. Uses hash_fn to compute the hash of each element.</div><div id="123" class="line none">  123  * equals_fn to compute equality of two keys.  Whenever an element is</div><div id="124" class="line none">  124  * removed without being returned, destroy_key_fn is run on the pointer</div><div id="125" class="line none">  125  * to the key and destroy_value_fn is run on the pointer to the value.</div><div id="126" class="line none">  126  * Either or both may be NULL if a callback is not desired in this case.</div><div id="127" class="line none">  127  */</div><div id="128" class="line none">  128 AWS_COMMON_API</div><div id="129" class="line none">  129 int aws_hash_table_init(</div><div id="130" class="line none">  130     struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>,</div><div id="131" class="line none">  131     struct <a href="allocator.h.html#15">aws_allocator</a> *<a href="array_list.h.html#16">alloc</a>,</div><div id="132" class="line none">  132     size_t <a href="private/hash_table_impl.h.html#35">size</a>,</div><div id="133" class="line none">  133     <a href="hash_table.h.html#92">aws_hash_fn</a> *<a href="private/hash_table_impl.h.html#29">hash_fn</a>,</div><div id="134" class="line none">  134     <a href="hash_table.h.html#104">aws_hash_callback_eq_fn</a> *<a href="private/hash_table_impl.h.html#30">equals_fn</a>,</div><div id="135" class="line none">  135     <a href="hash_table.h.html#116">aws_hash_callback_destroy_fn</a> *<a href="private/hash_table_impl.h.html#31">destroy_key_fn</a>,</div><div id="136" class="line none">  136     <a href="hash_table.h.html#116">aws_hash_callback_destroy_fn</a> *<a href="private/hash_table_impl.h.html#32">destroy_value_fn</a>);</div><div id="137" class="line none">  137 </div><div id="138" class="line none">  138 /**</div><div id="139" class="line none">  139  * Deletes every element from map and frees all associated memory.</div><div id="140" class="line none">  140  * destroy_fn will be called for each element.  aws_hash_table_init</div><div id="141" class="line none">  141  * must be called before reusing the hash table.</div><div id="142" class="line none">  142  *</div><div id="143" class="line none">  143  * This method is idempotent.</div><div id="144" class="line none">  144  */</div><div id="145" class="line none">  145 AWS_COMMON_API</div><div id="146" class="line none">  146 void aws_hash_table_clean_up(struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>);</div><div id="147" class="line none">  147 </div><div id="148" class="line none">  148 /**</div><div id="149" class="line none">  149  * Safely swaps two hash tables. Note that we swap the entirety of the hash</div><div id="150" class="line none">  150  * table, including which allocator is associated.</div><div id="151" class="line none">  151  *</div><div id="152" class="line none">  152  * Neither hash table is required to be initialized; if one or both is</div><div id="153" class="line none">  153  * uninitialized, then the uninitialized state is also swapped.</div><div id="154" class="line none">  154  */</div><div id="155" class="line none">  155 AWS_COMMON_API</div><div id="156" class="line none">  156 void aws_hash_table_swap(struct <a href="hash_table.h.html#48">aws_hash_table</a> *AWS_RESTRICT a, struct <a href="hash_table.h.html#48">aws_hash_table</a> *AWS_RESTRICT b);</div><div id="157" class="line none">  157 </div><div id="158" class="line none">  158 /**</div><div id="159" class="line none">  159  * Moves the hash table in 'from' to 'to'. After this move, 'from' will</div><div id="160" class="line none">  160  * be identical to the state of the original 'to' hash table, and 'to'</div><div id="161" class="line none">  161  * will be in the same state as if it had been passed to aws_hash_table_clean_up</div><div id="162" class="line none">  162  * (that is, it will have no memory allocated, and it will be safe to</div><div id="163" class="line none">  163  * either discard it or call aws_hash_table_clean_up again).</div><div id="164" class="line none">  164  *</div><div id="165" class="line none">  165  * Note that 'to' will not be cleaned up. You should make sure that 'to'</div><div id="166" class="line none">  166  * is either uninitialized or cleaned up before moving a hashtable into</div><div id="167" class="line none">  167  * it.</div><div id="168" class="line none">  168  */</div><div id="169" class="line none">  169 AWS_COMMON_API</div><div id="170" class="line none">  170 void aws_hash_table_move(struct <a href="hash_table.h.html#48">aws_hash_table</a> *AWS_RESTRICT to, struct <a href="hash_table.h.html#48">aws_hash_table</a> *AWS_RESTRICT <a href="../../../../sources/openssl/evp_override.c.html#412">from</a>);</div><div id="171" class="line none">  171 </div><div id="172" class="line none">  172 /**</div><div id="173" class="line none">  173  * Returns the current number of entries in the table.</div><div id="174" class="line none">  174  */</div><div id="175" class="line none">  175 AWS_COMMON_API</div><div id="176" class="line none">  176 size_t aws_hash_table_get_entry_count(const struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>);</div><div id="177" class="line none">  177 </div><div id="178" class="line none">  178 /**</div><div id="179" class="line none">  179  * Returns an iterator to be used for iterating through a hash table.</div><div id="180" class="line none">  180  * Iterator will already point to the first element of the table it finds,</div><div id="181" class="line none">  181  * which can be accessed as iter.element.</div><div id="182" class="line none">  182  *</div><div id="183" class="line none">  183  * This function cannot fail, but if there are no elements in the table,</div><div id="184" class="line none">  184  * the returned iterator will return true for aws_hash_iter_done(&amp;iter).</div><div id="185" class="line none">  185  */</div><div id="186" class="line none">  186 AWS_COMMON_API</div><div id="187" class="line none">  187 struct <a href="hash_table.h.html#74">aws_hash_iter</a> aws_hash_iter_begin(const struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>);</div><div id="188" class="line none">  188 </div><div id="189" class="line none">  189 /**</div><div id="190" class="line none">  190  * Returns true if iterator is done iterating through table, false otherwise.</div><div id="191" class="line none">  191  * If this is true, the iterator will not include an element of the table.</div><div id="192" class="line none">  192  */</div><div id="193" class="line none">  193 AWS_COMMON_API</div><div id="194" class="line none">  194 bool aws_hash_iter_done(const struct <a href="hash_table.h.html#74">aws_hash_iter</a> *iter);</div><div id="195" class="line none">  195 </div><div id="196" class="line none">  196 /**</div><div id="197" class="line none">  197  * Updates iterator so that it points to next element of hash table.</div><div id="198" class="line none">  198  *</div><div id="199" class="line none">  199  * This and the two previous functions are designed to be used together with</div><div id="200" class="line none">  200  * the following idiom:</div><div id="201" class="line none">  201  *</div><div id="202" class="line none">  202  * for (struct aws_hash_iter iter = aws_hash_iter_begin(&amp;map);</div><div id="203" class="line none">  203  *      !aws_hash_iter_done(&amp;iter); aws_hash_iter_next(&amp;iter)) {</div><div id="204" class="line none">  204  *     const key_type key = *(const key_type *)iter.element.key;</div><div id="205" class="line none">  205  *     value_type value = *(value_type *)iter.element.value;</div><div id="206" class="line none">  206  *     // etc.</div><div id="207" class="line none">  207  * }</div><div id="208" class="line none">  208  *</div><div id="209" class="line none">  209  * Note that calling this on an iter which is "done" is idempotent:</div><div id="210" class="line none">  210  * i.e. it will return another iter which is "done".</div><div id="211" class="line none">  211  */</div><div id="212" class="line none">  212 AWS_COMMON_API</div><div id="213" class="line none">  213 void aws_hash_iter_next(struct <a href="hash_table.h.html#74">aws_hash_iter</a> *iter);</div><div id="214" class="line none">  214 </div><div id="215" class="line none">  215 /**</div><div id="216" class="line none">  216  * Deletes the element currently pointed-to by the hash iterator.</div><div id="217" class="line none">  217  * After calling this method, the element member of the iterator</div><div id="218" class="line none">  218  * should not be accessed until the next call to aws_hash_iter_next.</div><div id="219" class="line none">  219  *</div><div id="220" class="line none">  220  * @param destroy_contents If true, the destructors for the key and value</div><div id="221" class="line none">  221  *  will be called.</div><div id="222" class="line none">  222  */</div><div id="223" class="line none">  223 AWS_COMMON_API</div><div id="224" class="line none">  224 void aws_hash_iter_delete(struct <a href="hash_table.h.html#74">aws_hash_iter</a> *iter, bool destroy_contents);</div><div id="225" class="line none">  225 </div><div id="226" class="line none">  226 /**</div><div id="227" class="line none">  227  * Attempts to locate an element at key.  If the element is found, a</div><div id="228" class="line none">  228  * pointer to the value is placed in *p_elem; if it is not found,</div><div id="229" class="line none">  229  * *pElem is set to NULL. Either way, AWS_OP_SUCCESS is returned.</div><div id="230" class="line none">  230  *</div><div id="231" class="line none">  231  * This method does not change the state of the hash table. Therefore, it</div><div id="232" class="line none">  232  * is safe to call _find from multiple threads on the same hash table,</div><div id="233" class="line none">  233  * provided no mutating operations happen in parallel.</div><div id="234" class="line none">  234  *</div><div id="235" class="line none">  235  * Calling code may update the value in the hash table by modifying **pElem</div><div id="236" class="line none">  236  * after a successful find. However, this pointer is not guaranteed to</div><div id="237" class="line none">  237  * remain usable after a subsequent call to _put, _delete, _clear, or</div><div id="238" class="line none">  238  * _clean_up.</div><div id="239" class="line none">  239  */</div><div id="240" class="line none">  240 </div><div id="241" class="line none">  241 AWS_COMMON_API</div><div id="242" class="line none">  242 int aws_hash_table_find(const struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>, const void *<a href="hash_table.h.html#64">key</a>, struct <a href="hash_table.h.html#63">aws_hash_element</a> **p_elem);</div><div id="243" class="line none">  243 </div><div id="244" class="line none">  244 /**</div><div id="245" class="line none">  245  * Attempts to locate an element at key. If no such element was found,</div><div id="246" class="line none">  246  * creates a new element, with value initialized to NULL. In either case, a</div><div id="247" class="line none">  247  * pointer to the element is placed in *p_elem.</div><div id="248" class="line none">  248  *</div><div id="249" class="line none">  249  * If was_created is non-NULL, *was_created is set to 0 if an existing</div><div id="250" class="line none">  250  * element was found, or 1 is a new element was created.</div><div id="251" class="line none">  251  *</div><div id="252" class="line none">  252  * Returns AWS_OP_SUCCESS if an item was found or created.</div><div id="253" class="line none">  253  * Raises AWS_ERROR_OOM if hash table expansion was required and memory</div><div id="254" class="line none">  254  * allocation failed.</div><div id="255" class="line none">  255  */</div><div id="256" class="line none">  256 AWS_COMMON_API</div><div id="257" class="line none">  257 int aws_hash_table_create(</div><div id="258" class="line none">  258     struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>,</div><div id="259" class="line none">  259     const void *<a href="hash_table.h.html#64">key</a>,</div><div id="260" class="line none">  260     struct <a href="hash_table.h.html#63">aws_hash_element</a> **p_elem,</div><div id="261" class="line none">  261     int *was_created);</div><div id="262" class="line none">  262 </div><div id="263" class="line none">  263 /**</div><div id="264" class="line none">  264  * Inserts a new element at key, with the given value. If another element</div><div id="265" class="line none">  265  * exists at that key, the old element will be overwritten; both old key and</div><div id="266" class="line none">  266  * value objects will be destroyed.</div><div id="267" class="line none">  267  *</div><div id="268" class="line none">  268  * If was_created is non-NULL, *was_created is set to 0 if an existing</div><div id="269" class="line none">  269  * element was found, or 1 is a new element was created.</div><div id="270" class="line none">  270  *</div><div id="271" class="line none">  271  * Returns AWS_OP_SUCCESS if an item was found or created.</div><div id="272" class="line none">  272  * Raises AWS_ERROR_OOM if hash table expansion was required and memory</div><div id="273" class="line none">  273  */</div><div id="274" class="line none">  274 AWS_COMMON_API</div><div id="275" class="line none">  275 int aws_hash_table_put(struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>, const void *<a href="hash_table.h.html#64">key</a>, void *<a href="atomics.h.html#17">value</a>, int *was_created);</div><div id="276" class="line none">  276 </div><div id="277" class="line none">  277 /**</div><div id="278" class="line none">  278  * Removes element at key. Always returns AWS_OP_SUCCESS.</div><div id="279" class="line none">  279  *</div><div id="280" class="line none">  280  * If pValue is non-NULL, the existing value (if any) is moved into</div><div id="281" class="line none">  281  * (*value) before removing from the table, and destroy_fn is _not_</div><div id="282" class="line none">  282  * invoked. If pValue is NULL, then (if the element existed) destroy_fn</div><div id="283" class="line none">  283  * will be invoked on the element being removed.</div><div id="284" class="line none">  284  *</div><div id="285" class="line none">  285  * If was_present is non-NULL, it is set to 0 if the element was</div><div id="286" class="line none">  286  * not present, or 1 if it was present (and is now removed).</div><div id="287" class="line none">  287  */</div><div id="288" class="line none">  288 AWS_COMMON_API</div><div id="289" class="line none">  289 int aws_hash_table_remove(</div><div id="290" class="line none">  290     struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>,</div><div id="291" class="line none">  291     const void *<a href="hash_table.h.html#64">key</a>,</div><div id="292" class="line none">  292     struct <a href="hash_table.h.html#63">aws_hash_element</a> *p_value,</div><div id="293" class="line none">  293     int *was_present);</div><div id="294" class="line none">  294 </div><div id="295" class="line none">  295 /**</div><div id="296" class="line none">  296  * Removes element already known (typically by find()).</div><div id="297" class="line none">  297  *</div><div id="298" class="line none">  298  * p_value should point to a valid element returned by create() or find().</div><div id="299" class="line none">  299  *</div><div id="300" class="line none">  300  * NOTE: DO NOT call this method from inside of a aws_hash_table_foreach callback, return</div><div id="301" class="line none">  301  * AWS_COMMON_HASH_TABLE_ITER_DELETE instead.</div><div id="302" class="line none">  302  */</div><div id="303" class="line none">  303 AWS_COMMON_API</div><div id="304" class="line none">  304 int aws_hash_table_remove_element(struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>, struct <a href="hash_table.h.html#63">aws_hash_element</a> *p_value);</div><div id="305" class="line none">  305 </div><div id="306" class="line none">  306 /**</div><div id="307" class="line none">  307  * Iterates through every element in the map and invokes the callback on</div><div id="308" class="line none">  308  * that item. Iteration is performed in an arbitrary, implementation-defined</div><div id="309" class="line none">  309  * order, and is not guaranteed to be consistent across invocations.</div><div id="310" class="line none">  310  *</div><div id="311" class="line none">  311  * The callback may change the value associated with the key by overwriting</div><div id="312" class="line none">  312  * the value pointed-to by value. In this case, the on_element_removed</div><div id="313" class="line none">  313  * callback will not be invoked, unless the callback invokes</div><div id="314" class="line none">  314  * AWS_COMMON_HASH_TABLE_ITER_DELETE (in which case the on_element_removed</div><div id="315" class="line none">  315  * is given the updated value).</div><div id="316" class="line none">  316  *</div><div id="317" class="line none">  317  * The callback must return a bitmask of zero or more of the following values</div><div id="318" class="line none">  318  * ORed together:</div><div id="319" class="line none">  319  *</div><div id="320" class="line none">  320  * # AWS_COMMON_HASH_TABLE_ITER_CONTINUE - Continues iteration to the next</div><div id="321" class="line none">  321  *     element (if not set, iteration stops)</div><div id="322" class="line none">  322  * # AWS_COMMON_HASH_TABLE_ITER_DELETE   - Deletes the current value and</div><div id="323" class="line none">  323  *     continues iteration.  destroy_fn will NOT be invoked.</div><div id="324" class="line none">  324  *</div><div id="325" class="line none">  325  * Invoking any method which may change the contents of the hashtable</div><div id="326" class="line none">  326  * during iteration results in undefined behavior. However, you may safely</div><div id="327" class="line none">  327  * invoke non-mutating operations during an iteration.</div><div id="328" class="line none">  328  *</div><div id="329" class="line none">  329  * This operation is mutating only if AWS_COMMON_HASH_TABLE_ITER_DELETE</div><div id="330" class="line none">  330  * is returned at some point during iteration. Otherwise, it is non-mutating</div><div id="331" class="line none">  331  * and is safe to invoke in parallel with other non-mutating operations.</div><div id="332" class="line none">  332  */</div><div id="333" class="line none">  333 </div><div id="334" class="line none">  334 AWS_COMMON_API</div><div id="335" class="line none">  335 int aws_hash_table_foreach(</div><div id="336" class="line none">  336     struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>,</div><div id="337" class="line none">  337     int (*callback)(void *context, struct <a href="hash_table.h.html#63">aws_hash_element</a> *p_element),</div><div id="338" class="line none">  338     void *context);</div><div id="339" class="line none">  339 </div><div id="340" class="line none">  340 /**</div><div id="341" class="line none">  341  * Compares two hash tables for equality. Both hash tables must have equivalent</div><div id="342" class="line none">  342  * key comparators; values will be compared using the comparator passed into this</div><div id="343" class="line none">  343  * function. The key hash function does not need to be equivalent between the</div><div id="344" class="line none">  344  * two hash tables.</div><div id="345" class="line none">  345  */</div><div id="346" class="line none">  346 AWS_COMMON_API</div><div id="347" class="line none">  347 bool aws_hash_table_eq(</div><div id="348" class="line none">  348     const struct <a href="hash_table.h.html#48">aws_hash_table</a> *a,</div><div id="349" class="line none">  349     const struct <a href="hash_table.h.html#48">aws_hash_table</a> *b,</div><div id="350" class="line none">  350     <a href="hash_table.h.html#104">aws_hash_callback_eq_fn</a> *value_eq);</div><div id="351" class="line none">  351 </div><div id="352" class="line none">  352 /**</div><div id="353" class="line none">  353  * Removes every element from the hash map. destroy_fn will be called for</div><div id="354" class="line none">  354  * each element.</div><div id="355" class="line none">  355  */</div><div id="356" class="line none">  356 AWS_COMMON_API</div><div id="357" class="line none">  357 void aws_hash_table_clear(struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>);</div><div id="358" class="line none">  358 </div><div id="359" class="line none">  359 /**</div><div id="360" class="line none">  360  * Convenience hash function for NULL-terminated C-strings</div><div id="361" class="line none">  361  */</div><div id="362" class="line none">  362 AWS_COMMON_API</div><div id="363" class="line none">  363 uint64_t aws_hash_c_string(const void *item);</div><div id="364" class="line none">  364 </div><div id="365" class="line none">  365 /**</div><div id="366" class="line none">  366  * Convenience hash function for struct aws_strings.</div><div id="367" class="line none">  367  * Hash is same as used on the string bytes by aws_hash_c_string.</div><div id="368" class="line none">  368  */</div><div id="369" class="line none">  369 AWS_COMMON_API</div><div id="370" class="line none">  370 uint64_t aws_hash_string(const void *item);</div><div id="371" class="line none">  371 </div><div id="372" class="line none">  372 /**</div><div id="373" class="line none">  373  * Convenience hash function for struct aws_byte_cursor.</div><div id="374" class="line none">  374  * Hash is same as used on the string bytes by aws_hash_c_string.</div><div id="375" class="line none">  375  */</div><div id="376" class="line none">  376 AWS_COMMON_API</div><div id="377" class="line none">  377 uint64_t aws_hash_byte_cursor_ptr(const void *item);</div><div id="378" class="line none">  378 </div><div id="379" class="line none">  379 /**</div><div id="380" class="line none">  380  * Convenience hash function which hashes the pointer value directly,</div><div id="381" class="line none">  381  * without dereferencing.  This can be used in cases where pointer identity</div><div id="382" class="line none">  382  * is desired, or where a uintptr_t is encoded into a const void *.</div><div id="383" class="line none">  383  */</div><div id="384" class="line none">  384 AWS_COMMON_API</div><div id="385" class="line none">  385 uint64_t aws_hash_ptr(const void *item);</div><div id="386" class="line none">  386 </div><div id="387" class="line none">  387 AWS_COMMON_API</div><div id="388" class="line none">  388 uint64_t aws_hash_combine(uint64_t item1, uint64_t item2);</div><div id="389" class="line none">  389 </div><div id="390" class="line none">  390 /**</div><div id="391" class="line none">  391  * Convenience eq callback for NULL-terminated C-strings</div><div id="392" class="line none">  392  */</div><div id="393" class="line none">  393 AWS_COMMON_API</div><div id="394" class="line none">  394 bool aws_hash_callback_c_str_eq(const void *a, const void *b);</div><div id="395" class="line none">  395 </div><div id="396" class="line none">  396 /**</div><div id="397" class="line none">  397  * Convenience eq callback for AWS strings</div><div id="398" class="line none">  398  */</div><div id="399" class="line none">  399 AWS_COMMON_API</div><div id="400" class="line none">  400 bool aws_hash_callback_string_eq(const void *a, const void *b);</div><div id="401" class="line none">  401 </div><div id="402" class="line none">  402 /**</div><div id="403" class="line none">  403  * Convenience destroy callback for AWS strings</div><div id="404" class="line none">  404  */</div><div id="405" class="line none">  405 AWS_COMMON_API</div><div id="406" class="line none">  406 void aws_hash_callback_string_destroy(void *a);</div><div id="407" class="line none">  407 </div><div id="408" class="line none">  408 /**</div><div id="409" class="line none">  409  * Equality function which compares pointer equality.</div><div id="410" class="line none">  410  */</div><div id="411" class="line none">  411 AWS_COMMON_API</div><div id="412" class="line none">  412 bool aws_ptr_eq(const void *a, const void *b);</div><div id="413" class="line none">  413 </div><div id="414" class="line none">  414 /**</div><div id="415" class="line none">  415  * Best-effort check of hash_table_state data-structure invariants</div><div id="416" class="line none">  416  */</div><div id="417" class="line none">  417 AWS_COMMON_API</div><div id="418" class="line none">  418 bool <a href="hash_table.h.html#418">aws_hash_table_is_valid</a>(const struct <a href="hash_table.h.html#48">aws_hash_table</a> *<a href="hash_table.h.html#75">map</a>);</div><div id="419" class="line none">  419 </div><div id="420" class="line none">  420 /**</div><div id="421" class="line none">  421  * Given a pointer to a hash_iter, checks that it is well-formed, with all data-structure invariants.</div><div id="422" class="line none">  422  */</div><div id="423" class="line none">  423 AWS_COMMON_API</div><div id="424" class="line none">  424 bool aws_hash_iter_is_valid(const struct <a href="hash_table.h.html#74">aws_hash_iter</a> *iter);</div><div id="425" class="line none">  425 </div><div id="426" class="line none">  426 AWS_EXTERN_C_END</div><div id="427" class="line none">  427 </div><div id="428" class="line none">  428 #endif /* AWS_COMMON_HASH_TABLE_H */</div>
</div>
</body>
</html>
