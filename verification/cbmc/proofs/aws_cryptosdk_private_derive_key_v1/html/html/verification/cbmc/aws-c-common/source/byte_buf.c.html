
<html>
<head>
<title>verification/cbmc/aws-c-common/source/byte_buf.c</title>
<link rel="stylesheet" type="text/css" href="../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 /**</div><div id="2" class="line none">    2  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.</div><div id="3" class="line none">    3  * SPDX-License-Identifier: Apache-2.0.</div><div id="4" class="line none">    4  */</div><div id="5" class="line none">    5 </div><div id="6" class="line none">    6 #include &lt;aws/common/byte_buf.h&gt;</div><div id="7" class="line none">    7 #include &lt;aws/common/private/byte_buf.h&gt;</div><div id="8" class="line none">    8 </div><div id="9" class="line none">    9 #include &lt;stdarg.h&gt;</div><div id="10" class="line none">   10 </div><div id="11" class="line none">   11 #ifdef _MSC_VER</div><div id="12" class="line none">   12 /* disables warning non const declared initializers for Microsoft compilers */</div><div id="13" class="line none">   13 #    pragma warning(disable : 4204)</div><div id="14" class="line none">   14 #    pragma warning(disable : 4706)</div><div id="15" class="line none">   15 #endif</div><div id="16" class="line none">   16 </div><div id="17" class="line none">   17 int <a href="byte_buf.c.html#17">aws_byte_buf_init</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf, struct <a href="../include/aws/common/allocator.h.html#15">aws_allocator</a> *<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, size_t <a href="../include/aws/common/byte_buf.h.html#29">capacity</a>) {</div><div id="18" class="line none">   18     AWS_PRECONDITION(buf);</div><div id="19" class="line none">   19     AWS_PRECONDITION(<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>);</div><div id="20" class="line none">   20 </div><div id="21" class="line none">   21     buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> = (<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> == 0) ? NULL : <a href="../verification/cbmc/sources/proof_allocators.c.html#116">aws_mem_acquire</a>(<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, <a href="../include/aws/common/byte_buf.h.html#29">capacity</a>);</div><div id="22" class="line none">   22     if (<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> != 0 &amp;&amp; buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> == NULL) {</div><div id="23" class="line none">   23         AWS_ZERO_STRUCT(*buf);</div><div id="24" class="line none">   24         return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="25" class="line none">   25     }</div><div id="26" class="line none">   26 </div><div id="27" class="line none">   27     buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = 0;</div><div id="28" class="line none">   28     buf-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> = <a href="../include/aws/common/byte_buf.h.html#29">capacity</a>;</div><div id="29" class="line none">   29     buf-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a> = <a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>;</div><div id="30" class="line none">   30     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="31" class="line none">   31     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="32" class="line none">   32 }</div><div id="33" class="line none">   33 </div><div id="34" class="line none">   34 int <a href="byte_buf.c.html#34">aws_byte_buf_init_copy</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *dest, struct <a href="../include/aws/common/allocator.h.html#15">aws_allocator</a> *<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *src) {</div><div id="35" class="line none">   35     AWS_PRECONDITION(<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>);</div><div id="36" class="line none">   36     AWS_PRECONDITION(dest);</div><div id="37" class="line none">   37     AWS_ERROR_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(src));</div><div id="38" class="line none">   38 </div><div id="39" class="line none">   39     if (!src-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>) {</div><div id="40" class="line none">   40         AWS_ZERO_STRUCT(*dest);</div><div id="41" class="line none">   41         dest-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a> = <a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>;</div><div id="42" class="line none">   42         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(dest));</div><div id="43" class="line none">   43         return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="44" class="line none">   44     }</div><div id="45" class="line none">   45 </div><div id="46" class="line none">   46     *dest = *src;</div><div id="47" class="line none">   47     dest-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a> = <a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>;</div><div id="48" class="line none">   48     dest-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> = (uint8_t *)<a href="../verification/cbmc/sources/proof_allocators.c.html#116">aws_mem_acquire</a>(<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, src-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>);</div><div id="49" class="line none">   49     if (dest-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> == NULL) {</div><div id="50" class="line none">   50         AWS_ZERO_STRUCT(*dest);</div><div id="51" class="line none">   51         return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="52" class="line none">   52     }</div><div id="53" class="line none">   53     memcpy(dest-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, src-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, src-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="54" class="line none">   54     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(dest));</div><div id="55" class="line none">   55     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="56" class="line none">   56 }</div><div id="57" class="line none">   57 </div><div id="58" class="line none">   58 bool <a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const buf) {</div><div id="59" class="line hit">   59     return buf != NULL &amp;&amp;</div><div id="60" class="line hit">   60            ((buf-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> == 0 &amp;&amp; buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> == 0 &amp;&amp; buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> == NULL) ||</div><div id="61" class="line both">   61             (buf-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> &gt; 0 &amp;&amp; buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &lt;= buf-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> &amp;&amp; AWS_MEM_IS_WRITABLE(buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, buf-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>)));</div><div id="62" class="line hit">   62 }</div><div id="63" class="line none">   63 </div><div id="64" class="line none">   64 bool <a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *cursor) {</div><div id="65" class="line none">   65     return cursor != NULL &amp;&amp;</div><div id="66" class="line none">   66            ((cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> == 0) || (cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0 &amp;&amp; cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> &amp;&amp; AWS_MEM_IS_READABLE(cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>)));</div><div id="67" class="line none">   67 }</div><div id="68" class="line none">   68 </div><div id="69" class="line none">   69 void <a href="byte_buf.c.html#69">aws_byte_buf_reset</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf, bool zero_contents) {</div><div id="70" class="line none">   70     if (zero_contents) {</div><div id="71" class="line none">   71         <a href="byte_buf.c.html#87">aws_byte_buf_secure_zero</a>(buf);</div><div id="72" class="line none">   72     }</div><div id="73" class="line none">   73     buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = 0;</div><div id="74" class="line none">   74 }</div><div id="75" class="line none">   75 </div><div id="76" class="line none">   76 void <a href="byte_buf.c.html#76">aws_byte_buf_clean_up</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf) {</div><div id="77" class="line none">   77     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="78" class="line none">   78     if (buf-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a> &amp;&amp; buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>) {</div><div id="79" class="line none">   79         <a href="../verification/cbmc/sources/proof_allocators.c.html#201">aws_mem_release</a>(buf-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, (void *)buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>);</div><div id="80" class="line none">   80     }</div><div id="81" class="line none">   81     buf-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a> = NULL;</div><div id="82" class="line none">   82     buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> = NULL;</div><div id="83" class="line none">   83     buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = 0;</div><div id="84" class="line none">   84     buf-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> = 0;</div><div id="85" class="line none">   85 }</div><div id="86" class="line none">   86 </div><div id="87" class="line none">   87 void <a href="byte_buf.c.html#87">aws_byte_buf_secure_zero</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf) {</div><div id="88" class="line hit">   88     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="89" class="line hit">   89     if (buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>) {</div><div id="90" class="line hit">   90         <a href="common.c.html#27">aws_secure_zero</a>(buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, buf-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>);</div><div id="91" class="line none">   91     }</div><div id="92" class="line hit">   92     buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = 0;</div><div id="93" class="line hit">   93     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="94" class="line hit">   94 }</div><div id="95" class="line none">   95 </div><div id="96" class="line none">   96 void <a href="byte_buf.c.html#96">aws_byte_buf_clean_up_secure</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf) {</div><div id="97" class="line none">   97     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="98" class="line none">   98     <a href="byte_buf.c.html#87">aws_byte_buf_secure_zero</a>(buf);</div><div id="99" class="line none">   99     <a href="byte_buf.c.html#76">aws_byte_buf_clean_up</a>(buf);</div><div id="100" class="line none">  100     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="101" class="line none">  101 }</div><div id="102" class="line none">  102 </div><div id="103" class="line none">  103 bool <a href="byte_buf.c.html#103">aws_byte_buf_eq</a>(const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const a, const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const b) {</div><div id="104" class="line none">  104     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(a));</div><div id="105" class="line none">  105     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(b));</div><div id="106" class="line none">  106     bool rval = <a href="byte_buf.c.html#419">aws_array_eq</a>(a-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, a-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="107" class="line none">  107     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(a));</div><div id="108" class="line none">  108     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(b));</div><div id="109" class="line none">  109     return rval;</div><div id="110" class="line none">  110 }</div><div id="111" class="line none">  111 </div><div id="112" class="line none">  112 bool <a href="byte_buf.c.html#112">aws_byte_buf_eq_ignore_case</a>(const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const a, const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const b) {</div><div id="113" class="line none">  113     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(a));</div><div id="114" class="line none">  114     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(b));</div><div id="115" class="line none">  115     bool rval = <a href="byte_buf.c.html#394">aws_array_eq_ignore_case</a>(a-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, a-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="116" class="line none">  116     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(a));</div><div id="117" class="line none">  117     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(b));</div><div id="118" class="line none">  118     return rval;</div><div id="119" class="line none">  119 }</div><div id="120" class="line none">  120 </div><div id="121" class="line none">  121 bool <a href="byte_buf.c.html#121">aws_byte_buf_eq_c_str</a>(const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const buf, const char *const c_str) {</div><div id="122" class="line none">  122     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="123" class="line none">  123     AWS_PRECONDITION(c_str != NULL);</div><div id="124" class="line none">  124     bool rval = <a href="byte_buf.c.html#464">aws_array_eq_c_str</a>(buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, c_str);</div><div id="125" class="line none">  125     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="126" class="line none">  126     return rval;</div><div id="127" class="line none">  127 }</div><div id="128" class="line none">  128 </div><div id="129" class="line none">  129 bool <a href="byte_buf.c.html#129">aws_byte_buf_eq_c_str_ignore_case</a>(const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const buf, const char *const c_str) {</div><div id="130" class="line none">  130     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="131" class="line none">  131     AWS_PRECONDITION(c_str != NULL);</div><div id="132" class="line none">  132     bool rval = <a href="byte_buf.c.html#436">aws_array_eq_c_str_ignore_case</a>(buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, c_str);</div><div id="133" class="line none">  133     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="134" class="line none">  134     return rval;</div><div id="135" class="line none">  135 }</div><div id="136" class="line none">  136 </div><div id="137" class="line none">  137 int <a href="byte_buf.c.html#137">aws_byte_buf_init_copy_from_cursor</a>(</div><div id="138" class="line none">  138     struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *dest,</div><div id="139" class="line none">  139     struct <a href="../include/aws/common/allocator.h.html#15">aws_allocator</a> *<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>,</div><div id="140" class="line none">  140     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> src) {</div><div id="141" class="line none">  141     AWS_PRECONDITION(<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>);</div><div id="142" class="line none">  142     AWS_PRECONDITION(dest);</div><div id="143" class="line none">  143     AWS_ERROR_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(&amp;src));</div><div id="144" class="line none">  144 </div><div id="145" class="line none">  145     AWS_ZERO_STRUCT(*dest);</div><div id="146" class="line none">  146 </div><div id="147" class="line none">  147     dest-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> = (src.<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0) ? (uint8_t *)<a href="../verification/cbmc/sources/proof_allocators.c.html#116">aws_mem_acquire</a>(<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, src.<a href="../include/aws/common/byte_buf.h.html#27">len</a>) : NULL;</div><div id="148" class="line none">  148     if (src.<a href="../include/aws/common/byte_buf.h.html#27">len</a> != 0 &amp;&amp; dest-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> == NULL) {</div><div id="149" class="line none">  149         return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="150" class="line none">  150     }</div><div id="151" class="line none">  151 </div><div id="152" class="line none">  152     dest-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = src.<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="153" class="line none">  153     dest-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> = src.<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="154" class="line none">  154     dest-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a> = <a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>;</div><div id="155" class="line none">  155     if (src.<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0) {</div><div id="156" class="line none">  156         memcpy(dest-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, src.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, src.<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="157" class="line none">  157     }</div><div id="158" class="line none">  158     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(dest));</div><div id="159" class="line none">  159     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="160" class="line none">  160 }</div><div id="161" class="line none">  161 </div><div id="162" class="line none">  162 int <a href="byte_buf.c.html#162">aws_byte_buf_init_cache_and_update_cursors</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *dest, struct <a href="../include/aws/common/allocator.h.html#15">aws_allocator</a> *<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, ...) {</div><div id="163" class="line none">  163     AWS_PRECONDITION(<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>);</div><div id="164" class="line none">  164     AWS_PRECONDITION(dest);</div><div id="165" class="line none">  165 </div><div id="166" class="line none">  166     AWS_ZERO_STRUCT(*dest);</div><div id="167" class="line none">  167 </div><div id="168" class="line none">  168     size_t total_len = 0;</div><div id="169" class="line none">  169     va_list args;</div><div id="170" class="line none">  170     va_start(args, <a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>);</div><div id="171" class="line none">  171 </div><div id="172" class="line none">  172     /* Loop until final NULL arg is encountered */</div><div id="173" class="line none">  173     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *cursor_i;</div><div id="174" class="line none">  174     while ((cursor_i = va_arg(args, struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *)) != NULL) {</div><div id="175" class="line none">  175         AWS_ASSERT(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cursor_i));</div><div id="176" class="line none">  176         if (<a href="../include/aws/common/math.inl.html#126">aws_add_size_checked</a>(total_len, cursor_i-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, &amp;total_len)) {</div><div id="177" class="line none">  177             return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="178" class="line none">  178         }</div><div id="179" class="line none">  179     }</div><div id="180" class="line none">  180     va_end(args);</div><div id="181" class="line none">  181 </div><div id="182" class="line none">  182     if (<a href="byte_buf.c.html#17">aws_byte_buf_init</a>(dest, <a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, total_len)) {</div><div id="183" class="line none">  183         return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="184" class="line none">  184     }</div><div id="185" class="line none">  185 </div><div id="186" class="line none">  186     va_start(args, <a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>);</div><div id="187" class="line none">  187     while ((cursor_i = va_arg(args, struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *)) != NULL) {</div><div id="188" class="line none">  188         /* Impossible for this call to fail, we pre-allocated sufficient space */</div><div id="189" class="line none">  189         <a href="byte_buf.c.html#1577">aws_byte_buf_append_and_update</a>(dest, cursor_i);</div><div id="190" class="line none">  190     }</div><div id="191" class="line none">  191     va_end(args);</div><div id="192" class="line none">  192 </div><div id="193" class="line none">  193     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="194" class="line none">  194 }</div><div id="195" class="line none">  195 </div><div id="196" class="line none">  196 bool <a href="byte_buf.c.html#196">aws_byte_cursor_next_split</a>(</div><div id="197" class="line none">  197     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT input_str,</div><div id="198" class="line none">  198     char split_on,</div><div id="199" class="line none">  199     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT substr) {</div><div id="200" class="line none">  200 </div><div id="201" class="line none">  201     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(input_str));</div><div id="202" class="line none">  202 </div><div id="203" class="line none">  203     /* If substr is zeroed-out, then this is the first run. */</div><div id="204" class="line none">  204     const bool first_run = substr-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> == NULL;</div><div id="205" class="line none">  205 </div><div id="206" class="line none">  206     /* It's legal for input_str to be zeroed out: {.ptr=NULL, .len=0}</div><div id="207" class="line none">  207      * Deal with this case separately */</div><div id="208" class="line none">  208     if (AWS_UNLIKELY(input_str-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> == NULL)) {</div><div id="209" class="line none">  209         if (first_run) {</div><div id="210" class="line none">  210             /* Set substr-&gt;ptr to something non-NULL so that next split() call doesn't look like the first run */</div><div id="211" class="line none">  211             substr-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = (void *)"";</div><div id="212" class="line none">  212             substr-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = 0;</div><div id="213" class="line none">  213             return true;</div><div id="214" class="line none">  214         }</div><div id="215" class="line none">  215 </div><div id="216" class="line none">  216         /* done */</div><div id="217" class="line none">  217         AWS_ZERO_STRUCT(*substr);</div><div id="218" class="line none">  218         return false;</div><div id="219" class="line none">  219     }</div><div id="220" class="line none">  220 </div><div id="221" class="line none">  221     /* Rest of function deals with non-NULL input_str-&gt;ptr */</div><div id="222" class="line none">  222 </div><div id="223" class="line none">  223     if (first_run) {</div><div id="224" class="line none">  224         *substr = *input_str;</div><div id="225" class="line none">  225     } else {</div><div id="226" class="line none">  226         /* This is not the first run.</div><div id="227" class="line none">  227          * Advance substr past the previous split. */</div><div id="228" class="line none">  228         const uint8_t *input_end = input_str-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> + input_str-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="229" class="line none">  229         substr-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> += substr-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> + 1;</div><div id="230" class="line none">  230 </div><div id="231" class="line none">  231         /* Note that it's ok if substr-&gt;ptr == input_end, this happens in the</div><div id="232" class="line none">  232          * final valid split of an input_str that ends with the split_on character:</div><div id="233" class="line none">  233          * Ex: "AB&amp;" split on '&amp;' produces "AB" and "" */</div><div id="234" class="line none">  234         if (substr-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> &gt; input_end || substr-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> &lt; input_str-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>) { /* 2nd check is overflow check */</div><div id="235" class="line none">  235             /* done */</div><div id="236" class="line none">  236             AWS_ZERO_STRUCT(*substr);</div><div id="237" class="line none">  237             return false;</div><div id="238" class="line none">  238         }</div><div id="239" class="line none">  239 </div><div id="240" class="line none">  240         /* update len to be remainder of the string */</div><div id="241" class="line none">  241         substr-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = input_str-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> - (substr-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> - input_str-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>);</div><div id="242" class="line none">  242     }</div><div id="243" class="line none">  243 </div><div id="244" class="line none">  244     /* substr is now remainder of string, search for next split */</div><div id="245" class="line none">  245     uint8_t *new_location = memchr(substr-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, split_on, substr-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="246" class="line none">  246     if (new_location) {</div><div id="247" class="line none">  247 </div><div id="248" class="line none">  248         /* Character found, update string length. */</div><div id="249" class="line none">  249         substr-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = new_location - substr-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>;</div><div id="250" class="line none">  250     }</div><div id="251" class="line none">  251 </div><div id="252" class="line none">  252     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(substr));</div><div id="253" class="line none">  253     return true;</div><div id="254" class="line none">  254 }</div><div id="255" class="line none">  255 </div><div id="256" class="line none">  256 int <a href="byte_buf.c.html#256">aws_byte_cursor_split_on_char_n</a>(</div><div id="257" class="line none">  257     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT input_str,</div><div id="258" class="line none">  258     char split_on,</div><div id="259" class="line none">  259     size_t n,</div><div id="260" class="line none">  260     struct <a href="../include/aws/common/array_list.h.html#15">aws_array_list</a> *AWS_RESTRICT output) {</div><div id="261" class="line none">  261     AWS_ASSERT(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(input_str));</div><div id="262" class="line none">  262     AWS_ASSERT(output);</div><div id="263" class="line none">  263     AWS_ASSERT(output-&gt;<a href="../include/aws/common/array_list.h.html#19">item_size</a> &gt;= sizeof(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a>));</div><div id="264" class="line none">  264 </div><div id="265" class="line none">  265     size_t max_splits = n &gt; 0 ? n : SIZE_MAX;</div><div id="266" class="line none">  266     size_t split_count = 0;</div><div id="267" class="line none">  267 </div><div id="268" class="line none">  268     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> substr;</div><div id="269" class="line none">  269     AWS_ZERO_STRUCT(substr);</div><div id="270" class="line none">  270 </div><div id="271" class="line none">  271     /* Until we run out of substrs or hit the max split count, keep iterating and pushing into the array list. */</div><div id="272" class="line none">  272     while (split_count &lt;= max_splits &amp;&amp; <a href="byte_buf.c.html#196">aws_byte_cursor_next_split</a>(input_str, split_on, &amp;substr)) {</div><div id="273" class="line none">  273 </div><div id="274" class="line none">  274         if (split_count == max_splits) {</div><div id="275" class="line none">  275             /* If this is the last split, take the rest of the string. */</div><div id="276" class="line none">  276             substr.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = input_str-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> - (substr.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> - input_str-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>);</div><div id="277" class="line none">  277         }</div><div id="278" class="line none">  278 </div><div id="279" class="line none">  279         if (AWS_UNLIKELY(<a href="../include/aws/common/array_list.inl.html#130">aws_array_list_push_back</a>(output, (const void *)&amp;substr))) {</div><div id="280" class="line none">  280             return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="281" class="line none">  281         }</div><div id="282" class="line none">  282         ++split_count;</div><div id="283" class="line none">  283     }</div><div id="284" class="line none">  284 </div><div id="285" class="line none">  285     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="286" class="line none">  286 }</div><div id="287" class="line none">  287 </div><div id="288" class="line none">  288 int <a href="byte_buf.c.html#288">aws_byte_cursor_split_on_char</a>(</div><div id="289" class="line none">  289     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT input_str,</div><div id="290" class="line none">  290     char split_on,</div><div id="291" class="line none">  291     struct <a href="../include/aws/common/array_list.h.html#15">aws_array_list</a> *AWS_RESTRICT output) {</div><div id="292" class="line none">  292 </div><div id="293" class="line none">  293     return <a href="byte_buf.c.html#256">aws_byte_cursor_split_on_char_n</a>(input_str, split_on, 0, output);</div><div id="294" class="line none">  294 }</div><div id="295" class="line none">  295 </div><div id="296" class="line none">  296 int <a href="byte_buf.c.html#296">aws_byte_cursor_find_exact</a>(</div><div id="297" class="line none">  297     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT input_str,</div><div id="298" class="line none">  298     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT to_find,</div><div id="299" class="line none">  299     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *first_find) {</div><div id="300" class="line none">  300     if (to_find-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; input_str-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="301" class="line none">  301         return <a href="../include/aws/common/error.inl.html#17">aws_raise_error</a>(<a href="../include/aws/common/error.h.html#191">AWS_ERROR_STRING_MATCH_NOT_FOUND</a>);</div><div id="302" class="line none">  302     }</div><div id="303" class="line none">  303 </div><div id="304" class="line none">  304     if (to_find-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &lt; 1) {</div><div id="305" class="line none">  305         return <a href="../include/aws/common/error.inl.html#17">aws_raise_error</a>(<a href="../include/aws/common/error.h.html#147">AWS_ERROR_SHORT_BUFFER</a>);</div><div id="306" class="line none">  306     }</div><div id="307" class="line none">  307 </div><div id="308" class="line none">  308     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> working_cur = *input_str;</div><div id="309" class="line none">  309 </div><div id="310" class="line none">  310     while (working_cur.<a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="311" class="line none">  311         uint8_t *first_char_location = memchr(working_cur.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, (char)*to_find-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, working_cur.<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="312" class="line none">  312 </div><div id="313" class="line none">  313         if (!first_char_location) {</div><div id="314" class="line none">  314             return <a href="../include/aws/common/error.inl.html#17">aws_raise_error</a>(<a href="../include/aws/common/error.h.html#191">AWS_ERROR_STRING_MATCH_NOT_FOUND</a>);</div><div id="315" class="line none">  315         }</div><div id="316" class="line none">  316 </div><div id="317" class="line none">  317         <a href="byte_buf.c.html#1041">aws_byte_cursor_advance</a>(&amp;working_cur, first_char_location - working_cur.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>);</div><div id="318" class="line none">  318 </div><div id="319" class="line none">  319         if (working_cur.<a href="../include/aws/common/byte_buf.h.html#27">len</a> &lt; to_find-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="320" class="line none">  320             return <a href="../include/aws/common/error.inl.html#17">aws_raise_error</a>(<a href="../include/aws/common/error.h.html#191">AWS_ERROR_STRING_MATCH_NOT_FOUND</a>);</div><div id="321" class="line none">  321         }</div><div id="322" class="line none">  322 </div><div id="323" class="line none">  323         if (!memcmp(working_cur.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, to_find-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, to_find-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>)) {</div><div id="324" class="line none">  324             *first_find = working_cur;</div><div id="325" class="line none">  325             return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="326" class="line none">  326         }</div><div id="327" class="line none">  327 </div><div id="328" class="line none">  328         <a href="byte_buf.c.html#1041">aws_byte_cursor_advance</a>(&amp;working_cur, 1);</div><div id="329" class="line none">  329     }</div><div id="330" class="line none">  330 </div><div id="331" class="line none">  331     return <a href="../include/aws/common/error.inl.html#17">aws_raise_error</a>(<a href="../include/aws/common/error.h.html#191">AWS_ERROR_STRING_MATCH_NOT_FOUND</a>);</div><div id="332" class="line none">  332 }</div><div id="333" class="line none">  333 </div><div id="334" class="line none">  334 int <a href="byte_buf.c.html#334">aws_byte_buf_cat</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *dest, size_t number_of_args, ...) {</div><div id="335" class="line none">  335     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(dest));</div><div id="336" class="line none">  336 </div><div id="337" class="line none">  337     va_list ap;</div><div id="338" class="line none">  338     va_start(ap, number_of_args);</div><div id="339" class="line none">  339 </div><div id="340" class="line none">  340     for (size_t i = 0; i &lt; number_of_args; ++i) {</div><div id="341" class="line none">  341         struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> = va_arg(ap, struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *);</div><div id="342" class="line none">  342         struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> cursor = <a href="byte_buf.c.html#933">aws_byte_cursor_from_buf</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>);</div><div id="343" class="line none">  343 </div><div id="344" class="line none">  344         if (<a href="byte_buf.c.html#561">aws_byte_buf_append</a>(dest, &amp;cursor)) {</div><div id="345" class="line none">  345             va_end(ap);</div><div id="346" class="line none">  346             AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(dest));</div><div id="347" class="line none">  347             return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="348" class="line none">  348         }</div><div id="349" class="line none">  349     }</div><div id="350" class="line none">  350 </div><div id="351" class="line none">  351     va_end(ap);</div><div id="352" class="line none">  352     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(dest));</div><div id="353" class="line none">  353     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="354" class="line none">  354 }</div><div id="355" class="line none">  355 </div><div id="356" class="line none">  356 bool <a href="byte_buf.c.html#356">aws_byte_cursor_eq</a>(const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *a, const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *b) {</div><div id="357" class="line none">  357     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(a));</div><div id="358" class="line none">  358     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(b));</div><div id="359" class="line none">  359     bool rv = <a href="byte_buf.c.html#419">aws_array_eq</a>(a-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, a-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="360" class="line none">  360     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(a));</div><div id="361" class="line none">  361     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(b));</div><div id="362" class="line none">  362     return rv;</div><div id="363" class="line none">  363 }</div><div id="364" class="line none">  364 </div><div id="365" class="line none">  365 bool <a href="byte_buf.c.html#365">aws_byte_cursor_eq_ignore_case</a>(const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *a, const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *b) {</div><div id="366" class="line none">  366     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(a));</div><div id="367" class="line none">  367     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(b));</div><div id="368" class="line none">  368     bool rv = <a href="byte_buf.c.html#394">aws_array_eq_ignore_case</a>(a-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, a-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="369" class="line none">  369     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(a));</div><div id="370" class="line none">  370     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(b));</div><div id="371" class="line none">  371     return rv;</div><div id="372" class="line none">  372 }</div><div id="373" class="line none">  373 </div><div id="374" class="line none">  374 /* Every possible uint8_t value, lowercased */</div><div id="375" class="line none">  375 static const uint8_t <a href="byte_buf.c.html#375">s_tolower_table</a>[] = {</div><div id="376" class="line none">  376     0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,</div><div id="377" class="line none">  377     22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,</div><div id="378" class="line none">  378     44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  'a',</div><div id="379" class="line none">  379     'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', '<a href="../../sources/openssl/ec_override.c.html#282">r</a>', '<a href="../../sources/openssl/ec_override.c.html#283">s</a>', 't', 'u', 'v', 'w',</div><div id="380" class="line none">  380     'x', 'y', 'z', 91,  92,  93,  94,  95,  96,  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',</div><div id="381" class="line none">  381     'n', 'o', 'p', 'q', '<a href="../../sources/openssl/ec_override.c.html#282">r</a>', '<a href="../../sources/openssl/ec_override.c.html#283">s</a>', 't', 'u', 'v', 'w', 'x', 'y', 'z', 123, 124, 125, 126, 127, 128, 129, 130, 131,</div><div id="382" class="line none">  382     132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,</div><div id="383" class="line none">  383     154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,</div><div id="384" class="line none">  384     176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,</div><div id="385" class="line none">  385     198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,</div><div id="386" class="line none">  386     220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,</div><div id="387" class="line none">  387     242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255};</div><div id="388" class="line none">  388 AWS_STATIC_ASSERT(AWS_ARRAY_SIZE(<a href="byte_buf.c.html#375">s_tolower_table</a>) == 256);</div><div id="389" class="line none">  389 </div><div id="390" class="line none">  390 const uint8_t *<a href="byte_buf.c.html#390">aws_lookup_table_to_lower_get</a>(void) {</div><div id="391" class="line none">  391     return <a href="byte_buf.c.html#375">s_tolower_table</a>;</div><div id="392" class="line none">  392 }</div><div id="393" class="line none">  393 </div><div id="394" class="line none">  394 bool <a href="byte_buf.c.html#394">aws_array_eq_ignore_case</a>(</div><div id="395" class="line none">  395     const void *const array_a,</div><div id="396" class="line none">  396     const size_t len_a,</div><div id="397" class="line none">  397     const void *const array_b,</div><div id="398" class="line none">  398     const size_t len_b) {</div><div id="399" class="line none">  399     AWS_PRECONDITION(</div><div id="400" class="line none">  400         (len_a == 0) || AWS_MEM_IS_READABLE(array_a, len_a), "Input array [array_a] must be readable up to [len_a].");</div><div id="401" class="line none">  401     AWS_PRECONDITION(</div><div id="402" class="line none">  402         (len_b == 0) || AWS_MEM_IS_READABLE(array_b, len_b), "Input array [array_b] must be readable up to [len_b].");</div><div id="403" class="line none">  403 </div><div id="404" class="line none">  404     if (len_a != len_b) {</div><div id="405" class="line none">  405         return false;</div><div id="406" class="line none">  406     }</div><div id="407" class="line none">  407 </div><div id="408" class="line none">  408     const uint8_t *bytes_a = array_a;</div><div id="409" class="line none">  409     const uint8_t *bytes_b = array_b;</div><div id="410" class="line none">  410     for (size_t i = 0; i &lt; len_a; ++i) {</div><div id="411" class="line none">  411         if (<a href="byte_buf.c.html#375">s_tolower_table</a>[bytes_a[i]] != <a href="byte_buf.c.html#375">s_tolower_table</a>[bytes_b[i]]) {</div><div id="412" class="line none">  412             return false;</div><div id="413" class="line none">  413         }</div><div id="414" class="line none">  414     }</div><div id="415" class="line none">  415 </div><div id="416" class="line none">  416     return true;</div><div id="417" class="line none">  417 }</div><div id="418" class="line none">  418 </div><div id="419" class="line none">  419 bool <a href="byte_buf.c.html#419">aws_array_eq</a>(const void *const array_a, const size_t len_a, const void *const array_b, const size_t len_b) {</div><div id="420" class="line none">  420     AWS_PRECONDITION(</div><div id="421" class="line none">  421         (len_a == 0) || AWS_MEM_IS_READABLE(array_a, len_a), "Input array [array_a] must be readable up to [len_a].");</div><div id="422" class="line none">  422     AWS_PRECONDITION(</div><div id="423" class="line none">  423         (len_b == 0) || AWS_MEM_IS_READABLE(array_b, len_b), "Input array [array_b] must be readable up to [len_b].");</div><div id="424" class="line none">  424 </div><div id="425" class="line none">  425     if (len_a != len_b) {</div><div id="426" class="line none">  426         return false;</div><div id="427" class="line none">  427     }</div><div id="428" class="line none">  428 </div><div id="429" class="line none">  429     if (len_a == 0) {</div><div id="430" class="line none">  430         return true;</div><div id="431" class="line none">  431     }</div><div id="432" class="line none">  432 </div><div id="433" class="line none">  433     return !memcmp(array_a, array_b, len_a);</div><div id="434" class="line none">  434 }</div><div id="435" class="line none">  435 </div><div id="436" class="line none">  436 bool <a href="byte_buf.c.html#436">aws_array_eq_c_str_ignore_case</a>(const void *const array, const size_t array_len, const char *const c_str) {</div><div id="437" class="line none">  437     AWS_PRECONDITION(</div><div id="438" class="line none">  438         array || (array_len == 0),</div><div id="439" class="line none">  439         "Either input pointer [array_a] mustn't be NULL or input [array_len] mustn't be zero.");</div><div id="440" class="line none">  440     AWS_PRECONDITION(c_str != NULL);</div><div id="441" class="line none">  441 </div><div id="442" class="line none">  442     /* Simpler implementation could have been:</div><div id="443" class="line none">  443      *   return aws_array_eq_ignore_case(array, array_len, c_str, strlen(c_str));</div><div id="444" class="line none">  444      * but that would have traversed c_str twice.</div><div id="445" class="line none">  445      * This implementation traverses c_str just once. */</div><div id="446" class="line none">  446 </div><div id="447" class="line none">  447     const uint8_t *array_bytes = array;</div><div id="448" class="line none">  448     const uint8_t *str_bytes = (const uint8_t *)c_str;</div><div id="449" class="line none">  449 </div><div id="450" class="line none">  450     for (size_t i = 0; i &lt; array_len; ++i) {</div><div id="451" class="line none">  451         uint8_t <a href="../../sources/openssl/ec_override.c.html#283">s</a> = str_bytes[i];</div><div id="452" class="line none">  452         if (<a href="../../sources/openssl/ec_override.c.html#283">s</a> == '\0') {</div><div id="453" class="line none">  453             return false;</div><div id="454" class="line none">  454         }</div><div id="455" class="line none">  455 </div><div id="456" class="line none">  456         if (<a href="byte_buf.c.html#375">s_tolower_table</a>[array_bytes[i]] != <a href="byte_buf.c.html#375">s_tolower_table</a>[<a href="../../sources/openssl/ec_override.c.html#283">s</a>]) {</div><div id="457" class="line none">  457             return false;</div><div id="458" class="line none">  458         }</div><div id="459" class="line none">  459     }</div><div id="460" class="line none">  460 </div><div id="461" class="line none">  461     return str_bytes[array_len] == '\0';</div><div id="462" class="line none">  462 }</div><div id="463" class="line none">  463 </div><div id="464" class="line none">  464 bool <a href="byte_buf.c.html#464">aws_array_eq_c_str</a>(const void *const array, const size_t array_len, const char *const c_str) {</div><div id="465" class="line none">  465     AWS_PRECONDITION(</div><div id="466" class="line none">  466         array || (array_len == 0),</div><div id="467" class="line none">  467         "Either input pointer [array_a] mustn't be NULL or input [array_len] mustn't be zero.");</div><div id="468" class="line none">  468     AWS_PRECONDITION(c_str != NULL);</div><div id="469" class="line none">  469 </div><div id="470" class="line none">  470     /* Simpler implementation could have been:</div><div id="471" class="line none">  471      *   return aws_array_eq(array, array_len, c_str, strlen(c_str));</div><div id="472" class="line none">  472      * but that would have traversed c_str twice.</div><div id="473" class="line none">  473      * This implementation traverses c_str just once. */</div><div id="474" class="line none">  474 </div><div id="475" class="line none">  475     const uint8_t *array_bytes = array;</div><div id="476" class="line none">  476     const uint8_t *str_bytes = (const uint8_t *)c_str;</div><div id="477" class="line none">  477 </div><div id="478" class="line none">  478     for (size_t i = 0; i &lt; array_len; ++i) {</div><div id="479" class="line none">  479         uint8_t <a href="../../sources/openssl/ec_override.c.html#283">s</a> = str_bytes[i];</div><div id="480" class="line none">  480         if (<a href="../../sources/openssl/ec_override.c.html#283">s</a> == '\0') {</div><div id="481" class="line none">  481             return false;</div><div id="482" class="line none">  482         }</div><div id="483" class="line none">  483 </div><div id="484" class="line none">  484         if (array_bytes[i] != <a href="../../sources/openssl/ec_override.c.html#283">s</a>) {</div><div id="485" class="line none">  485             return false;</div><div id="486" class="line none">  486         }</div><div id="487" class="line none">  487     }</div><div id="488" class="line none">  488 </div><div id="489" class="line none">  489     return str_bytes[array_len] == '\0';</div><div id="490" class="line none">  490 }</div><div id="491" class="line none">  491 </div><div id="492" class="line none">  492 uint64_t <a href="byte_buf.c.html#492">aws_hash_array_ignore_case</a>(const void *array, const size_t <a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="493" class="line none">  493     AWS_PRECONDITION(AWS_MEM_IS_READABLE(array, <a href="../include/aws/common/byte_buf.h.html#27">len</a>));</div><div id="494" class="line none">  494     /* FNV-1a: https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function */</div><div id="495" class="line none">  495     const uint64_t fnv_offset_basis = 0xcbf29ce484222325ULL;</div><div id="496" class="line none">  496     const uint64_t fnv_prime = 0x100000001b3ULL;</div><div id="497" class="line none">  497 </div><div id="498" class="line none">  498     const uint8_t *i = array;</div><div id="499" class="line none">  499     const uint8_t *end = i + <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="500" class="line none">  500 </div><div id="501" class="line none">  501     uint64_t hash = fnv_offset_basis;</div><div id="502" class="line none">  502     while (i != end) {</div><div id="503" class="line none">  503         const uint8_t lower = <a href="byte_buf.c.html#375">s_tolower_table</a>[*i++];</div><div id="504" class="line none">  504         hash ^= lower;</div><div id="505" class="line none">  505 #ifdef CBMC</div><div id="506" class="line none">  506 #    pragma CPROVER check push</div><div id="507" class="line none">  507 #    pragma CPROVER check disable "unsigned-overflow"</div><div id="508" class="line none">  508 #endif</div><div id="509" class="line none">  509         hash *= fnv_prime;</div><div id="510" class="line none">  510 #ifdef CBMC</div><div id="511" class="line none">  511 #    pragma CPROVER check pop</div><div id="512" class="line none">  512 #endif</div><div id="513" class="line none">  513     }</div><div id="514" class="line none">  514     return hash;</div><div id="515" class="line none">  515 }</div><div id="516" class="line none">  516 </div><div id="517" class="line none">  517 uint64_t <a href="byte_buf.c.html#517">aws_hash_byte_cursor_ptr_ignore_case</a>(const void *item) {</div><div id="518" class="line none">  518     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(item));</div><div id="519" class="line none">  519     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const cursor = item;</div><div id="520" class="line none">  520     uint64_t rval = <a href="byte_buf.c.html#492">aws_hash_array_ignore_case</a>(cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="521" class="line none">  521     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(item));</div><div id="522" class="line none">  522     return rval;</div><div id="523" class="line none">  523 }</div><div id="524" class="line none">  524 </div><div id="525" class="line none">  525 bool <a href="byte_buf.c.html#525">aws_byte_cursor_eq_byte_buf</a>(const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const a, const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const b) {</div><div id="526" class="line none">  526     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(a));</div><div id="527" class="line none">  527     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(b));</div><div id="528" class="line none">  528     bool rv = <a href="byte_buf.c.html#419">aws_array_eq</a>(a-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, a-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="529" class="line none">  529     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(a));</div><div id="530" class="line none">  530     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(b));</div><div id="531" class="line none">  531     return rv;</div><div id="532" class="line none">  532 }</div><div id="533" class="line none">  533 </div><div id="534" class="line none">  534 bool <a href="byte_buf.c.html#534">aws_byte_cursor_eq_byte_buf_ignore_case</a>(</div><div id="535" class="line none">  535     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const a,</div><div id="536" class="line none">  536     const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const b) {</div><div id="537" class="line none">  537     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(a));</div><div id="538" class="line none">  538     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(b));</div><div id="539" class="line none">  539     bool rv = <a href="byte_buf.c.html#394">aws_array_eq_ignore_case</a>(a-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, a-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, b-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="540" class="line none">  540     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(a));</div><div id="541" class="line none">  541     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(b));</div><div id="542" class="line none">  542     return rv;</div><div id="543" class="line none">  543 }</div><div id="544" class="line none">  544 </div><div id="545" class="line none">  545 bool <a href="byte_buf.c.html#545">aws_byte_cursor_eq_c_str</a>(const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const cursor, const char *const c_str) {</div><div id="546" class="line none">  546     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cursor));</div><div id="547" class="line none">  547     AWS_PRECONDITION(c_str != NULL);</div><div id="548" class="line none">  548     bool rv = <a href="byte_buf.c.html#464">aws_array_eq_c_str</a>(cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, c_str);</div><div id="549" class="line none">  549     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cursor));</div><div id="550" class="line none">  550     return rv;</div><div id="551" class="line none">  551 }</div><div id="552" class="line none">  552 </div><div id="553" class="line none">  553 bool <a href="byte_buf.c.html#553">aws_byte_cursor_eq_c_str_ignore_case</a>(const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const cursor, const char *const c_str) {</div><div id="554" class="line none">  554     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cursor));</div><div id="555" class="line none">  555     AWS_PRECONDITION(c_str != NULL);</div><div id="556" class="line none">  556     bool rv = <a href="byte_buf.c.html#436">aws_array_eq_c_str_ignore_case</a>(cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, c_str);</div><div id="557" class="line none">  557     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cursor));</div><div id="558" class="line none">  558     return rv;</div><div id="559" class="line none">  559 }</div><div id="560" class="line none">  560 </div><div id="561" class="line none">  561 int <a href="byte_buf.c.html#561">aws_byte_buf_append</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *to, const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *<a href="../../sources/openssl/evp_override.c.html#412">from</a>) {</div><div id="562" class="line none">  562     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="563" class="line none">  563     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="564" class="line none">  564 </div><div id="565" class="line none">  565     if (to-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> - to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &lt; <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="566" class="line none">  566         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="567" class="line none">  567         AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="568" class="line none">  568         return <a href="../include/aws/common/error.inl.html#17">aws_raise_error</a>(<a href="../include/aws/common/error.h.html#169">AWS_ERROR_DEST_COPY_TOO_SMALL</a>);</div><div id="569" class="line none">  569     }</div><div id="570" class="line none">  570 </div><div id="571" class="line none">  571     if (<a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0) {</div><div id="572" class="line none">  572         /* This assert teaches clang-tidy that from-&gt;ptr and to-&gt;buffer cannot be null in a non-empty buffers */</div><div id="573" class="line none">  573         AWS_ASSERT(<a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>);</div><div id="574" class="line none">  574         AWS_ASSERT(to-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>);</div><div id="575" class="line none">  575         memcpy(to-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> + to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="576" class="line none">  576         to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> += <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="577" class="line none">  577     }</div><div id="578" class="line none">  578 </div><div id="579" class="line none">  579     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="580" class="line none">  580     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="581" class="line none">  581     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="582" class="line none">  582 }</div><div id="583" class="line none">  583 </div><div id="584" class="line none">  584 int <a href="byte_buf.c.html#584">aws_byte_buf_append_with_lookup</a>(</div><div id="585" class="line none">  585     struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT to,</div><div id="586" class="line none">  586     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT <a href="../../sources/openssl/evp_override.c.html#412">from</a>,</div><div id="587" class="line none">  587     const uint8_t *lookup_table) {</div><div id="588" class="line none">  588     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="589" class="line none">  589     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="590" class="line none">  590     AWS_PRECONDITION(</div><div id="591" class="line none">  591         AWS_MEM_IS_READABLE(lookup_table, 256), "Input array [lookup_table] must be at least 256 bytes long.");</div><div id="592" class="line none">  592 </div><div id="593" class="line none">  593     if (to-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> - to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &lt; <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="594" class="line none">  594         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="595" class="line none">  595         AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="596" class="line none">  596         return <a href="../include/aws/common/error.inl.html#17">aws_raise_error</a>(<a href="../include/aws/common/error.h.html#169">AWS_ERROR_DEST_COPY_TOO_SMALL</a>);</div><div id="597" class="line none">  597     }</div><div id="598" class="line none">  598 </div><div id="599" class="line none">  599     for (size_t i = 0; i &lt; <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>; ++i) {</div><div id="600" class="line none">  600         to-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>[to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> + i] = lookup_table[<a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>[i]];</div><div id="601" class="line none">  601     }</div><div id="602" class="line none">  602 </div><div id="603" class="line none">  603     if (<a href="../include/aws/common/math.inl.html#126">aws_add_size_checked</a>(to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, &amp;to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>)) {</div><div id="604" class="line none">  604         return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="605" class="line none">  605     }</div><div id="606" class="line none">  606 </div><div id="607" class="line none">  607     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="608" class="line none">  608     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="609" class="line none">  609     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="610" class="line none">  610 }</div><div id="611" class="line none">  611 </div><div id="612" class="line none">  612 static int <a href="byte_buf.c.html#612">s_aws_byte_buf_append_dynamic</a>(</div><div id="613" class="line none">  613     struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *to,</div><div id="614" class="line none">  614     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *<a href="../../sources/openssl/evp_override.c.html#412">from</a>,</div><div id="615" class="line none">  615     bool clear_released_memory) {</div><div id="616" class="line none">  616     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="617" class="line none">  617     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="618" class="line none">  618     AWS_ERROR_PRECONDITION(to-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>);</div><div id="619" class="line none">  619 </div><div id="620" class="line none">  620     if (to-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> - to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &lt; <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="621" class="line none">  621         /*</div><div id="622" class="line none">  622          * NewCapacity = Max(OldCapacity * 2, OldCapacity + MissingCapacity)</div><div id="623" class="line none">  623          */</div><div id="624" class="line none">  624         size_t missing_capacity = <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> - (to-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> - to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="625" class="line none">  625 </div><div id="626" class="line none">  626         size_t required_capacity = 0;</div><div id="627" class="line none">  627         if (<a href="../include/aws/common/math.inl.html#126">aws_add_size_checked</a>(to-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>, missing_capacity, &amp;required_capacity)) {</div><div id="628" class="line none">  628             AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="629" class="line none">  629             AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="630" class="line none">  630             return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="631" class="line none">  631         }</div><div id="632" class="line none">  632 </div><div id="633" class="line none">  633         /*</div><div id="634" class="line none">  634          * It's ok if this overflows, just clamp to max possible.</div><div id="635" class="line none">  635          * In theory this lets us still grow a buffer that's larger than 1/2 size_t space</div><div id="636" class="line none">  636          * at least enough to accommodate the append.</div><div id="637" class="line none">  637          */</div><div id="638" class="line none">  638         size_t growth_capacity = <a href="../include/aws/common/math.inl.html#112">aws_add_size_saturating</a>(to-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>, to-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>);</div><div id="639" class="line none">  639 </div><div id="640" class="line none">  640         size_t new_capacity = required_capacity;</div><div id="641" class="line none">  641         if (new_capacity &lt; growth_capacity) {</div><div id="642" class="line none">  642             new_capacity = growth_capacity;</div><div id="643" class="line none">  643         }</div><div id="644" class="line none">  644 </div><div id="645" class="line none">  645         /*</div><div id="646" class="line none">  646          * Attempt to resize - we intentionally do not use reserve() in order to preserve</div><div id="647" class="line none">  647          * the (unlikely) use case of from and to being the same buffer range.</div><div id="648" class="line none">  648          */</div><div id="649" class="line none">  649 </div><div id="650" class="line none">  650         /*</div><div id="651" class="line none">  651          * Try the max, but if that fails and the required is smaller, try it in fallback</div><div id="652" class="line none">  652          */</div><div id="653" class="line none">  653         uint8_t *new_buffer = <a href="../verification/cbmc/sources/proof_allocators.c.html#116">aws_mem_acquire</a>(to-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, new_capacity);</div><div id="654" class="line none">  654         if (new_buffer == NULL) {</div><div id="655" class="line none">  655             if (new_capacity &gt; required_capacity) {</div><div id="656" class="line none">  656                 new_capacity = required_capacity;</div><div id="657" class="line none">  657                 new_buffer = <a href="../verification/cbmc/sources/proof_allocators.c.html#116">aws_mem_acquire</a>(to-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, new_capacity);</div><div id="658" class="line none">  658                 if (new_buffer == NULL) {</div><div id="659" class="line none">  659                     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="660" class="line none">  660                     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="661" class="line none">  661                     return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="662" class="line none">  662                 }</div><div id="663" class="line none">  663             } else {</div><div id="664" class="line none">  664                 AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="665" class="line none">  665                 AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="666" class="line none">  666                 return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="667" class="line none">  667             }</div><div id="668" class="line none">  668         }</div><div id="669" class="line none">  669 </div><div id="670" class="line none">  670         /*</div><div id="671" class="line none">  671          * Copy old buffer -&gt; new buffer</div><div id="672" class="line none">  672          */</div><div id="673" class="line none">  673         if (to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0) {</div><div id="674" class="line none">  674             memcpy(new_buffer, to-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="675" class="line none">  675         }</div><div id="676" class="line none">  676         /*</div><div id="677" class="line none">  677          * Copy what we actually wanted to append in the first place</div><div id="678" class="line none">  678          */</div><div id="679" class="line none">  679         if (<a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0) {</div><div id="680" class="line none">  680             memcpy(new_buffer + to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="681" class="line none">  681         }</div><div id="682" class="line none">  682 </div><div id="683" class="line none">  683         if (clear_released_memory) {</div><div id="684" class="line none">  684             <a href="common.c.html#27">aws_secure_zero</a>(to-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, to-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>);</div><div id="685" class="line none">  685         }</div><div id="686" class="line none">  686 </div><div id="687" class="line none">  687         /*</div><div id="688" class="line none">  688          * Get rid of the old buffer</div><div id="689" class="line none">  689          */</div><div id="690" class="line none">  690         <a href="../verification/cbmc/sources/proof_allocators.c.html#201">aws_mem_release</a>(to-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, to-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>);</div><div id="691" class="line none">  691 </div><div id="692" class="line none">  692         /*</div><div id="693" class="line none">  693          * Switch to the new buffer</div><div id="694" class="line none">  694          */</div><div id="695" class="line none">  695         to-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> = new_buffer;</div><div id="696" class="line none">  696         to-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> = new_capacity;</div><div id="697" class="line none">  697     } else {</div><div id="698" class="line none">  698         if (<a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0) {</div><div id="699" class="line none">  699             /* This assert teaches clang-tidy that from-&gt;ptr and to-&gt;buffer cannot be null in a non-empty buffers */</div><div id="700" class="line none">  700             AWS_ASSERT(<a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>);</div><div id="701" class="line none">  701             AWS_ASSERT(to-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>);</div><div id="702" class="line none">  702             memcpy(to-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> + to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="703" class="line none">  703         }</div><div id="704" class="line none">  704     }</div><div id="705" class="line none">  705 </div><div id="706" class="line none">  706     to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> += <a href="../../sources/openssl/evp_override.c.html#412">from</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="707" class="line none">  707 </div><div id="708" class="line none">  708     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="709" class="line none">  709     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(<a href="../../sources/openssl/evp_override.c.html#412">from</a>));</div><div id="710" class="line none">  710     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="711" class="line none">  711 }</div><div id="712" class="line none">  712 </div><div id="713" class="line none">  713 int <a href="byte_buf.c.html#713">aws_byte_buf_append_dynamic</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *to, const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *<a href="../../sources/openssl/evp_override.c.html#412">from</a>) {</div><div id="714" class="line none">  714     return <a href="byte_buf.c.html#612">s_aws_byte_buf_append_dynamic</a>(to, <a href="../../sources/openssl/evp_override.c.html#412">from</a>, false);</div><div id="715" class="line none">  715 }</div><div id="716" class="line none">  716 </div><div id="717" class="line none">  717 int <a href="byte_buf.c.html#717">aws_byte_buf_append_dynamic_secure</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *to, const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *<a href="../../sources/openssl/evp_override.c.html#412">from</a>) {</div><div id="718" class="line none">  718     return <a href="byte_buf.c.html#612">s_aws_byte_buf_append_dynamic</a>(to, <a href="../../sources/openssl/evp_override.c.html#412">from</a>, true);</div><div id="719" class="line none">  719 }</div><div id="720" class="line none">  720 </div><div id="721" class="line none">  721 static int <a href="byte_buf.c.html#721">s_aws_byte_buf_append_byte_dynamic</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, uint8_t <a href="../include/aws/common/atomics.h.html#17">value</a>, bool clear_released_memory) {</div><div id="722" class="line none">  722 #if defined(_MSC_VER)</div><div id="723" class="line none">  723 #    pragma warning(push)</div><div id="724" class="line none">  724 #    pragma warning(disable : 4221)</div><div id="725" class="line none">  725 #endif /* _MSC_VER */</div><div id="726" class="line none">  726 </div><div id="727" class="line none">  727     /* msvc isn't a fan of this pointer-to-local assignment */</div><div id="728" class="line none">  728     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> eq_cursor = {.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = 1, .<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = &amp;<a href="../include/aws/common/atomics.h.html#17">value</a>};</div><div id="729" class="line none">  729 </div><div id="730" class="line none">  730 #if defined(_MSC_VER)</div><div id="731" class="line none">  731 #    pragma warning(pop)</div><div id="732" class="line none">  732 #endif /* _MSC_VER */</div><div id="733" class="line none">  733 </div><div id="734" class="line none">  734     return <a href="byte_buf.c.html#612">s_aws_byte_buf_append_dynamic</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, &amp;eq_cursor, clear_released_memory);</div><div id="735" class="line none">  735 }</div><div id="736" class="line none">  736 </div><div id="737" class="line none">  737 int <a href="byte_buf.c.html#737">aws_byte_buf_append_byte_dynamic</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, uint8_t <a href="../include/aws/common/atomics.h.html#17">value</a>) {</div><div id="738" class="line none">  738     return <a href="byte_buf.c.html#721">s_aws_byte_buf_append_byte_dynamic</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, <a href="../include/aws/common/atomics.h.html#17">value</a>, false);</div><div id="739" class="line none">  739 }</div><div id="740" class="line none">  740 </div><div id="741" class="line none">  741 int <a href="byte_buf.c.html#741">aws_byte_buf_append_byte_dynamic_secure</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, uint8_t <a href="../include/aws/common/atomics.h.html#17">value</a>) {</div><div id="742" class="line none">  742     return <a href="byte_buf.c.html#721">s_aws_byte_buf_append_byte_dynamic</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, <a href="../include/aws/common/atomics.h.html#17">value</a>, true);</div><div id="743" class="line none">  743 }</div><div id="744" class="line none">  744 </div><div id="745" class="line none">  745 int <a href="byte_buf.c.html#745">aws_byte_buf_reserve</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, size_t requested_capacity) {</div><div id="746" class="line none">  746     AWS_ERROR_PRECONDITION(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>);</div><div id="747" class="line none">  747     AWS_ERROR_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>));</div><div id="748" class="line none">  748 </div><div id="749" class="line none">  749     if (requested_capacity &lt;= <a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>) {</div><div id="750" class="line none">  750         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>));</div><div id="751" class="line none">  751         return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="752" class="line none">  752     }</div><div id="753" class="line none">  753 </div><div id="754" class="line none">  754     if (<a href="../verification/cbmc/sources/proof_allocators.c.html#210">aws_mem_realloc</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>, (void **)&amp;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, <a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>, requested_capacity)) {</div><div id="755" class="line none">  755         return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="756" class="line none">  756     }</div><div id="757" class="line none">  757 </div><div id="758" class="line none">  758     <a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> = requested_capacity;</div><div id="759" class="line none">  759 </div><div id="760" class="line none">  760     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>));</div><div id="761" class="line none">  761     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="762" class="line none">  762 }</div><div id="763" class="line none">  763 </div><div id="764" class="line none">  764 int <a href="byte_buf.c.html#764">aws_byte_buf_reserve_relative</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, size_t additional_length) {</div><div id="765" class="line none">  765     AWS_ERROR_PRECONDITION(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a>);</div><div id="766" class="line none">  766     AWS_ERROR_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>));</div><div id="767" class="line none">  767 </div><div id="768" class="line none">  768     size_t requested_capacity = 0;</div><div id="769" class="line none">  769     if (AWS_UNLIKELY(<a href="../include/aws/common/math.inl.html#126">aws_add_size_checked</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, additional_length, &amp;requested_capacity))) {</div><div id="770" class="line none">  770         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>));</div><div id="771" class="line none">  771         return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="772" class="line none">  772     }</div><div id="773" class="line none">  773 </div><div id="774" class="line none">  774     return <a href="byte_buf.c.html#745">aws_byte_buf_reserve</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, requested_capacity);</div><div id="775" class="line none">  775 }</div><div id="776" class="line none">  776 </div><div id="777" class="line none">  777 struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> <a href="byte_buf.c.html#777">aws_byte_cursor_right_trim_pred</a>(</div><div id="778" class="line none">  778     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *source,</div><div id="779" class="line none">  779     <a href="../include/aws/common/byte_buf.h.html#67">aws_byte_predicate_fn</a> *predicate) {</div><div id="780" class="line none">  780     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(source));</div><div id="781" class="line none">  781     AWS_PRECONDITION(predicate != NULL);</div><div id="782" class="line none">  782     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> trimmed = *source;</div><div id="783" class="line none">  783 </div><div id="784" class="line none">  784     while (trimmed.<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0 &amp;&amp; predicate(*(trimmed.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> + trimmed.<a href="../include/aws/common/byte_buf.h.html#27">len</a> - 1))) {</div><div id="785" class="line none">  785         --trimmed.<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="786" class="line none">  786     }</div><div id="787" class="line none">  787     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(source));</div><div id="788" class="line none">  788     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(&amp;trimmed));</div><div id="789" class="line none">  789     return trimmed;</div><div id="790" class="line none">  790 }</div><div id="791" class="line none">  791 </div><div id="792" class="line none">  792 struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> <a href="byte_buf.c.html#792">aws_byte_cursor_left_trim_pred</a>(</div><div id="793" class="line none">  793     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *source,</div><div id="794" class="line none">  794     <a href="../include/aws/common/byte_buf.h.html#67">aws_byte_predicate_fn</a> *predicate) {</div><div id="795" class="line none">  795     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(source));</div><div id="796" class="line none">  796     AWS_PRECONDITION(predicate != NULL);</div><div id="797" class="line none">  797     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> trimmed = *source;</div><div id="798" class="line none">  798 </div><div id="799" class="line none">  799     while (trimmed.<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0 &amp;&amp; predicate(*(trimmed.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>))) {</div><div id="800" class="line none">  800         --trimmed.<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="801" class="line none">  801         ++trimmed.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>;</div><div id="802" class="line none">  802     }</div><div id="803" class="line none">  803     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(source));</div><div id="804" class="line none">  804     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(&amp;trimmed));</div><div id="805" class="line none">  805     return trimmed;</div><div id="806" class="line none">  806 }</div><div id="807" class="line none">  807 </div><div id="808" class="line none">  808 struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> <a href="byte_buf.c.html#808">aws_byte_cursor_trim_pred</a>(</div><div id="809" class="line none">  809     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *source,</div><div id="810" class="line none">  810     <a href="../include/aws/common/byte_buf.h.html#67">aws_byte_predicate_fn</a> *predicate) {</div><div id="811" class="line none">  811     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(source));</div><div id="812" class="line none">  812     AWS_PRECONDITION(predicate != NULL);</div><div id="813" class="line none">  813     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> left_trimmed = <a href="byte_buf.c.html#792">aws_byte_cursor_left_trim_pred</a>(source, predicate);</div><div id="814" class="line none">  814     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> dest = <a href="byte_buf.c.html#777">aws_byte_cursor_right_trim_pred</a>(&amp;left_trimmed, predicate);</div><div id="815" class="line none">  815     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(source));</div><div id="816" class="line none">  816     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(&amp;dest));</div><div id="817" class="line none">  817     return dest;</div><div id="818" class="line none">  818 }</div><div id="819" class="line none">  819 </div><div id="820" class="line none">  820 bool <a href="byte_buf.c.html#820">aws_byte_cursor_satisfies_pred</a>(const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *source, <a href="../include/aws/common/byte_buf.h.html#67">aws_byte_predicate_fn</a> *predicate) {</div><div id="821" class="line none">  821     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> trimmed = <a href="byte_buf.c.html#792">aws_byte_cursor_left_trim_pred</a>(source, predicate);</div><div id="822" class="line none">  822     bool rval = (trimmed.<a href="../include/aws/common/byte_buf.h.html#27">len</a> == 0);</div><div id="823" class="line none">  823     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(source));</div><div id="824" class="line none">  824     return rval;</div><div id="825" class="line none">  825 }</div><div id="826" class="line none">  826 </div><div id="827" class="line none">  827 int <a href="byte_buf.c.html#827">aws_byte_cursor_compare_lexical</a>(const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *lhs, const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *rhs) {</div><div id="828" class="line none">  828     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(lhs));</div><div id="829" class="line none">  829     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(rhs));</div><div id="830" class="line none">  830     /* make sure we don't pass NULL pointers to memcmp */</div><div id="831" class="line none">  831     AWS_PRECONDITION(lhs-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> != NULL);</div><div id="832" class="line none">  832     AWS_PRECONDITION(rhs-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> != NULL);</div><div id="833" class="line none">  833     size_t comparison_length = lhs-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="834" class="line none">  834     if (comparison_length &gt; rhs-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="835" class="line none">  835         comparison_length = rhs-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="836" class="line none">  836     }</div><div id="837" class="line none">  837 </div><div id="838" class="line none">  838     int result = memcmp(lhs-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, rhs-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, comparison_length);</div><div id="839" class="line none">  839 </div><div id="840" class="line none">  840     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(lhs));</div><div id="841" class="line none">  841     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(rhs));</div><div id="842" class="line none">  842     if (result != 0) {</div><div id="843" class="line none">  843         return result;</div><div id="844" class="line none">  844     }</div><div id="845" class="line none">  845 </div><div id="846" class="line none">  846     if (lhs-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> != rhs-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="847" class="line none">  847         return comparison_length == lhs-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> ? -1 : 1;</div><div id="848" class="line none">  848     }</div><div id="849" class="line none">  849 </div><div id="850" class="line none">  850     return 0;</div><div id="851" class="line none">  851 }</div><div id="852" class="line none">  852 </div><div id="853" class="line none">  853 int <a href="byte_buf.c.html#853">aws_byte_cursor_compare_lookup</a>(</div><div id="854" class="line none">  854     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *lhs,</div><div id="855" class="line none">  855     const struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *rhs,</div><div id="856" class="line none">  856     const uint8_t *lookup_table) {</div><div id="857" class="line none">  857     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(lhs));</div><div id="858" class="line none">  858     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(rhs));</div><div id="859" class="line none">  859     AWS_PRECONDITION(AWS_MEM_IS_READABLE(lookup_table, 256));</div><div id="860" class="line none">  860     const uint8_t *lhs_curr = lhs-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>;</div><div id="861" class="line none">  861     const uint8_t *lhs_end = lhs_curr + lhs-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="862" class="line none">  862 </div><div id="863" class="line none">  863     const uint8_t *rhs_curr = rhs-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>;</div><div id="864" class="line none">  864     const uint8_t *rhs_end = rhs_curr + rhs-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="865" class="line none">  865 </div><div id="866" class="line none">  866     while (lhs_curr &lt; lhs_end &amp;&amp; rhs_curr &lt; rhs_end) {</div><div id="867" class="line none">  867         uint8_t lhc = lookup_table[*lhs_curr];</div><div id="868" class="line none">  868         uint8_t rhc = lookup_table[*rhs_curr];</div><div id="869" class="line none">  869 </div><div id="870" class="line none">  870         AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(lhs));</div><div id="871" class="line none">  871         AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(rhs));</div><div id="872" class="line none">  872         if (lhc &lt; rhc) {</div><div id="873" class="line none">  873             return -1;</div><div id="874" class="line none">  874         }</div><div id="875" class="line none">  875 </div><div id="876" class="line none">  876         if (lhc &gt; rhc) {</div><div id="877" class="line none">  877             return 1;</div><div id="878" class="line none">  878         }</div><div id="879" class="line none">  879 </div><div id="880" class="line none">  880         lhs_curr++;</div><div id="881" class="line none">  881         rhs_curr++;</div><div id="882" class="line none">  882     }</div><div id="883" class="line none">  883 </div><div id="884" class="line none">  884     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(lhs));</div><div id="885" class="line none">  885     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(rhs));</div><div id="886" class="line none">  886     if (lhs_curr &lt; lhs_end) {</div><div id="887" class="line none">  887         return 1;</div><div id="888" class="line none">  888     }</div><div id="889" class="line none">  889 </div><div id="890" class="line none">  890     if (rhs_curr &lt; rhs_end) {</div><div id="891" class="line none">  891         return -1;</div><div id="892" class="line none">  892     }</div><div id="893" class="line none">  893 </div><div id="894" class="line none">  894     return 0;</div><div id="895" class="line none">  895 }</div><div id="896" class="line none">  896 </div><div id="897" class="line none">  897 /**</div><div id="898" class="line none">  898  * For creating a byte buffer from a null-terminated string literal.</div><div id="899" class="line none">  899  */</div><div id="900" class="line none">  900 struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> <a href="byte_buf.c.html#900">aws_byte_buf_from_c_str</a>(const char *c_str) {</div><div id="901" class="line hit">  901     struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> buf;</div><div id="902" class="line both">  902     buf.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = (!c_str) ? 0 : strlen(c_str);</div><div id="903" class="line hit">  903     buf.<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> = buf.<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="904" class="line hit">  904     buf.<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> = (buf.<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> == 0) ? NULL : (uint8_t *)c_str;</div><div id="905" class="line hit">  905     buf.<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a> = NULL;</div><div id="906" class="line hit">  906     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(&amp;buf));</div><div id="907" class="line hit">  907     return buf;</div><div id="908" class="line hit">  908 }</div><div id="909" class="line none">  909 </div><div id="910" class="line none">  910 struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> <a href="byte_buf.c.html#910">aws_byte_buf_from_array</a>(const void *<a href="../include/aws/common/string.h.html#45">bytes</a>, size_t <a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="911" class="line hit">  911     AWS_PRECONDITION(AWS_MEM_IS_WRITABLE(<a href="../include/aws/common/string.h.html#45">bytes</a>, <a href="../include/aws/common/byte_buf.h.html#27">len</a>), "Input array [bytes] must be writable up to [len] bytes.");</div><div id="912" class="line hit">  912     struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> buf;</div><div id="913" class="line hit">  913     buf.<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> = (<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0) ? (uint8_t *)<a href="../include/aws/common/string.h.html#45">bytes</a> : NULL;</div><div id="914" class="line hit">  914     buf.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="915" class="line hit">  915     buf.<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> = <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="916" class="line hit">  916     buf.<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a> = NULL;</div><div id="917" class="line hit">  917     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(&amp;buf));</div><div id="918" class="line hit">  918     return buf;</div><div id="919" class="line hit">  919 }</div><div id="920" class="line none">  920 </div><div id="921" class="line none">  921 struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> <a href="byte_buf.c.html#921">aws_byte_buf_from_empty_array</a>(const void *<a href="../include/aws/common/string.h.html#45">bytes</a>, size_t <a href="../include/aws/common/byte_buf.h.html#29">capacity</a>) {</div><div id="922" class="line none">  922     AWS_PRECONDITION(</div><div id="923" class="line none">  923         AWS_MEM_IS_WRITABLE(<a href="../include/aws/common/string.h.html#45">bytes</a>, <a href="../include/aws/common/byte_buf.h.html#29">capacity</a>), "Input array [bytes] must be writable up to [capacity] bytes.");</div><div id="924" class="line none">  924     struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> buf;</div><div id="925" class="line none">  925     buf.<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> = (<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> &gt; 0) ? (uint8_t *)<a href="../include/aws/common/string.h.html#45">bytes</a> : NULL;</div><div id="926" class="line none">  926     buf.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = 0;</div><div id="927" class="line none">  927     buf.<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> = <a href="../include/aws/common/byte_buf.h.html#29">capacity</a>;</div><div id="928" class="line none">  928     buf.<a href="../include/aws/common/ring_buffer.h.html#19">allocator</a> = NULL;</div><div id="929" class="line none">  929     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(&amp;buf));</div><div id="930" class="line none">  930     return buf;</div><div id="931" class="line none">  931 }</div><div id="932" class="line none">  932 </div><div id="933" class="line none">  933 struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> <a href="byte_buf.c.html#933">aws_byte_cursor_from_buf</a>(const struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const buf) {</div><div id="934" class="line none">  934     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="935" class="line none">  935     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> cur;</div><div id="936" class="line none">  936     cur.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>;</div><div id="937" class="line none">  937     cur.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="938" class="line none">  938     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(&amp;cur));</div><div id="939" class="line none">  939     return cur;</div><div id="940" class="line none">  940 }</div><div id="941" class="line none">  941 </div><div id="942" class="line none">  942 struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> <a href="byte_buf.c.html#942">aws_byte_cursor_from_c_str</a>(const char *c_str) {</div><div id="943" class="line none">  943     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> cur;</div><div id="944" class="line none">  944     cur.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = (uint8_t *)c_str;</div><div id="945" class="line none">  945     cur.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = (cur.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>) ? strlen(c_str) : 0;</div><div id="946" class="line none">  946     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(&amp;cur));</div><div id="947" class="line none">  947     return cur;</div><div id="948" class="line none">  948 }</div><div id="949" class="line none">  949 </div><div id="950" class="line none">  950 struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> <a href="byte_buf.c.html#950">aws_byte_cursor_from_array</a>(const void *const <a href="../include/aws/common/string.h.html#45">bytes</a>, const size_t <a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="951" class="line none">  951     AWS_PRECONDITION(<a href="../include/aws/common/byte_buf.h.html#27">len</a> == 0 || AWS_MEM_IS_READABLE(<a href="../include/aws/common/string.h.html#45">bytes</a>, <a href="../include/aws/common/byte_buf.h.html#27">len</a>), "Input array [bytes] must be readable up to [len].");</div><div id="952" class="line none">  952     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> cur;</div><div id="953" class="line none">  953     cur.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = (uint8_t *)<a href="../include/aws/common/string.h.html#45">bytes</a>;</div><div id="954" class="line none">  954     cur.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="955" class="line none">  955     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(&amp;cur));</div><div id="956" class="line none">  956     return cur;</div><div id="957" class="line none">  957 }</div><div id="958" class="line none">  958 </div><div id="959" class="line none">  959 #ifdef CBMC</div><div id="960" class="line none">  960 #    pragma CPROVER check push</div><div id="961" class="line none">  961 #    pragma CPROVER check disable "unsigned-overflow"</div><div id="962" class="line none">  962 #endif</div><div id="963" class="line none">  963 /**</div><div id="964" class="line none">  964  * If index &gt;= bound, bound &gt; (SIZE_MAX / 2), or index &gt; (SIZE_MAX / 2), returns</div><div id="965" class="line none">  965  * 0. Otherwise, returns UINTPTR_MAX.  This function is designed to return the correct</div><div id="966" class="line none">  966  * value even under CPU speculation conditions, and is intended to be used for</div><div id="967" class="line none">  967  * SPECTRE mitigation purposes.</div><div id="968" class="line none">  968  */</div><div id="969" class="line none">  969 size_t <a href="byte_buf.c.html#969">aws_nospec_mask</a>(size_t <a href="../verification/cbmc/include/proof_helpers/utils.h.html#22">index</a>, size_t bound) {</div><div id="970" class="line none">  970     /*</div><div id="971" class="line none">  971      * SPECTRE mitigation - we compute a mask that will be zero if len &lt; 0</div><div id="972" class="line none">  972      * or len &gt;= buf-&gt;len, and all-ones otherwise, and AND it into the index.</div><div id="973" class="line none">  973      * It is critical that we avoid any branches in this logic.</div><div id="974" class="line none">  974      */</div><div id="975" class="line none">  975 </div><div id="976" class="line none">  976     /*</div><div id="977" class="line none">  977      * Hide the index value from the optimizer. This helps ensure that all this</div><div id="978" class="line none">  978      * logic doesn't get eliminated.</div><div id="979" class="line none">  979      */</div><div id="980" class="line none">  980 #if defined(__GNUC__) || defined(__clang__)</div><div id="981" class="line none">  981     __asm__ __volatile__("" : "+r"(<a href="../verification/cbmc/include/proof_helpers/utils.h.html#22">index</a>));</div><div id="982" class="line none">  982 #endif</div><div id="983" class="line none">  983 #if defined(_MSVC_LANG)</div><div id="984" class="line none">  984     /*</div><div id="985" class="line none">  985      * MSVC doesn't have a good way for us to blind the optimizer, and doesn't</div><div id="986" class="line none">  986      * even have inline asm on x64. Some experimentation indicates that this</div><div id="987" class="line none">  987      * hack seems to confuse it sufficiently for our needs.</div><div id="988" class="line none">  988      */</div><div id="989" class="line none">  989     *((volatile uint8_t *)&amp;<a href="../verification/cbmc/include/proof_helpers/utils.h.html#22">index</a>) += 0;</div><div id="990" class="line none">  990 #endif</div><div id="991" class="line none">  991 </div><div id="992" class="line none">  992     /*</div><div id="993" class="line none">  993      * If len &gt; (SIZE_MAX / 2), then we can end up with len - buf-&gt;len being</div><div id="994" class="line none">  994      * positive simply because the sign bit got inverted away. So we also check</div><div id="995" class="line none">  995      * that the sign bit isn't set from the start.</div><div id="996" class="line none">  996      *</div><div id="997" class="line none">  997      * We also check that bound &lt;= (SIZE_MAX / 2) to catch cases where the</div><div id="998" class="line none">  998      * buffer is _already_ out of bounds.</div><div id="999" class="line none">  999      */</div><div id="1000" class="line none"> 1000     size_t negative_mask = <a href="../verification/cbmc/include/proof_helpers/utils.h.html#22">index</a> | bound;</div><div id="1001" class="line none"> 1001     size_t toobig_mask = bound - <a href="../verification/cbmc/include/proof_helpers/utils.h.html#22">index</a> - (uintptr_t)1;</div><div id="1002" class="line none"> 1002     size_t combined_mask = negative_mask | toobig_mask;</div><div id="1003" class="line none"> 1003 </div><div id="1004" class="line none"> 1004     /*</div><div id="1005" class="line none"> 1005      * combined_mask needs to have its sign bit OFF for us to be in range.</div><div id="1006" class="line none"> 1006      * We'd like to expand this to a mask we can AND into our index, so flip</div><div id="1007" class="line none"> 1007      * that bit (and everything else), shift it over so it's the only bit in the</div><div id="1008" class="line none"> 1008      * ones position, and multiply across the entire register.</div><div id="1009" class="line none"> 1009      *</div><div id="1010" class="line none"> 1010      * First, extract the (inverse) top bit and move it to the lowest bit.</div><div id="1011" class="line none"> 1011      * Because there's no standard SIZE_BIT in C99, we'll divide by a mask with</div><div id="1012" class="line none"> 1012      * just the top bit set instead.</div><div id="1013" class="line none"> 1013      */</div><div id="1014" class="line none"> 1014 </div><div id="1015" class="line none"> 1015     combined_mask = (~combined_mask) / (SIZE_MAX - (SIZE_MAX &gt;&gt; 1));</div><div id="1016" class="line none"> 1016 </div><div id="1017" class="line none"> 1017     /*</div><div id="1018" class="line none"> 1018      * Now multiply it to replicate it across all bits.</div><div id="1019" class="line none"> 1019      *</div><div id="1020" class="line none"> 1020      * Note that GCC is smart enough to optimize the divide-and-multiply into</div><div id="1021" class="line none"> 1021      * an arithmetic right shift operation on x86.</div><div id="1022" class="line none"> 1022      */</div><div id="1023" class="line none"> 1023     combined_mask = combined_mask * UINTPTR_MAX;</div><div id="1024" class="line none"> 1024 </div><div id="1025" class="line none"> 1025     return combined_mask;</div><div id="1026" class="line none"> 1026 }</div><div id="1027" class="line none"> 1027 #ifdef CBMC</div><div id="1028" class="line none"> 1028 #    pragma CPROVER check pop</div><div id="1029" class="line none"> 1029 #endif</div><div id="1030" class="line none"> 1030 </div><div id="1031" class="line none"> 1031 /**</div><div id="1032" class="line none"> 1032  * Tests if the given aws_byte_cursor has at least len bytes remaining. If so,</div><div id="1033" class="line none"> 1033  * *buf is advanced by len bytes (incrementing -&gt;ptr and decrementing -&gt;len),</div><div id="1034" class="line none"> 1034  * and an aws_byte_cursor referring to the first len bytes of the original *buf</div><div id="1035" class="line none"> 1035  * is returned. Otherwise, an aws_byte_cursor with -&gt;ptr = NULL, -&gt;len = 0 is</div><div id="1036" class="line none"> 1036  * returned.</div><div id="1037" class="line none"> 1037  *</div><div id="1038" class="line none"> 1038  * Note that if len is above (SIZE_MAX / 2), this function will also treat it as</div><div id="1039" class="line none"> 1039  * a buffer overflow, and return NULL without changing *buf.</div><div id="1040" class="line none"> 1040  */</div><div id="1041" class="line none"> 1041 struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> <a href="byte_buf.c.html#1041">aws_byte_cursor_advance</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const cursor, const size_t <a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="1042" class="line none"> 1042     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cursor));</div><div id="1043" class="line none"> 1043     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> rv;</div><div id="1044" class="line none"> 1044     if (cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; (SIZE_MAX &gt;&gt; 1) || <a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; (SIZE_MAX &gt;&gt; 1) || <a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="1045" class="line none"> 1045         rv.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = NULL;</div><div id="1046" class="line none"> 1046         rv.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = 0;</div><div id="1047" class="line none"> 1047     } else {</div><div id="1048" class="line none"> 1048         rv.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>;</div><div id="1049" class="line none"> 1049         rv.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="1050" class="line none"> 1050 </div><div id="1051" class="line none"> 1051         cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> += <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="1052" class="line none"> 1052         cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> -= <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="1053" class="line none"> 1053     }</div><div id="1054" class="line none"> 1054     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cursor));</div><div id="1055" class="line none"> 1055     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(&amp;rv));</div><div id="1056" class="line none"> 1056     return rv;</div><div id="1057" class="line none"> 1057 }</div><div id="1058" class="line none"> 1058 </div><div id="1059" class="line none"> 1059 /**</div><div id="1060" class="line none"> 1060  * Behaves identically to aws_byte_cursor_advance, but avoids speculative</div><div id="1061" class="line none"> 1061  * execution potentially reading out-of-bounds pointers (by returning an</div><div id="1062" class="line none"> 1062  * empty ptr in such speculated paths).</div><div id="1063" class="line none"> 1063  *</div><div id="1064" class="line none"> 1064  * This should generally be done when using an untrusted or</div><div id="1065" class="line none"> 1065  * data-dependent value for 'len', to avoid speculating into a path where</div><div id="1066" class="line none"> 1066  * cursor-&gt;ptr points outside the true ptr length.</div><div id="1067" class="line none"> 1067  */</div><div id="1068" class="line none"> 1068 </div><div id="1069" class="line none"> 1069 struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> <a href="byte_buf.c.html#1069">aws_byte_cursor_advance_nospec</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const cursor, size_t <a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="1070" class="line none"> 1070     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cursor));</div><div id="1071" class="line none"> 1071 </div><div id="1072" class="line none"> 1072     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> rv;</div><div id="1073" class="line none"> 1073 </div><div id="1074" class="line none"> 1074     if (<a href="../include/aws/common/byte_buf.h.html#27">len</a> &lt;= cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &amp;&amp; <a href="../include/aws/common/byte_buf.h.html#27">len</a> &lt;= (SIZE_MAX &gt;&gt; 1) &amp;&amp; cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &lt;= (SIZE_MAX &gt;&gt; 1)) {</div><div id="1075" class="line none"> 1075         /*</div><div id="1076" class="line none"> 1076          * If we're speculating past a failed bounds check, null out the pointer. This ensures</div><div id="1077" class="line none"> 1077          * that we don't try to read past the end of the buffer and leak information about other</div><div id="1078" class="line none"> 1078          * memory through timing side-channels.</div><div id="1079" class="line none"> 1079          */</div><div id="1080" class="line none"> 1080         uintptr_t <a href="../include/aws/common/private/hash_table_impl.h.html#38">mask</a> = <a href="byte_buf.c.html#969">aws_nospec_mask</a>(<a href="../include/aws/common/byte_buf.h.html#27">len</a>, cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> + 1);</div><div id="1081" class="line none"> 1081 </div><div id="1082" class="line none"> 1082         /* Make sure we don't speculate-underflow len either */</div><div id="1083" class="line none"> 1083         <a href="../include/aws/common/byte_buf.h.html#27">len</a> = <a href="../include/aws/common/byte_buf.h.html#27">len</a> &amp; <a href="../include/aws/common/private/hash_table_impl.h.html#38">mask</a>;</div><div id="1084" class="line none"> 1084         cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = (uint8_t *)((uintptr_t)cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> &amp; <a href="../include/aws/common/private/hash_table_impl.h.html#38">mask</a>);</div><div id="1085" class="line none"> 1085         /* Make sure subsequent nospec accesses don't advance ptr past NULL */</div><div id="1086" class="line none"> 1086         cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &amp; <a href="../include/aws/common/private/hash_table_impl.h.html#38">mask</a>;</div><div id="1087" class="line none"> 1087 </div><div id="1088" class="line none"> 1088         rv.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>;</div><div id="1089" class="line none"> 1089         /* Make sure anything acting upon the returned cursor _also_ doesn't advance past NULL */</div><div id="1090" class="line none"> 1090         rv.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = <a href="../include/aws/common/byte_buf.h.html#27">len</a> &amp; <a href="../include/aws/common/private/hash_table_impl.h.html#38">mask</a>;</div><div id="1091" class="line none"> 1091 </div><div id="1092" class="line none"> 1092         cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> += <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="1093" class="line none"> 1093         cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> -= <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="1094" class="line none"> 1094     } else {</div><div id="1095" class="line none"> 1095         rv.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = NULL;</div><div id="1096" class="line none"> 1096         rv.<a href="../include/aws/common/byte_buf.h.html#27">len</a> = 0;</div><div id="1097" class="line none"> 1097     }</div><div id="1098" class="line none"> 1098 </div><div id="1099" class="line none"> 1099     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cursor));</div><div id="1100" class="line none"> 1100     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(&amp;rv));</div><div id="1101" class="line none"> 1101     return rv;</div><div id="1102" class="line none"> 1102 }</div><div id="1103" class="line none"> 1103 </div><div id="1104" class="line none"> 1104 /**</div><div id="1105" class="line none"> 1105  * Reads specified length of data from byte cursor and copies it to the</div><div id="1106" class="line none"> 1106  * destination array.</div><div id="1107" class="line none"> 1107  *</div><div id="1108" class="line none"> 1108  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="1109" class="line none"> 1109  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1110" class="line none"> 1110  * cursor unchanged.</div><div id="1111" class="line none"> 1111  */</div><div id="1112" class="line none"> 1112 bool <a href="byte_buf.c.html#1112">aws_byte_cursor_read</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT cur, void *AWS_RESTRICT dest, const size_t <a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="1113" class="line none"> 1113     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1114" class="line none"> 1114     AWS_PRECONDITION(AWS_MEM_IS_WRITABLE(dest, <a href="../include/aws/common/byte_buf.h.html#27">len</a>));</div><div id="1115" class="line none"> 1115     if (<a href="../include/aws/common/byte_buf.h.html#27">len</a> == 0)</div><div id="1116" class="line none"> 1116         return true;</div><div id="1117" class="line none"> 1117 </div><div id="1118" class="line none"> 1118     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> slice = <a href="byte_buf.c.html#1069">aws_byte_cursor_advance_nospec</a>(cur, <a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="1119" class="line none"> 1119 </div><div id="1120" class="line none"> 1120     if (slice.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>) {</div><div id="1121" class="line none"> 1121         memcpy(dest, slice.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, <a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="1122" class="line none"> 1122         AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1123" class="line none"> 1123         AWS_POSTCONDITION(AWS_MEM_IS_READABLE(dest, <a href="../include/aws/common/byte_buf.h.html#27">len</a>));</div><div id="1124" class="line none"> 1124         return true;</div><div id="1125" class="line none"> 1125     }</div><div id="1126" class="line none"> 1126     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1127" class="line none"> 1127     return false;</div><div id="1128" class="line none"> 1128 }</div><div id="1129" class="line none"> 1129 </div><div id="1130" class="line none"> 1130 /**</div><div id="1131" class="line none"> 1131  * Reads as many bytes from cursor as size of buffer, and copies them to buffer.</div><div id="1132" class="line none"> 1132  *</div><div id="1133" class="line none"> 1133  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="1134" class="line none"> 1134  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1135" class="line none"> 1135  * cursor unchanged.</div><div id="1136" class="line none"> 1136  */</div><div id="1137" class="line none"> 1137 bool <a href="byte_buf.c.html#1137">aws_byte_cursor_read_and_fill_buffer</a>(</div><div id="1138" class="line none"> 1138     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT cur,</div><div id="1139" class="line none"> 1139     struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT dest) {</div><div id="1140" class="line none"> 1140     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1141" class="line none"> 1141     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(dest));</div><div id="1142" class="line none"> 1142     if (<a href="byte_buf.c.html#1112">aws_byte_cursor_read</a>(cur, dest-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, dest-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>)) {</div><div id="1143" class="line none"> 1143         dest-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = dest-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>;</div><div id="1144" class="line none"> 1144         AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1145" class="line none"> 1145         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(dest));</div><div id="1146" class="line none"> 1146         return true;</div><div id="1147" class="line none"> 1147     }</div><div id="1148" class="line none"> 1148     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1149" class="line none"> 1149     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(dest));</div><div id="1150" class="line none"> 1150     return false;</div><div id="1151" class="line none"> 1151 }</div><div id="1152" class="line none"> 1152 </div><div id="1153" class="line none"> 1153 /**</div><div id="1154" class="line none"> 1154  * Reads a single byte from cursor, placing it in *var.</div><div id="1155" class="line none"> 1155  *</div><div id="1156" class="line none"> 1156  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="1157" class="line none"> 1157  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1158" class="line none"> 1158  * cursor unchanged.</div><div id="1159" class="line none"> 1159  */</div><div id="1160" class="line none"> 1160 bool <a href="byte_buf.c.html#1160">aws_byte_cursor_read_u8</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT cur, uint8_t *AWS_RESTRICT var) {</div><div id="1161" class="line none"> 1161     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1162" class="line none"> 1162     AWS_PRECONDITION(AWS_MEM_IS_WRITABLE(var, 1));</div><div id="1163" class="line none"> 1163     bool rv = <a href="byte_buf.c.html#1112">aws_byte_cursor_read</a>(cur, var, 1);</div><div id="1164" class="line none"> 1164     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1165" class="line none"> 1165     return rv;</div><div id="1166" class="line none"> 1166 }</div><div id="1167" class="line none"> 1167 </div><div id="1168" class="line none"> 1168 /**</div><div id="1169" class="line none"> 1169  * Reads a 16-bit value in network byte order from cur, and places it in host</div><div id="1170" class="line none"> 1170  * byte order into var.</div><div id="1171" class="line none"> 1171  *</div><div id="1172" class="line none"> 1172  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="1173" class="line none"> 1173  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1174" class="line none"> 1174  * cursor unchanged.</div><div id="1175" class="line none"> 1175  */</div><div id="1176" class="line none"> 1176 bool <a href="byte_buf.c.html#1176">aws_byte_cursor_read_be16</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *cur, uint16_t *var) {</div><div id="1177" class="line none"> 1177     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1178" class="line none"> 1178     AWS_PRECONDITION(AWS_OBJECT_PTR_IS_WRITABLE(var));</div><div id="1179" class="line none"> 1179     bool rv = <a href="byte_buf.c.html#1112">aws_byte_cursor_read</a>(cur, var, 2);</div><div id="1180" class="line none"> 1180 </div><div id="1181" class="line none"> 1181     if (AWS_LIKELY(rv)) {</div><div id="1182" class="line none"> 1182         *var = <a href="../include/aws/common/byte_order.inl.html#154">aws_ntoh16</a>(*var);</div><div id="1183" class="line none"> 1183     }</div><div id="1184" class="line none"> 1184 </div><div id="1185" class="line none"> 1185     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1186" class="line none"> 1186     return rv;</div><div id="1187" class="line none"> 1187 }</div><div id="1188" class="line none"> 1188 </div><div id="1189" class="line none"> 1189 /**</div><div id="1190" class="line none"> 1190  * Reads an unsigned 24-bit value (3 bytes) in network byte order from cur,</div><div id="1191" class="line none"> 1191  * and places it in host byte order into 32-bit var.</div><div id="1192" class="line none"> 1192  * Ex: if cur's next 3 bytes are {0xAA, 0xBB, 0xCC}, then var becomes 0x00AABBCC.</div><div id="1193" class="line none"> 1193  *</div><div id="1194" class="line none"> 1194  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="1195" class="line none"> 1195  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1196" class="line none"> 1196  * cursor unchanged.</div><div id="1197" class="line none"> 1197  */</div><div id="1198" class="line none"> 1198 bool <a href="byte_buf.c.html#1198">aws_byte_cursor_read_be24</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *cur, uint32_t *var) {</div><div id="1199" class="line none"> 1199     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1200" class="line none"> 1200     AWS_PRECONDITION(AWS_OBJECT_PTR_IS_WRITABLE(var));</div><div id="1201" class="line none"> 1201 </div><div id="1202" class="line none"> 1202     uint8_t *var_bytes = (void *)var;</div><div id="1203" class="line none"> 1203 </div><div id="1204" class="line none"> 1204     /* read into "lower" 3 bytes */</div><div id="1205" class="line none"> 1205     bool rv = <a href="byte_buf.c.html#1112">aws_byte_cursor_read</a>(cur, &amp;var_bytes[1], 3);</div><div id="1206" class="line none"> 1206 </div><div id="1207" class="line none"> 1207     if (AWS_LIKELY(rv)) {</div><div id="1208" class="line none"> 1208         /* zero out "highest" 4th byte*/</div><div id="1209" class="line none"> 1209         var_bytes[0] = 0;</div><div id="1210" class="line none"> 1210 </div><div id="1211" class="line none"> 1211         *var = <a href="../include/aws/common/byte_order.inl.html#118">aws_ntoh32</a>(*var);</div><div id="1212" class="line none"> 1212     }</div><div id="1213" class="line none"> 1213 </div><div id="1214" class="line none"> 1214     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1215" class="line none"> 1215     return rv;</div><div id="1216" class="line none"> 1216 }</div><div id="1217" class="line none"> 1217 </div><div id="1218" class="line none"> 1218 /**</div><div id="1219" class="line none"> 1219  * Reads a 32-bit value in network byte order from cur, and places it in host</div><div id="1220" class="line none"> 1220  * byte order into var.</div><div id="1221" class="line none"> 1221  *</div><div id="1222" class="line none"> 1222  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="1223" class="line none"> 1223  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1224" class="line none"> 1224  * cursor unchanged.</div><div id="1225" class="line none"> 1225  */</div><div id="1226" class="line none"> 1226 bool <a href="byte_buf.c.html#1226">aws_byte_cursor_read_be32</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *cur, uint32_t *var) {</div><div id="1227" class="line none"> 1227     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1228" class="line none"> 1228     AWS_PRECONDITION(AWS_OBJECT_PTR_IS_WRITABLE(var));</div><div id="1229" class="line none"> 1229     bool rv = <a href="byte_buf.c.html#1112">aws_byte_cursor_read</a>(cur, var, 4);</div><div id="1230" class="line none"> 1230 </div><div id="1231" class="line none"> 1231     if (AWS_LIKELY(rv)) {</div><div id="1232" class="line none"> 1232         *var = <a href="../include/aws/common/byte_order.inl.html#118">aws_ntoh32</a>(*var);</div><div id="1233" class="line none"> 1233     }</div><div id="1234" class="line none"> 1234 </div><div id="1235" class="line none"> 1235     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1236" class="line none"> 1236     return rv;</div><div id="1237" class="line none"> 1237 }</div><div id="1238" class="line none"> 1238 </div><div id="1239" class="line none"> 1239 /**</div><div id="1240" class="line none"> 1240  * Reads a 32-bit value in network byte order from cur, and places it in host</div><div id="1241" class="line none"> 1241  * byte order into var.</div><div id="1242" class="line none"> 1242  *</div><div id="1243" class="line none"> 1243  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="1244" class="line none"> 1244  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1245" class="line none"> 1245  * cursor unchanged.</div><div id="1246" class="line none"> 1246  */</div><div id="1247" class="line none"> 1247 bool <a href="byte_buf.c.html#1247">aws_byte_cursor_read_float_be32</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *cur, float *var) {</div><div id="1248" class="line none"> 1248     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1249" class="line none"> 1249     AWS_PRECONDITION(AWS_OBJECT_PTR_IS_WRITABLE(var));</div><div id="1250" class="line none"> 1250     bool rv = <a href="byte_buf.c.html#1112">aws_byte_cursor_read</a>(cur, var, sizeof(float));</div><div id="1251" class="line none"> 1251 </div><div id="1252" class="line none"> 1252     if (AWS_LIKELY(rv)) {</div><div id="1253" class="line none"> 1253         *var = <a href="../include/aws/common/byte_order.inl.html#129">aws_ntohf32</a>(*var);</div><div id="1254" class="line none"> 1254     }</div><div id="1255" class="line none"> 1255 </div><div id="1256" class="line none"> 1256     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1257" class="line none"> 1257     return rv;</div><div id="1258" class="line none"> 1258 }</div><div id="1259" class="line none"> 1259 </div><div id="1260" class="line none"> 1260 /**</div><div id="1261" class="line none"> 1261  * Reads a 64-bit value in network byte order from cur, and places it in host</div><div id="1262" class="line none"> 1262  * byte order into var.</div><div id="1263" class="line none"> 1263  *</div><div id="1264" class="line none"> 1264  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="1265" class="line none"> 1265  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1266" class="line none"> 1266  * cursor unchanged.</div><div id="1267" class="line none"> 1267  */</div><div id="1268" class="line none"> 1268 bool <a href="byte_buf.c.html#1268">aws_byte_cursor_read_float_be64</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *cur, double *var) {</div><div id="1269" class="line none"> 1269     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1270" class="line none"> 1270     AWS_PRECONDITION(AWS_OBJECT_PTR_IS_WRITABLE(var));</div><div id="1271" class="line none"> 1271     bool rv = <a href="byte_buf.c.html#1112">aws_byte_cursor_read</a>(cur, var, sizeof(double));</div><div id="1272" class="line none"> 1272 </div><div id="1273" class="line none"> 1273     if (AWS_LIKELY(rv)) {</div><div id="1274" class="line none"> 1274         *var = <a href="../include/aws/common/byte_order.inl.html#136">aws_ntohf64</a>(*var);</div><div id="1275" class="line none"> 1275     }</div><div id="1276" class="line none"> 1276 </div><div id="1277" class="line none"> 1277     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1278" class="line none"> 1278     return rv;</div><div id="1279" class="line none"> 1279 }</div><div id="1280" class="line none"> 1280 </div><div id="1281" class="line none"> 1281 /**</div><div id="1282" class="line none"> 1282  * Reads a 64-bit value in network byte order from cur, and places it in host</div><div id="1283" class="line none"> 1283  * byte order into var.</div><div id="1284" class="line none"> 1284  *</div><div id="1285" class="line none"> 1285  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="1286" class="line none"> 1286  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1287" class="line none"> 1287  * cursor unchanged.</div><div id="1288" class="line none"> 1288  */</div><div id="1289" class="line none"> 1289 bool <a href="byte_buf.c.html#1289">aws_byte_cursor_read_be64</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *cur, uint64_t *var) {</div><div id="1290" class="line none"> 1290     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1291" class="line none"> 1291     AWS_PRECONDITION(AWS_OBJECT_PTR_IS_WRITABLE(var));</div><div id="1292" class="line none"> 1292     bool rv = <a href="byte_buf.c.html#1112">aws_byte_cursor_read</a>(cur, var, sizeof(*var));</div><div id="1293" class="line none"> 1293 </div><div id="1294" class="line none"> 1294     if (AWS_LIKELY(rv)) {</div><div id="1295" class="line none"> 1295         *var = <a href="../include/aws/common/byte_order.inl.html#54">aws_ntoh64</a>(*var);</div><div id="1296" class="line none"> 1296     }</div><div id="1297" class="line none"> 1297 </div><div id="1298" class="line none"> 1298     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1299" class="line none"> 1299     return rv;</div><div id="1300" class="line none"> 1300 }</div><div id="1301" class="line none"> 1301 </div><div id="1302" class="line none"> 1302 /* Lookup from '0' -&gt; 0, 'f' -&gt; 0xf, 'F' -&gt; 0xF, etc</div><div id="1303" class="line none"> 1303  * invalid characters have value 255 */</div><div id="1304" class="line none"> 1304 /* clang-format off */</div><div id="1305" class="line none"> 1305 static const uint8_t <a href="byte_buf.c.html#1305">s_hex_to_num_table</a>[] = {</div><div id="1306" class="line none"> 1306     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div><div id="1307" class="line none"> 1307     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div><div id="1308" class="line none"> 1308     255, 255,</div><div id="1309" class="line none"> 1309     /* 0 - 9 */</div><div id="1310" class="line none"> 1310     0, 1, 2, 3, 4, 5, 6, 7, 8, 9,</div><div id="1311" class="line none"> 1311     255, 255, 255, 255, 255, 255, 255,</div><div id="1312" class="line none"> 1312     /* A - F */</div><div id="1313" class="line none"> 1313     0xA, 0xB, 0xC, 0xD, 0xE, 0xF,</div><div id="1314" class="line none"> 1314     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div><div id="1315" class="line none"> 1315     255, 255, 255,</div><div id="1316" class="line none"> 1316     /* a - f */</div><div id="1317" class="line none"> 1317     0xa, 0xb, 0xc, 0xd, 0xe, 0xf,</div><div id="1318" class="line none"> 1318     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div><div id="1319" class="line none"> 1319     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div><div id="1320" class="line none"> 1320     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div><div id="1321" class="line none"> 1321     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div><div id="1322" class="line none"> 1322     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div><div id="1323" class="line none"> 1323     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div><div id="1324" class="line none"> 1324     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</div><div id="1325" class="line none"> 1325 };</div><div id="1326" class="line none"> 1326 AWS_STATIC_ASSERT(AWS_ARRAY_SIZE(<a href="byte_buf.c.html#1305">s_hex_to_num_table</a>) == 256);</div><div id="1327" class="line none"> 1327 /* clang-format on */</div><div id="1328" class="line none"> 1328 </div><div id="1329" class="line none"> 1329 const uint8_t *<a href="byte_buf.c.html#1329">aws_lookup_table_hex_to_num_get</a>(void) {</div><div id="1330" class="line none"> 1330     return <a href="byte_buf.c.html#1305">s_hex_to_num_table</a>;</div><div id="1331" class="line none"> 1331 }</div><div id="1332" class="line none"> 1332 </div><div id="1333" class="line none"> 1333 bool <a href="byte_buf.c.html#1333">aws_byte_cursor_read_hex_u8</a>(struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *cur, uint8_t *var) {</div><div id="1334" class="line none"> 1334     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1335" class="line none"> 1335     AWS_PRECONDITION(AWS_OBJECT_PTR_IS_WRITABLE(var));</div><div id="1336" class="line none"> 1336 </div><div id="1337" class="line none"> 1337     bool success = false;</div><div id="1338" class="line none"> 1338     if (AWS_LIKELY(cur-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt;= 2)) {</div><div id="1339" class="line none"> 1339         const uint8_t hi = <a href="byte_buf.c.html#1305">s_hex_to_num_table</a>[cur-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>[0]];</div><div id="1340" class="line none"> 1340         const uint8_t lo = <a href="byte_buf.c.html#1305">s_hex_to_num_table</a>[cur-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>[1]];</div><div id="1341" class="line none"> 1341 </div><div id="1342" class="line none"> 1342         /* table maps invalid characters to 255 */</div><div id="1343" class="line none"> 1343         if (AWS_LIKELY(hi != 255 &amp;&amp; lo != 255)) {</div><div id="1344" class="line none"> 1344             *var = (hi &lt;&lt; 4) | lo;</div><div id="1345" class="line none"> 1345             cur-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> += 2;</div><div id="1346" class="line none"> 1346             cur-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> -= 2;</div><div id="1347" class="line none"> 1347             success = true;</div><div id="1348" class="line none"> 1348         }</div><div id="1349" class="line none"> 1349     }</div><div id="1350" class="line none"> 1350 </div><div id="1351" class="line none"> 1351     AWS_POSTCONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(cur));</div><div id="1352" class="line none"> 1352     return success;</div><div id="1353" class="line none"> 1353 }</div><div id="1354" class="line none"> 1354 </div><div id="1355" class="line none"> 1355 /**</div><div id="1356" class="line none"> 1356  * Appends a sub-buffer to the specified buffer.</div><div id="1357" class="line none"> 1357  *</div><div id="1358" class="line none"> 1358  * If the buffer has at least `len' bytes remaining (buffer-&gt;capacity - buffer-&gt;len &gt;= len),</div><div id="1359" class="line none"> 1359  * then buffer-&gt;len is incremented by len, and an aws_byte_buf is assigned to *output corresponding</div><div id="1360" class="line none"> 1360  * to the last len bytes of the input buffer. The aws_byte_buf at *output will have a null</div><div id="1361" class="line none"> 1361  * allocator, a zero initial length, and a capacity of 'len'. The function then returns true.</div><div id="1362" class="line none"> 1362  *</div><div id="1363" class="line none"> 1363  * If there is insufficient space, then this function nulls all fields in *output and returns</div><div id="1364" class="line none"> 1364  * false.</div><div id="1365" class="line none"> 1365  */</div><div id="1366" class="line none"> 1366 bool <a href="byte_buf.c.html#1366">aws_byte_buf_advance</a>(</div><div id="1367" class="line none"> 1367     struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const AWS_RESTRICT <a href="../include/aws/common/byte_buf.h.html#28">buffer</a>,</div><div id="1368" class="line none"> 1368     struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const AWS_RESTRICT output,</div><div id="1369" class="line none"> 1369     const size_t <a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="1370" class="line none"> 1370     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>));</div><div id="1371" class="line none"> 1371     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(output));</div><div id="1372" class="line none"> 1372     if (<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> - <a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt;= <a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="1373" class="line none"> 1373         *output = <a href="byte_buf.c.html#910">aws_byte_buf_from_array</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> + <a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, <a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="1374" class="line none"> 1374         <a href="../include/aws/common/byte_buf.h.html#28">buffer</a>-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> += <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="1375" class="line none"> 1375         output-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> = 0;</div><div id="1376" class="line none"> 1376         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>));</div><div id="1377" class="line none"> 1377         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(output));</div><div id="1378" class="line none"> 1378         return true;</div><div id="1379" class="line none"> 1379     } else {</div><div id="1380" class="line none"> 1380         AWS_ZERO_STRUCT(*output);</div><div id="1381" class="line none"> 1381         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>));</div><div id="1382" class="line none"> 1382         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(output));</div><div id="1383" class="line none"> 1383         return false;</div><div id="1384" class="line none"> 1384     }</div><div id="1385" class="line none"> 1385 }</div><div id="1386" class="line none"> 1386 </div><div id="1387" class="line none"> 1387 /**</div><div id="1388" class="line none"> 1388  * Write specified number of bytes from array to byte buffer.</div><div id="1389" class="line none"> 1389  *</div><div id="1390" class="line none"> 1390  * On success, returns true and updates the buffer length accordingly.</div><div id="1391" class="line none"> 1391  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="1392" class="line none"> 1392  * buffer unchanged.</div><div id="1393" class="line none"> 1393  */</div><div id="1394" class="line none"> 1394 bool <a href="byte_buf.c.html#1394">aws_byte_buf_write</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT buf, const uint8_t *AWS_RESTRICT src, size_t <a href="../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="1395" class="line none"> 1395     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1396" class="line none"> 1396     AWS_PRECONDITION(AWS_MEM_IS_READABLE(src, <a href="../include/aws/common/byte_buf.h.html#27">len</a>), "Input array [src] must be readable up to [len] bytes.");</div><div id="1397" class="line none"> 1397 </div><div id="1398" class="line none"> 1398     if (<a href="../include/aws/common/byte_buf.h.html#27">len</a> == 0) {</div><div id="1399" class="line none"> 1399         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1400" class="line none"> 1400         return true;</div><div id="1401" class="line none"> 1401     }</div><div id="1402" class="line none"> 1402 </div><div id="1403" class="line none"> 1403     if (buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; (SIZE_MAX &gt;&gt; 1) || <a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; (SIZE_MAX &gt;&gt; 1) || buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> + <a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; buf-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>) {</div><div id="1404" class="line none"> 1404         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1405" class="line none"> 1405         return false;</div><div id="1406" class="line none"> 1406     }</div><div id="1407" class="line none"> 1407 </div><div id="1408" class="line none"> 1408     memcpy(buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> + buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, src, <a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="1409" class="line none"> 1409     buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> += <a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="1410" class="line none"> 1410 </div><div id="1411" class="line none"> 1411     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1412" class="line none"> 1412     return true;</div><div id="1413" class="line none"> 1413 }</div><div id="1414" class="line none"> 1414 </div><div id="1415" class="line none"> 1415 /**</div><div id="1416" class="line none"> 1416  * Copies all bytes from buffer to buffer.</div><div id="1417" class="line none"> 1417  *</div><div id="1418" class="line none"> 1418  * On success, returns true and updates the buffer /length accordingly.</div><div id="1419" class="line none"> 1419  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="1420" class="line none"> 1420  * buffer unchanged.</div><div id="1421" class="line none"> 1421  */</div><div id="1422" class="line none"> 1422 bool <a href="byte_buf.c.html#1422">aws_byte_buf_write_from_whole_buffer</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT buf, struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> src) {</div><div id="1423" class="line none"> 1423     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1424" class="line none"> 1424     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(&amp;src));</div><div id="1425" class="line none"> 1425     return <a href="byte_buf.c.html#1394">aws_byte_buf_write</a>(buf, src.<a href="../include/aws/common/byte_buf.h.html#28">buffer</a>, src.<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="1426" class="line none"> 1426 }</div><div id="1427" class="line none"> 1427 </div><div id="1428" class="line none"> 1428 /**</div><div id="1429" class="line none"> 1429  * Copies all bytes from buffer to buffer.</div><div id="1430" class="line none"> 1430  *</div><div id="1431" class="line none"> 1431  * On success, returns true and updates the buffer /length accordingly.</div><div id="1432" class="line none"> 1432  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="1433" class="line none"> 1433  * buffer unchanged.</div><div id="1434" class="line none"> 1434  */</div><div id="1435" class="line none"> 1435 bool <a href="byte_buf.c.html#1435">aws_byte_buf_write_from_whole_cursor</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT buf, struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> src) {</div><div id="1436" class="line none"> 1436     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1437" class="line none"> 1437     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(&amp;src));</div><div id="1438" class="line none"> 1438     return <a href="byte_buf.c.html#1394">aws_byte_buf_write</a>(buf, src.<a href="../include/aws/common/byte_buf.h.html#41">ptr</a>, src.<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="1439" class="line none"> 1439 }</div><div id="1440" class="line none"> 1440 </div><div id="1441" class="line none"> 1441 struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> <a href="byte_buf.c.html#1441">aws_byte_buf_write_to_capacity</a>(</div><div id="1442" class="line none"> 1442     struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf,</div><div id="1443" class="line none"> 1443     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *advancing_cursor) {</div><div id="1444" class="line none"> 1444 </div><div id="1445" class="line none"> 1445     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1446" class="line none"> 1446     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(advancing_cursor));</div><div id="1447" class="line none"> 1447 </div><div id="1448" class="line none"> 1448     size_t available = buf-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a> - buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>;</div><div id="1449" class="line none"> 1449     size_t write_size = <a href="../include/aws/common/math.inl.html#259">aws_min_size</a>(available, advancing_cursor-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="1450" class="line none"> 1450     struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> write_cursor = <a href="byte_buf.c.html#1041">aws_byte_cursor_advance</a>(advancing_cursor, write_size);</div><div id="1451" class="line none"> 1451     <a href="byte_buf.c.html#1435">aws_byte_buf_write_from_whole_cursor</a>(buf, write_cursor);</div><div id="1452" class="line none"> 1452     return write_cursor;</div><div id="1453" class="line none"> 1453 }</div><div id="1454" class="line none"> 1454 </div><div id="1455" class="line none"> 1455 /**</div><div id="1456" class="line none"> 1456  * Copies one byte to buffer.</div><div id="1457" class="line none"> 1457  *</div><div id="1458" class="line none"> 1458  * On success, returns true and updates the cursor /length</div><div id="1459" class="line none"> 1459  accordingly.</div><div id="1460" class="line none"> 1460 </div><div id="1461" class="line none"> 1461  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1462" class="line none"> 1462  cursor unchanged.</div><div id="1463" class="line none"> 1463  */</div><div id="1464" class="line none"> 1464 bool <a href="byte_buf.c.html#1464">aws_byte_buf_write_u8</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT buf, uint8_t c) {</div><div id="1465" class="line none"> 1465     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1466" class="line none"> 1466     return <a href="byte_buf.c.html#1394">aws_byte_buf_write</a>(buf, &amp;c, 1);</div><div id="1467" class="line none"> 1467 }</div><div id="1468" class="line none"> 1468 </div><div id="1469" class="line none"> 1469 /**</div><div id="1470" class="line none"> 1470  * Writes one byte repeatedly to buffer (like memset)</div><div id="1471" class="line none"> 1471  *</div><div id="1472" class="line none"> 1472  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="1473" class="line none"> 1473  * buffer unchanged.</div><div id="1474" class="line none"> 1474  */</div><div id="1475" class="line none"> 1475 bool <a href="byte_buf.c.html#1475">aws_byte_buf_write_u8_n</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf, uint8_t c, size_t <a href="../include/aws/common/error.h.html#34">count</a>) {</div><div id="1476" class="line none"> 1476     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1477" class="line none"> 1477 </div><div id="1478" class="line none"> 1478     if (buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> &gt; (SIZE_MAX &gt;&gt; 1) || <a href="../include/aws/common/error.h.html#34">count</a> &gt; (SIZE_MAX &gt;&gt; 1) || buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> + <a href="../include/aws/common/error.h.html#34">count</a> &gt; buf-&gt;<a href="../include/aws/common/byte_buf.h.html#29">capacity</a>) {</div><div id="1479" class="line none"> 1479         AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1480" class="line none"> 1480         return false;</div><div id="1481" class="line none"> 1481     }</div><div id="1482" class="line none"> 1482 </div><div id="1483" class="line none"> 1483     memset(buf-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> + buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>, c, <a href="../include/aws/common/error.h.html#34">count</a>);</div><div id="1484" class="line none"> 1484     buf-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> += <a href="../include/aws/common/error.h.html#34">count</a>;</div><div id="1485" class="line none"> 1485 </div><div id="1486" class="line none"> 1486     AWS_POSTCONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1487" class="line none"> 1487     return true;</div><div id="1488" class="line none"> 1488 }</div><div id="1489" class="line none"> 1489 </div><div id="1490" class="line none"> 1490 /**</div><div id="1491" class="line none"> 1491  * Writes a 16-bit integer in network byte order (big endian) to buffer.</div><div id="1492" class="line none"> 1492  *</div><div id="1493" class="line none"> 1493  * On success, returns true and updates the cursor /length accordingly.</div><div id="1494" class="line none"> 1494  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1495" class="line none"> 1495  * cursor unchanged.</div><div id="1496" class="line none"> 1496  */</div><div id="1497" class="line none"> 1497 bool <a href="byte_buf.c.html#1497">aws_byte_buf_write_be16</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf, uint16_t x) {</div><div id="1498" class="line none"> 1498     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1499" class="line none"> 1499     x = <a href="../include/aws/common/byte_order.inl.html#143">aws_hton16</a>(x);</div><div id="1500" class="line none"> 1500     return <a href="byte_buf.c.html#1394">aws_byte_buf_write</a>(buf, (uint8_t *)&amp;x, 2);</div><div id="1501" class="line none"> 1501 }</div><div id="1502" class="line none"> 1502 </div><div id="1503" class="line none"> 1503 /**</div><div id="1504" class="line none"> 1504  * Writes low 24-bits (3 bytes) of an unsigned integer in network byte order (big endian) to buffer.</div><div id="1505" class="line none"> 1505  * Ex: If x is 0x00AABBCC then {0xAA, 0xBB, 0xCC} is written to buffer.</div><div id="1506" class="line none"> 1506  *</div><div id="1507" class="line none"> 1507  * On success, returns true and updates the buffer /length accordingly.</div><div id="1508" class="line none"> 1508  * If there is insufficient space in the buffer, or x's value cannot fit in 3 bytes,</div><div id="1509" class="line none"> 1509  * returns false, leaving the buffer unchanged.</div><div id="1510" class="line none"> 1510  */</div><div id="1511" class="line none"> 1511 bool <a href="byte_buf.c.html#1511">aws_byte_buf_write_be24</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf, uint32_t x) {</div><div id="1512" class="line none"> 1512     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1513" class="line none"> 1513 </div><div id="1514" class="line none"> 1514     if (x &gt; 0x00FFFFFF) {</div><div id="1515" class="line none"> 1515         return false;</div><div id="1516" class="line none"> 1516     }</div><div id="1517" class="line none"> 1517 </div><div id="1518" class="line none"> 1518     uint32_t be32 = <a href="../include/aws/common/byte_order.inl.html#61">aws_hton32</a>(x);</div><div id="1519" class="line none"> 1519     uint8_t *be32_bytes = (uint8_t *)&amp;be32;</div><div id="1520" class="line none"> 1520 </div><div id="1521" class="line none"> 1521     /* write "lower" 3 bytes */</div><div id="1522" class="line none"> 1522     return <a href="byte_buf.c.html#1394">aws_byte_buf_write</a>(buf, &amp;be32_bytes[1], 3);</div><div id="1523" class="line none"> 1523 }</div><div id="1524" class="line none"> 1524 </div><div id="1525" class="line none"> 1525 /**</div><div id="1526" class="line none"> 1526  * Writes a 32-bit integer in network byte order (big endian) to buffer.</div><div id="1527" class="line none"> 1527  *</div><div id="1528" class="line none"> 1528  * On success, returns true and updates the cursor /length accordingly.</div><div id="1529" class="line none"> 1529  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1530" class="line none"> 1530  * cursor unchanged.</div><div id="1531" class="line none"> 1531  */</div><div id="1532" class="line none"> 1532 bool <a href="byte_buf.c.html#1532">aws_byte_buf_write_be32</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf, uint32_t x) {</div><div id="1533" class="line none"> 1533     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1534" class="line none"> 1534     x = <a href="../include/aws/common/byte_order.inl.html#61">aws_hton32</a>(x);</div><div id="1535" class="line none"> 1535     return <a href="byte_buf.c.html#1394">aws_byte_buf_write</a>(buf, (uint8_t *)&amp;x, 4);</div><div id="1536" class="line none"> 1536 }</div><div id="1537" class="line none"> 1537 </div><div id="1538" class="line none"> 1538 /**</div><div id="1539" class="line none"> 1539  * Writes a 32-bit float in network byte order (big endian) to buffer.</div><div id="1540" class="line none"> 1540  *</div><div id="1541" class="line none"> 1541  * On success, returns true and updates the cursor /length accordingly.</div><div id="1542" class="line none"> 1542  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1543" class="line none"> 1543  * cursor unchanged.</div><div id="1544" class="line none"> 1544  */</div><div id="1545" class="line none"> 1545 bool <a href="byte_buf.c.html#1545">aws_byte_buf_write_float_be32</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf, float x) {</div><div id="1546" class="line none"> 1546     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1547" class="line none"> 1547     x = <a href="../include/aws/common/byte_order.inl.html#72">aws_htonf32</a>(x);</div><div id="1548" class="line none"> 1548     return <a href="byte_buf.c.html#1394">aws_byte_buf_write</a>(buf, (uint8_t *)&amp;x, 4);</div><div id="1549" class="line none"> 1549 }</div><div id="1550" class="line none"> 1550 </div><div id="1551" class="line none"> 1551 /**</div><div id="1552" class="line none"> 1552  * Writes a 64-bit integer in network byte order (big endian) to buffer.</div><div id="1553" class="line none"> 1553  *</div><div id="1554" class="line none"> 1554  * On success, returns true and updates the cursor /length accordingly.</div><div id="1555" class="line none"> 1555  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1556" class="line none"> 1556  * cursor unchanged.</div><div id="1557" class="line none"> 1557  */</div><div id="1558" class="line none"> 1558 bool <a href="byte_buf.c.html#1558">aws_byte_buf_write_be64</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf, uint64_t x) {</div><div id="1559" class="line none"> 1559     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1560" class="line none"> 1560     x = <a href="../include/aws/common/byte_order.inl.html#34">aws_hton64</a>(x);</div><div id="1561" class="line none"> 1561     return <a href="byte_buf.c.html#1394">aws_byte_buf_write</a>(buf, (uint8_t *)&amp;x, 8);</div><div id="1562" class="line none"> 1562 }</div><div id="1563" class="line none"> 1563 </div><div id="1564" class="line none"> 1564 /**</div><div id="1565" class="line none"> 1565  * Writes a 64-bit float in network byte order (big endian) to buffer.</div><div id="1566" class="line none"> 1566  *</div><div id="1567" class="line none"> 1567  * On success, returns true and updates the cursor /length accordingly.</div><div id="1568" class="line none"> 1568  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="1569" class="line none"> 1569  * cursor unchanged.</div><div id="1570" class="line none"> 1570  */</div><div id="1571" class="line none"> 1571 bool <a href="byte_buf.c.html#1571">aws_byte_buf_write_float_be64</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf, double x) {</div><div id="1572" class="line none"> 1572     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(buf));</div><div id="1573" class="line none"> 1573     x = <a href="../include/aws/common/byte_order.inl.html#93">aws_htonf64</a>(x);</div><div id="1574" class="line none"> 1574     return <a href="byte_buf.c.html#1394">aws_byte_buf_write</a>(buf, (uint8_t *)&amp;x, 8);</div><div id="1575" class="line none"> 1575 }</div><div id="1576" class="line none"> 1576 </div><div id="1577" class="line none"> 1577 int <a href="byte_buf.c.html#1577">aws_byte_buf_append_and_update</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *to, struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *from_and_update) {</div><div id="1578" class="line none"> 1578     AWS_PRECONDITION(<a href="byte_buf.c.html#58">aws_byte_buf_is_valid</a>(to));</div><div id="1579" class="line none"> 1579     AWS_PRECONDITION(<a href="byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(from_and_update));</div><div id="1580" class="line none"> 1580 </div><div id="1581" class="line none"> 1581     if (<a href="byte_buf.c.html#561">aws_byte_buf_append</a>(to, from_and_update)) {</div><div id="1582" class="line none"> 1582         return <a href="../include/aws/common/error.h.html#16">AWS_OP_ERR</a>;</div><div id="1583" class="line none"> 1583     }</div><div id="1584" class="line none"> 1584 </div><div id="1585" class="line none"> 1585     from_and_update-&gt;<a href="../include/aws/common/byte_buf.h.html#41">ptr</a> = to-&gt;<a href="../include/aws/common/byte_buf.h.html#28">buffer</a> + (to-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a> - from_and_update-&gt;<a href="../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="1586" class="line none"> 1586     return <a href="../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>;</div><div id="1587" class="line none"> 1587 }</div><div id="1588" class="line none"> 1588 </div><div id="1589" class="line none"> 1589 static struct <a href="../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> <a href="byte_buf.c.html#1589">s_null_terminator_cursor</a> = <a href="../include/aws/common/byte_buf.h.html#61">AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL</a>("\0");</div><div id="1590" class="line none"> 1590 int <a href="byte_buf.c.html#1590">aws_byte_buf_append_null_terminator</a>(struct <a href="../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *buf) {</div><div id="1591" class="line none"> 1591     return <a href="byte_buf.c.html#713">aws_byte_buf_append_dynamic</a>(buf, &amp;<a href="byte_buf.c.html#1589">s_null_terminator_cursor</a>);</div><div id="1592" class="line none"> 1592 }</div><div id="1593" class="line none"> 1593 </div><div id="1594" class="line none"> 1594 bool <a href="byte_buf.c.html#1594">aws_isalnum</a>(uint8_t ch) {</div><div id="1595" class="line none"> 1595     return (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || (ch &gt;= '0' &amp;&amp; ch &lt;= '9');</div><div id="1596" class="line none"> 1596 }</div><div id="1597" class="line none"> 1597 </div><div id="1598" class="line none"> 1598 bool <a href="byte_buf.c.html#1598">aws_isalpha</a>(uint8_t ch) {</div><div id="1599" class="line none"> 1599     return (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z');</div><div id="1600" class="line none"> 1600 }</div><div id="1601" class="line none"> 1601 </div><div id="1602" class="line none"> 1602 bool <a href="byte_buf.c.html#1602">aws_isdigit</a>(uint8_t ch) {</div><div id="1603" class="line none"> 1603     return (ch &gt;= '0' &amp;&amp; ch &lt;= '9');</div><div id="1604" class="line none"> 1604 }</div><div id="1605" class="line none"> 1605 </div><div id="1606" class="line none"> 1606 bool <a href="byte_buf.c.html#1606">aws_isxdigit</a>(uint8_t ch) {</div><div id="1607" class="line none"> 1607     return (ch &gt;= '0' &amp;&amp; ch &lt;= '9') || (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F');</div><div id="1608" class="line none"> 1608 }</div><div id="1609" class="line none"> 1609 </div><div id="1610" class="line none"> 1610 bool <a href="byte_buf.c.html#1610">aws_isspace</a>(uint8_t ch) {</div><div id="1611" class="line none"> 1611     switch (ch) {</div><div id="1612" class="line none"> 1612         case 0x20: /* ' ' - space */</div><div id="1613" class="line none"> 1613             return true;</div><div id="1614" class="line none"> 1614         case 0x09: /* '\t' - horizontal tab */</div><div id="1615" class="line none"> 1615             return true;</div><div id="1616" class="line none"> 1616         case 0x0A: /* '\n' - line feed */</div><div id="1617" class="line none"> 1617             return true;</div><div id="1618" class="line none"> 1618         case 0x0B: /* '\v' - vertical tab */</div><div id="1619" class="line none"> 1619             return true;</div><div id="1620" class="line none"> 1620         case 0x0C: /* '\f' - form feed */</div><div id="1621" class="line none"> 1621             return true;</div><div id="1622" class="line none"> 1622         case 0x0D: /* '\r' - carriage return */</div><div id="1623" class="line none"> 1623             return true;</div><div id="1624" class="line none"> 1624         default:</div><div id="1625" class="line none"> 1625             return false;</div><div id="1626" class="line none"> 1626     }</div><div id="1627" class="line none"> 1627 }</div>
</div>
</body>
</html>
