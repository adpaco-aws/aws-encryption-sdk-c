
<html>
<head>
<title>verification/cbmc/aws-c-common/include/aws/common/byte_buf.h</title>
<link rel="stylesheet" type="text/css" href="../../../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 #ifndef <a href="byte_buf.h.html#2">AWS_COMMON_BYTE_BUF_H</a></div><div id="2" class="line none">    2 #define <a href="byte_buf.h.html#2">AWS_COMMON_BYTE_BUF_H</a></div><div id="3" class="line none">    3 /**</div><div id="4" class="line none">    4  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.</div><div id="5" class="line none">    5  * SPDX-License-Identifier: Apache-2.0.</div><div id="6" class="line none">    6  */</div><div id="7" class="line none">    7 </div><div id="8" class="line none">    8 #include &lt;aws/common/array_list.h&gt;</div><div id="9" class="line none">    9 #include &lt;aws/common/byte_order.h&gt;</div><div id="10" class="line none">   10 #include &lt;aws/common/common.h&gt;</div><div id="11" class="line none">   11 </div><div id="12" class="line none">   12 #include &lt;string.h&gt;</div><div id="13" class="line none">   13 </div><div id="14" class="line none">   14 /**</div><div id="15" class="line none">   15  * Represents a length-delimited binary string or buffer. If byte buffer points</div><div id="16" class="line none">   16  * to constant memory or memory that should otherwise not be freed by this</div><div id="17" class="line none">   17  * struct, set allocator to NULL and free function will be a no-op.</div><div id="18" class="line none">   18  *</div><div id="19" class="line none">   19  * This structure used to define the output for all functions that write to a buffer.</div><div id="20" class="line none">   20  *</div><div id="21" class="line none">   21  * Note that this structure allocates memory at the buffer pointer only. The</div><div id="22" class="line none">   22  * struct itself does not get dynamically allocated and must be either</div><div id="23" class="line none">   23  * maintained or copied to avoid losing access to the memory.</div><div id="24" class="line none">   24  */</div><div id="25" class="line none">   25 struct <a href="byte_buf.h.html#25">aws_byte_buf</a> {</div><div id="26" class="line none">   26     /* do not reorder this, this struct lines up nicely with windows buffer structures--saving us allocations.*/</div><div id="27" class="line none">   27     size_t <a href="byte_buf.h.html#27">len</a>;</div><div id="28" class="line none">   28     uint8_t *<a href="byte_buf.h.html#28">buffer</a>;</div><div id="29" class="line none">   29     size_t <a href="byte_buf.h.html#29">capacity</a>;</div><div id="30" class="line none">   30     struct <a href="allocator.h.html#15">aws_allocator</a> *<a href="ring_buffer.h.html#19">allocator</a>;</div><div id="31" class="line none">   31 };</div><div id="32" class="line none">   32 </div><div id="33" class="line none">   33 /**</div><div id="34" class="line none">   34  * Represents a movable pointer within a larger binary string or buffer.</div><div id="35" class="line none">   35  *</div><div id="36" class="line none">   36  * This structure is used to define buffers for reading.</div><div id="37" class="line none">   37  */</div><div id="38" class="line none">   38 struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> {</div><div id="39" class="line none">   39     /* do not reorder this, this struct lines up nicely with windows buffer structures--saving us allocations */</div><div id="40" class="line none">   40     size_t <a href="byte_buf.h.html#27">len</a>;</div><div id="41" class="line none">   41     uint8_t *<a href="byte_buf.h.html#41">ptr</a>;</div><div id="42" class="line none">   42 };</div><div id="43" class="line none">   43 </div><div id="44" class="line none">   44 /**</div><div id="45" class="line none">   45  * Helper macro for passing aws_byte_cursor to the printf family of functions.</div><div id="46" class="line none">   46  * Intended for use with the PRInSTR format macro.</div><div id="47" class="line none">   47  * Ex: printf(PRInSTR "\n", AWS_BYTE_CURSOR_PRI(my_cursor));</div><div id="48" class="line none">   48  */</div><div id="49" class="line none">   49 #define <a href="byte_buf.h.html#49">AWS_BYTE_CURSOR_PRI</a>(C) ((int)(C).<a href="byte_buf.h.html#27">len</a> &lt; 0 ? 0 : (int)(C).<a href="byte_buf.h.html#27">len</a>), (const char *)(C).<a href="byte_buf.h.html#41">ptr</a></div><div id="50" class="line none">   50 </div><div id="51" class="line none">   51 /**</div><div id="52" class="line none">   52  * Helper macro for passing aws_byte_buf to the printf family of functions.</div><div id="53" class="line none">   53  * Intended for use with the PRInSTR format macro.</div><div id="54" class="line none">   54  * Ex: printf(PRInSTR "\n", AWS_BYTE_BUF_PRI(my_buf));</div><div id="55" class="line none">   55  */</div><div id="56" class="line none">   56 #define <a href="byte_buf.h.html#56">AWS_BYTE_BUF_PRI</a>(B) ((int)(B).<a href="byte_buf.h.html#27">len</a> &lt; 0 ? 0 : (int)(B).<a href="byte_buf.h.html#27">len</a>), (const char *)(B).<a href="byte_buf.h.html#28">buffer</a></div><div id="57" class="line none">   57 </div><div id="58" class="line none">   58 /**</div><div id="59" class="line none">   59  * Helper Macro for inititilizing a byte cursor from a string literal</div><div id="60" class="line none">   60  */</div><div id="61" class="line none">   61 #define <a href="byte_buf.h.html#61">AWS_BYTE_CUR_INIT_FROM_STRING_LITERAL</a>(literal)                                                                 \</div><div id="62" class="line none">   62     { .<a href="byte_buf.h.html#41">ptr</a> = (uint8_t *)(const char *)(literal), .<a href="byte_buf.h.html#27">len</a> = sizeof(literal) - 1 }</div><div id="63" class="line none">   63 </div><div id="64" class="line none">   64 /**</div><div id="65" class="line none">   65  * Signature for function argument to trim APIs</div><div id="66" class="line none">   66  */</div><div id="67" class="line none">   67 typedef bool(<a href="byte_buf.h.html#67">aws_byte_predicate_fn</a>)(uint8_t <a href="atomics.h.html#17">value</a>);</div><div id="68" class="line none">   68 </div><div id="69" class="line none">   69 AWS_EXTERN_C_BEGIN</div><div id="70" class="line none">   70 </div><div id="71" class="line none">   71 /**</div><div id="72" class="line none">   72  * Compare two arrays.</div><div id="73" class="line none">   73  * Return whether their contents are equivalent.</div><div id="74" class="line none">   74  * NULL may be passed as the array pointer if its length is declared to be 0.</div><div id="75" class="line none">   75  */</div><div id="76" class="line none">   76 AWS_COMMON_API</div><div id="77" class="line none">   77 bool <a href="../../../source/byte_buf.c.html#419">aws_array_eq</a>(const void *const array_a, const size_t len_a, const void *array_b, const size_t len_b);</div><div id="78" class="line none">   78 </div><div id="79" class="line none">   79 /**</div><div id="80" class="line none">   80  * Perform a case-insensitive string comparison of two arrays.</div><div id="81" class="line none">   81  * Return whether their contents are equivalent.</div><div id="82" class="line none">   82  * NULL may be passed as the array pointer if its length is declared to be 0.</div><div id="83" class="line none">   83  * The "C" locale is used for comparing upper and lowercase letters.</div><div id="84" class="line none">   84  * Data is assumed to be ASCII text, UTF-8 will work fine too.</div><div id="85" class="line none">   85  */</div><div id="86" class="line none">   86 AWS_COMMON_API</div><div id="87" class="line none">   87 bool <a href="../../../source/byte_buf.c.html#394">aws_array_eq_ignore_case</a>(</div><div id="88" class="line none">   88     const void *const array_a,</div><div id="89" class="line none">   89     const size_t len_a,</div><div id="90" class="line none">   90     const void *const array_b,</div><div id="91" class="line none">   91     const size_t len_b);</div><div id="92" class="line none">   92 </div><div id="93" class="line none">   93 /**</div><div id="94" class="line none">   94  * Compare an array and a null-terminated string.</div><div id="95" class="line none">   95  * Returns true if their contents are equivalent.</div><div id="96" class="line none">   96  * The array should NOT contain a null-terminator, or the comparison will always return false.</div><div id="97" class="line none">   97  * NULL may be passed as the array pointer if its length is declared to be 0.</div><div id="98" class="line none">   98  */</div><div id="99" class="line none">   99 AWS_COMMON_API</div><div id="100" class="line none">  100 bool <a href="../../../source/byte_buf.c.html#464">aws_array_eq_c_str</a>(const void *const array, const size_t array_len, const char *const c_str);</div><div id="101" class="line none">  101 </div><div id="102" class="line none">  102 /**</div><div id="103" class="line none">  103  * Perform a case-insensitive string comparison of an array and a null-terminated string.</div><div id="104" class="line none">  104  * Return whether their contents are equivalent.</div><div id="105" class="line none">  105  * The array should NOT contain a null-terminator, or the comparison will always return false.</div><div id="106" class="line none">  106  * NULL may be passed as the array pointer if its length is declared to be 0.</div><div id="107" class="line none">  107  * The "C" locale is used for comparing upper and lowercase letters.</div><div id="108" class="line none">  108  * Data is assumed to be ASCII text, UTF-8 will work fine too.</div><div id="109" class="line none">  109  */</div><div id="110" class="line none">  110 AWS_COMMON_API</div><div id="111" class="line none">  111 bool <a href="../../../source/byte_buf.c.html#436">aws_array_eq_c_str_ignore_case</a>(const void *const array, const size_t array_len, const char *const c_str);</div><div id="112" class="line none">  112 </div><div id="113" class="line none">  113 AWS_COMMON_API</div><div id="114" class="line none">  114 int <a href="../../../source/byte_buf.c.html#17">aws_byte_buf_init</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf, struct <a href="allocator.h.html#15">aws_allocator</a> *<a href="ring_buffer.h.html#19">allocator</a>, size_t <a href="byte_buf.h.html#29">capacity</a>);</div><div id="115" class="line none">  115 </div><div id="116" class="line none">  116 /**</div><div id="117" class="line none">  117  * Initializes an aws_byte_buf structure base on another valid one.</div><div id="118" class="line none">  118  * Requires: *src and *allocator are valid objects.</div><div id="119" class="line none">  119  * Ensures: *dest is a valid aws_byte_buf with a new backing array dest-&gt;buffer</div><div id="120" class="line none">  120  * which is a copy of the elements from src-&gt;buffer.</div><div id="121" class="line none">  121  */</div><div id="122" class="line none">  122 AWS_COMMON_API int <a href="../../../source/byte_buf.c.html#34">aws_byte_buf_init_copy</a>(</div><div id="123" class="line none">  123     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *dest,</div><div id="124" class="line none">  124     struct <a href="allocator.h.html#15">aws_allocator</a> *<a href="ring_buffer.h.html#19">allocator</a>,</div><div id="125" class="line none">  125     const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *src);</div><div id="126" class="line none">  126 </div><div id="127" class="line none">  127 /**</div><div id="128" class="line none">  128  * Evaluates the set of properties that define the shape of all valid aws_byte_buf structures.</div><div id="129" class="line none">  129  * It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion).</div><div id="130" class="line none">  130  */</div><div id="131" class="line none">  131 AWS_COMMON_API</div><div id="132" class="line none">  132 bool <a href="../../../source/byte_buf.c.html#58">aws_byte_buf_is_valid</a>(const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const buf);</div><div id="133" class="line none">  133 </div><div id="134" class="line none">  134 /**</div><div id="135" class="line none">  135  * Evaluates the set of properties that define the shape of all valid aws_byte_cursor structures.</div><div id="136" class="line none">  136  * It is also a cheap check, in the sense it runs in constant time (i.e., no loops or recursion).</div><div id="137" class="line none">  137  */</div><div id="138" class="line none">  138 AWS_COMMON_API</div><div id="139" class="line none">  139 bool <a href="../../../source/byte_buf.c.html#64">aws_byte_cursor_is_valid</a>(const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *cursor);</div><div id="140" class="line none">  140 </div><div id="141" class="line none">  141 /**</div><div id="142" class="line none">  142  * Copies src buffer into dest and sets the correct len and capacity.</div><div id="143" class="line none">  143  * A new memory zone is allocated for dest-&gt;buffer. When dest is no longer needed it will have to be cleaned-up using</div><div id="144" class="line none">  144  * aws_byte_buf_clean_up(dest).</div><div id="145" class="line none">  145  * Dest capacity and len will be equal to the src len. Allocator of the dest will be identical with parameter allocator.</div><div id="146" class="line none">  146  * If src buffer is null the dest will have a null buffer with a len and a capacity of 0</div><div id="147" class="line none">  147  * Returns AWS_OP_SUCCESS in case of success or AWS_OP_ERR when memory can't be allocated.</div><div id="148" class="line none">  148  */</div><div id="149" class="line none">  149 AWS_COMMON_API</div><div id="150" class="line none">  150 int <a href="../../../source/byte_buf.c.html#137">aws_byte_buf_init_copy_from_cursor</a>(</div><div id="151" class="line none">  151     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *dest,</div><div id="152" class="line none">  152     struct <a href="allocator.h.html#15">aws_allocator</a> *<a href="ring_buffer.h.html#19">allocator</a>,</div><div id="153" class="line none">  153     struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> src);</div><div id="154" class="line none">  154 </div><div id="155" class="line none">  155 /**</div><div id="156" class="line none">  156  * Init buffer with contents of multiple cursors, and update cursors to reference the memory stored in the buffer.</div><div id="157" class="line none">  157  * Each cursor arg must be an `struct aws_byte_cursor *`. NULL must be passed as the final arg.</div><div id="158" class="line none">  158  * NOTE: Do not append/grow/resize buffers initialized this way, or the cursors will end up referencing invalid memory.</div><div id="159" class="line none">  159  * Returns AWS_OP_SUCCESS in case of success.</div><div id="160" class="line none">  160  * AWS_OP_ERR is returned if memory can't be allocated or the total cursor length exceeds SIZE_MAX.</div><div id="161" class="line none">  161  */</div><div id="162" class="line none">  162 AWS_COMMON_API</div><div id="163" class="line none">  163 int <a href="../../../source/byte_buf.c.html#162">aws_byte_buf_init_cache_and_update_cursors</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *dest, struct <a href="allocator.h.html#15">aws_allocator</a> *<a href="ring_buffer.h.html#19">allocator</a>, ...);</div><div id="164" class="line none">  164 </div><div id="165" class="line none">  165 AWS_COMMON_API</div><div id="166" class="line none">  166 void <a href="../../../source/byte_buf.c.html#76">aws_byte_buf_clean_up</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf);</div><div id="167" class="line none">  167 </div><div id="168" class="line none">  168 /**</div><div id="169" class="line none">  169  * Equivalent to calling aws_byte_buf_secure_zero and then aws_byte_buf_clean_up</div><div id="170" class="line none">  170  * on the buffer.</div><div id="171" class="line none">  171  */</div><div id="172" class="line none">  172 AWS_COMMON_API</div><div id="173" class="line none">  173 void <a href="../../../source/byte_buf.c.html#96">aws_byte_buf_clean_up_secure</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf);</div><div id="174" class="line none">  174 </div><div id="175" class="line none">  175 /**</div><div id="176" class="line none">  176  * Resets the len of the buffer to 0, but does not free the memory. The buffer can then be reused.</div><div id="177" class="line none">  177  * Optionally zeroes the contents, if the "zero_contents" flag is true.</div><div id="178" class="line none">  178  */</div><div id="179" class="line none">  179 AWS_COMMON_API</div><div id="180" class="line none">  180 void <a href="../../../source/byte_buf.c.html#69">aws_byte_buf_reset</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf, bool zero_contents);</div><div id="181" class="line none">  181 </div><div id="182" class="line none">  182 /**</div><div id="183" class="line none">  183  * Sets all bytes of buffer to zero and resets len to zero.</div><div id="184" class="line none">  184  */</div><div id="185" class="line none">  185 AWS_COMMON_API</div><div id="186" class="line none">  186 void <a href="../../../source/byte_buf.c.html#87">aws_byte_buf_secure_zero</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf);</div><div id="187" class="line none">  187 </div><div id="188" class="line none">  188 /**</div><div id="189" class="line none">  189  * Compare two aws_byte_buf structures.</div><div id="190" class="line none">  190  * Return whether their contents are equivalent.</div><div id="191" class="line none">  191  */</div><div id="192" class="line none">  192 AWS_COMMON_API</div><div id="193" class="line none">  193 bool <a href="../../../source/byte_buf.c.html#103">aws_byte_buf_eq</a>(const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const a, const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const b);</div><div id="194" class="line none">  194 </div><div id="195" class="line none">  195 /**</div><div id="196" class="line none">  196  * Perform a case-insensitive string comparison of two aws_byte_buf structures.</div><div id="197" class="line none">  197  * Return whether their contents are equivalent.</div><div id="198" class="line none">  198  * The "C" locale is used for comparing upper and lowercase letters.</div><div id="199" class="line none">  199  * Data is assumed to be ASCII text, UTF-8 will work fine too.</div><div id="200" class="line none">  200  */</div><div id="201" class="line none">  201 AWS_COMMON_API</div><div id="202" class="line none">  202 bool <a href="../../../source/byte_buf.c.html#112">aws_byte_buf_eq_ignore_case</a>(const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const a, const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const b);</div><div id="203" class="line none">  203 </div><div id="204" class="line none">  204 /**</div><div id="205" class="line none">  205  * Compare an aws_byte_buf and a null-terminated string.</div><div id="206" class="line none">  206  * Returns true if their contents are equivalent.</div><div id="207" class="line none">  207  * The buffer should NOT contain a null-terminator, or the comparison will always return false.</div><div id="208" class="line none">  208  */</div><div id="209" class="line none">  209 AWS_COMMON_API</div><div id="210" class="line none">  210 bool <a href="../../../source/byte_buf.c.html#121">aws_byte_buf_eq_c_str</a>(const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const buf, const char *const c_str);</div><div id="211" class="line none">  211 </div><div id="212" class="line none">  212 /**</div><div id="213" class="line none">  213  * Perform a case-insensitive string comparison of an aws_byte_buf and a null-terminated string.</div><div id="214" class="line none">  214  * Return whether their contents are equivalent.</div><div id="215" class="line none">  215  * The buffer should NOT contain a null-terminator, or the comparison will always return false.</div><div id="216" class="line none">  216  * The "C" locale is used for comparing upper and lowercase letters.</div><div id="217" class="line none">  217  * Data is assumed to be ASCII text, UTF-8 will work fine too.</div><div id="218" class="line none">  218  */</div><div id="219" class="line none">  219 AWS_COMMON_API</div><div id="220" class="line none">  220 bool <a href="../../../source/byte_buf.c.html#129">aws_byte_buf_eq_c_str_ignore_case</a>(const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const buf, const char *const c_str);</div><div id="221" class="line none">  221 </div><div id="222" class="line none">  222 /**</div><div id="223" class="line none">  223  * No copies, no buffer allocations. Iterates over input_str, and returns the next substring between split_on instances.</div><div id="224" class="line none">  224  *</div><div id="225" class="line none">  225  * Edge case rules are as follows:</div><div id="226" class="line none">  226  * If the input is an empty string, an empty cursor will be the one entry returned.</div><div id="227" class="line none">  227  * If the input begins with split_on, an empty cursor will be the first entry returned.</div><div id="228" class="line none">  228  * If the input has two adjacent split_on tokens, an empty cursor will be returned.</div><div id="229" class="line none">  229  * If the input ends with split_on, an empty cursor will be returned last.</div><div id="230" class="line none">  230  *</div><div id="231" class="line none">  231  * It is the user's responsibility zero-initialize substr before the first call.</div><div id="232" class="line none">  232  *</div><div id="233" class="line none">  233  * It is the user's responsibility to make sure the input buffer stays in memory</div><div id="234" class="line none">  234  * long enough to use the results.</div><div id="235" class="line none">  235  */</div><div id="236" class="line none">  236 AWS_COMMON_API</div><div id="237" class="line none">  237 bool <a href="../../../source/byte_buf.c.html#196">aws_byte_cursor_next_split</a>(</div><div id="238" class="line none">  238     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT input_str,</div><div id="239" class="line none">  239     char split_on,</div><div id="240" class="line none">  240     struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT substr);</div><div id="241" class="line none">  241 </div><div id="242" class="line none">  242 /**</div><div id="243" class="line none">  243  * No copies, no buffer allocations. Fills in output with a list of</div><div id="244" class="line none">  244  * aws_byte_cursor instances where buffer is an offset into the input_str and</div><div id="245" class="line none">  245  * len is the length of that string in the original buffer.</div><div id="246" class="line none">  246  *</div><div id="247" class="line none">  247  * Edge case rules are as follows:</div><div id="248" class="line none">  248  * if the input begins with split_on, an empty cursor will be the first entry in</div><div id="249" class="line none">  249  * output. if the input has two adjacent split_on tokens, an empty cursor will</div><div id="250" class="line none">  250  * be inserted into the output. if the input ends with split_on, an empty cursor</div><div id="251" class="line none">  251  * will be appended to the output.</div><div id="252" class="line none">  252  *</div><div id="253" class="line none">  253  * It is the user's responsibility to properly initialize output. Recommended number of preallocated elements from</div><div id="254" class="line none">  254  * output is your most likely guess for the upper bound of the number of elements resulting from the split.</div><div id="255" class="line none">  255  *</div><div id="256" class="line none">  256  * The type that will be stored in output is struct aws_byte_cursor (you'll need</div><div id="257" class="line none">  257  * this for the item size param).</div><div id="258" class="line none">  258  *</div><div id="259" class="line none">  259  * It is the user's responsibility to make sure the input buffer stays in memory</div><div id="260" class="line none">  260  * long enough to use the results.</div><div id="261" class="line none">  261  */</div><div id="262" class="line none">  262 AWS_COMMON_API</div><div id="263" class="line none">  263 int <a href="../../../source/byte_buf.c.html#288">aws_byte_cursor_split_on_char</a>(</div><div id="264" class="line none">  264     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT input_str,</div><div id="265" class="line none">  265     char split_on,</div><div id="266" class="line none">  266     struct <a href="array_list.h.html#15">aws_array_list</a> *AWS_RESTRICT output);</div><div id="267" class="line none">  267 </div><div id="268" class="line none">  268 /**</div><div id="269" class="line none">  269  * No copies, no buffer allocations. Fills in output with a list of aws_byte_cursor instances where buffer is</div><div id="270" class="line none">  270  * an offset into the input_str and len is the length of that string in the original buffer. N is the max number of</div><div id="271" class="line none">  271  * splits, if this value is zero, it will add all splits to the output.</div><div id="272" class="line none">  272  *</div><div id="273" class="line none">  273  * Edge case rules are as follows:</div><div id="274" class="line none">  274  * if the input begins with split_on, an empty cursor will be the first entry in output</div><div id="275" class="line none">  275  * if the input has two adjacent split_on tokens, an empty cursor will be inserted into the output.</div><div id="276" class="line none">  276  * if the input ends with split_on, an empty cursor will be appended to the output.</div><div id="277" class="line none">  277  *</div><div id="278" class="line none">  278  * It is the user's responsibility to properly initialize output. Recommended number of preallocated elements from</div><div id="279" class="line none">  279  * output is your most likely guess for the upper bound of the number of elements resulting from the split.</div><div id="280" class="line none">  280  *</div><div id="281" class="line none">  281  * If the output array is not large enough, input_str will be updated to point to the first character after the last</div><div id="282" class="line none">  282  * processed split_on instance.</div><div id="283" class="line none">  283  *</div><div id="284" class="line none">  284  * The type that will be stored in output is struct aws_byte_cursor (you'll need this for the item size param).</div><div id="285" class="line none">  285  *</div><div id="286" class="line none">  286  * It is the user's responsibility to make sure the input buffer stays in memory long enough to use the results.</div><div id="287" class="line none">  287  */</div><div id="288" class="line none">  288 AWS_COMMON_API</div><div id="289" class="line none">  289 int <a href="../../../source/byte_buf.c.html#256">aws_byte_cursor_split_on_char_n</a>(</div><div id="290" class="line none">  290     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT input_str,</div><div id="291" class="line none">  291     char split_on,</div><div id="292" class="line none">  292     size_t n,</div><div id="293" class="line none">  293     struct <a href="array_list.h.html#15">aws_array_list</a> *AWS_RESTRICT output);</div><div id="294" class="line none">  294 </div><div id="295" class="line none">  295 /**</div><div id="296" class="line none">  296  * Search for an exact byte match inside a cursor. The first match will be returned. Returns AWS_OP_SUCCESS</div><div id="297" class="line none">  297  * on successful match and first_find will be set to the offset in input_str, and length will be the remaining length</div><div id="298" class="line none">  298  * from input_str past the returned offset. If the match was not found, AWS_OP_ERR will be returned and</div><div id="299" class="line none">  299  * AWS_ERROR_STRING_MATCH_NOT_FOUND will be raised.</div><div id="300" class="line none">  300  */</div><div id="301" class="line none">  301 AWS_COMMON_API</div><div id="302" class="line none">  302 int <a href="../../../source/byte_buf.c.html#296">aws_byte_cursor_find_exact</a>(</div><div id="303" class="line none">  303     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT input_str,</div><div id="304" class="line none">  304     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT to_find,</div><div id="305" class="line none">  305     struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *first_find);</div><div id="306" class="line none">  306 </div><div id="307" class="line none">  307 /**</div><div id="308" class="line none">  308  *</div><div id="309" class="line none">  309  * Shrinks a byte cursor from the right for as long as the supplied predicate is true</div><div id="310" class="line none">  310  */</div><div id="311" class="line none">  311 AWS_COMMON_API</div><div id="312" class="line none">  312 struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> <a href="../../../source/byte_buf.c.html#777">aws_byte_cursor_right_trim_pred</a>(</div><div id="313" class="line none">  313     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *source,</div><div id="314" class="line none">  314     <a href="byte_buf.h.html#67">aws_byte_predicate_fn</a> *predicate);</div><div id="315" class="line none">  315 </div><div id="316" class="line none">  316 /**</div><div id="317" class="line none">  317  * Shrinks a byte cursor from the left for as long as the supplied predicate is true</div><div id="318" class="line none">  318  */</div><div id="319" class="line none">  319 AWS_COMMON_API</div><div id="320" class="line none">  320 struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> <a href="../../../source/byte_buf.c.html#792">aws_byte_cursor_left_trim_pred</a>(</div><div id="321" class="line none">  321     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *source,</div><div id="322" class="line none">  322     <a href="byte_buf.h.html#67">aws_byte_predicate_fn</a> *predicate);</div><div id="323" class="line none">  323 </div><div id="324" class="line none">  324 /**</div><div id="325" class="line none">  325  * Shrinks a byte cursor from both sides for as long as the supplied predicate is true</div><div id="326" class="line none">  326  */</div><div id="327" class="line none">  327 AWS_COMMON_API</div><div id="328" class="line none">  328 struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> <a href="../../../source/byte_buf.c.html#808">aws_byte_cursor_trim_pred</a>(</div><div id="329" class="line none">  329     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *source,</div><div id="330" class="line none">  330     <a href="byte_buf.h.html#67">aws_byte_predicate_fn</a> *predicate);</div><div id="331" class="line none">  331 </div><div id="332" class="line none">  332 /**</div><div id="333" class="line none">  333  * Returns true if the byte cursor's range of bytes all satisfy the predicate</div><div id="334" class="line none">  334  */</div><div id="335" class="line none">  335 AWS_COMMON_API</div><div id="336" class="line none">  336 bool <a href="../../../source/byte_buf.c.html#820">aws_byte_cursor_satisfies_pred</a>(const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *source, <a href="byte_buf.h.html#67">aws_byte_predicate_fn</a> *predicate);</div><div id="337" class="line none">  337 </div><div id="338" class="line none">  338 /**</div><div id="339" class="line none">  339  * Copies from to to. If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be</div><div id="340" class="line none">  340  * returned. dest-&gt;len will contain the amount of data actually copied to dest.</div><div id="341" class="line none">  341  *</div><div id="342" class="line none">  342  * from and to may be the same buffer, permitting copying a buffer into itself.</div><div id="343" class="line none">  343  */</div><div id="344" class="line none">  344 AWS_COMMON_API</div><div id="345" class="line none">  345 int <a href="../../../source/byte_buf.c.html#561">aws_byte_buf_append</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *to, const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *<a href="../../../../sources/openssl/evp_override.c.html#412">from</a>);</div><div id="346" class="line none">  346 </div><div id="347" class="line none">  347 /**</div><div id="348" class="line none">  348  * Copies from to to while converting bytes via the passed in lookup table.</div><div id="349" class="line none">  349  * If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be</div><div id="350" class="line none">  350  * returned. to-&gt;len will contain its original size plus the amount of data actually copied to to.</div><div id="351" class="line none">  351  *</div><div id="352" class="line none">  352  * from and to should not be the same buffer (overlap is not handled)</div><div id="353" class="line none">  353  * lookup_table must be at least 256 bytes</div><div id="354" class="line none">  354  */</div><div id="355" class="line none">  355 AWS_COMMON_API</div><div id="356" class="line none">  356 int <a href="../../../source/byte_buf.c.html#584">aws_byte_buf_append_with_lookup</a>(</div><div id="357" class="line none">  357     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT to,</div><div id="358" class="line none">  358     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT <a href="../../../../sources/openssl/evp_override.c.html#412">from</a>,</div><div id="359" class="line none">  359     const uint8_t *lookup_table);</div><div id="360" class="line none">  360 </div><div id="361" class="line none">  361 /**</div><div id="362" class="line none">  362  * Copies from to to. If to is too small, the buffer will be grown appropriately and</div><div id="363" class="line none">  363  * the old contents copied to, before the new contents are appended.</div><div id="364" class="line none">  364  *</div><div id="365" class="line none">  365  * If the grow fails (overflow or OOM), then an error will be returned.</div><div id="366" class="line none">  366  *</div><div id="367" class="line none">  367  * from and to may be the same buffer, permitting copying a buffer into itself.</div><div id="368" class="line none">  368  */</div><div id="369" class="line none">  369 AWS_COMMON_API</div><div id="370" class="line none">  370 int <a href="../../../source/byte_buf.c.html#713">aws_byte_buf_append_dynamic</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *to, const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *<a href="../../../../sources/openssl/evp_override.c.html#412">from</a>);</div><div id="371" class="line none">  371 </div><div id="372" class="line none">  372 /**</div><div id="373" class="line none">  373  * Copies `from` to `to`. If `to` is too small, the buffer will be grown appropriately and</div><div id="374" class="line none">  374  * the old contents copied over, before the new contents are appended.</div><div id="375" class="line none">  375  *</div><div id="376" class="line none">  376  * If the grow fails (overflow or OOM), then an error will be returned.</div><div id="377" class="line none">  377  *</div><div id="378" class="line none">  378  * If the buffer is grown, the old buffer will be securely cleared before getting freed.</div><div id="379" class="line none">  379  *</div><div id="380" class="line none">  380  * `from` and `to` may be the same buffer, permitting copying a buffer into itself.</div><div id="381" class="line none">  381  */</div><div id="382" class="line none">  382 AWS_COMMON_API</div><div id="383" class="line none">  383 int <a href="../../../source/byte_buf.c.html#717">aws_byte_buf_append_dynamic_secure</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *to, const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *<a href="../../../../sources/openssl/evp_override.c.html#412">from</a>);</div><div id="384" class="line none">  384 </div><div id="385" class="line none">  385 /**</div><div id="386" class="line none">  386  * Copies a single byte into `to`. If `to` is too small, the buffer will be grown appropriately and</div><div id="387" class="line none">  387  * the old contents copied over, before the byte is appended.</div><div id="388" class="line none">  388  *</div><div id="389" class="line none">  389  * If the grow fails (overflow or OOM), then an error will be returned.</div><div id="390" class="line none">  390  */</div><div id="391" class="line none">  391 AWS_COMMON_API</div><div id="392" class="line none">  392 int <a href="../../../source/byte_buf.c.html#737">aws_byte_buf_append_byte_dynamic</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *<a href="byte_buf.h.html#28">buffer</a>, uint8_t <a href="atomics.h.html#17">value</a>);</div><div id="393" class="line none">  393 </div><div id="394" class="line none">  394 /**</div><div id="395" class="line none">  395  * Copies a single byte into `to`. If `to` is too small, the buffer will be grown appropriately and</div><div id="396" class="line none">  396  * the old contents copied over, before the byte is appended.</div><div id="397" class="line none">  397  *</div><div id="398" class="line none">  398  * If the grow fails (overflow or OOM), then an error will be returned.</div><div id="399" class="line none">  399  *</div><div id="400" class="line none">  400  * If the buffer is grown, the old buffer will be securely cleared before getting freed.</div><div id="401" class="line none">  401  */</div><div id="402" class="line none">  402 AWS_COMMON_API</div><div id="403" class="line none">  403 int <a href="../../../source/byte_buf.c.html#741">aws_byte_buf_append_byte_dynamic_secure</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *<a href="byte_buf.h.html#28">buffer</a>, uint8_t <a href="atomics.h.html#17">value</a>);</div><div id="404" class="line none">  404 </div><div id="405" class="line none">  405 /**</div><div id="406" class="line none">  406  * Copy contents of cursor to buffer, then update cursor to reference the memory stored in the buffer.</div><div id="407" class="line none">  407  * If buffer is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned.</div><div id="408" class="line none">  408  *</div><div id="409" class="line none">  409  * The cursor is permitted to reference memory from earlier in the buffer.</div><div id="410" class="line none">  410  */</div><div id="411" class="line none">  411 AWS_COMMON_API</div><div id="412" class="line none">  412 int <a href="../../../source/byte_buf.c.html#1577">aws_byte_buf_append_and_update</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *to, struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *from_and_update);</div><div id="413" class="line none">  413 </div><div id="414" class="line none">  414 /**</div><div id="415" class="line none">  415  * Appends '\0' at the end of the buffer.</div><div id="416" class="line none">  416  */</div><div id="417" class="line none">  417 AWS_COMMON_API</div><div id="418" class="line none">  418 int <a href="../../../source/byte_buf.c.html#1590">aws_byte_buf_append_null_terminator</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf);</div><div id="419" class="line none">  419 </div><div id="420" class="line none">  420 /**</div><div id="421" class="line none">  421  * Attempts to increase the capacity of a buffer to the requested capacity</div><div id="422" class="line none">  422  *</div><div id="423" class="line none">  423  * If the the buffer's capacity is currently larger than the request capacity, the</div><div id="424" class="line none">  424  * function does nothing (no shrink is performed).</div><div id="425" class="line none">  425  */</div><div id="426" class="line none">  426 AWS_COMMON_API</div><div id="427" class="line none">  427 int <a href="../../../source/byte_buf.c.html#745">aws_byte_buf_reserve</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *<a href="byte_buf.h.html#28">buffer</a>, size_t requested_capacity);</div><div id="428" class="line none">  428 </div><div id="429" class="line none">  429 /**</div><div id="430" class="line none">  430  * Convenience function that attempts to increase the capacity of a buffer relative to the current</div><div id="431" class="line none">  431  * length.</div><div id="432" class="line none">  432  *</div><div id="433" class="line none">  433  *  aws_byte_buf_reserve_relative(buf, x) ~~ aws_byte_buf_reserve(buf, buf-&gt;len + x)</div><div id="434" class="line none">  434  *</div><div id="435" class="line none">  435  */</div><div id="436" class="line none">  436 AWS_COMMON_API</div><div id="437" class="line none">  437 int <a href="../../../source/byte_buf.c.html#764">aws_byte_buf_reserve_relative</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *<a href="byte_buf.h.html#28">buffer</a>, size_t additional_length);</div><div id="438" class="line none">  438 </div><div id="439" class="line none">  439 /**</div><div id="440" class="line none">  440  * Concatenates a variable number of struct aws_byte_buf * into destination.</div><div id="441" class="line none">  441  * Number of args must be greater than 1. If dest is too small,</div><div id="442" class="line none">  442  * AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. dest-&gt;len will contain the</div><div id="443" class="line none">  443  * amount of data actually copied to dest.</div><div id="444" class="line none">  444  */</div><div id="445" class="line none">  445 AWS_COMMON_API</div><div id="446" class="line none">  446 int <a href="../../../source/byte_buf.c.html#334">aws_byte_buf_cat</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *dest, size_t number_of_args, ...);</div><div id="447" class="line none">  447 </div><div id="448" class="line none">  448 /**</div><div id="449" class="line none">  449  * Compare two aws_byte_cursor structures.</div><div id="450" class="line none">  450  * Return whether their contents are equivalent.</div><div id="451" class="line none">  451  */</div><div id="452" class="line none">  452 AWS_COMMON_API</div><div id="453" class="line none">  453 bool <a href="../../../source/byte_buf.c.html#356">aws_byte_cursor_eq</a>(const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *a, const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *b);</div><div id="454" class="line none">  454 </div><div id="455" class="line none">  455 /**</div><div id="456" class="line none">  456  * Perform a case-insensitive string comparison of two aws_byte_cursor structures.</div><div id="457" class="line none">  457  * Return whether their contents are equivalent.</div><div id="458" class="line none">  458  * The "C" locale is used for comparing upper and lowercase letters.</div><div id="459" class="line none">  459  * Data is assumed to be ASCII text, UTF-8 will work fine too.</div><div id="460" class="line none">  460  */</div><div id="461" class="line none">  461 AWS_COMMON_API</div><div id="462" class="line none">  462 bool <a href="../../../source/byte_buf.c.html#365">aws_byte_cursor_eq_ignore_case</a>(const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *a, const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *b);</div><div id="463" class="line none">  463 </div><div id="464" class="line none">  464 /**</div><div id="465" class="line none">  465  * Compare an aws_byte_cursor and an aws_byte_buf.</div><div id="466" class="line none">  466  * Return whether their contents are equivalent.</div><div id="467" class="line none">  467  */</div><div id="468" class="line none">  468 AWS_COMMON_API</div><div id="469" class="line none">  469 bool <a href="../../../source/byte_buf.c.html#525">aws_byte_cursor_eq_byte_buf</a>(const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *const a, const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const b);</div><div id="470" class="line none">  470 </div><div id="471" class="line none">  471 /**</div><div id="472" class="line none">  472  * Perform a case-insensitive string comparison of an aws_byte_cursor and an aws_byte_buf.</div><div id="473" class="line none">  473  * Return whether their contents are equivalent.</div><div id="474" class="line none">  474  * The "C" locale is used for comparing upper and lowercase letters.</div><div id="475" class="line none">  475  * Data is assumed to be ASCII text, UTF-8 will work fine too.</div><div id="476" class="line none">  476  */</div><div id="477" class="line none">  477 AWS_COMMON_API</div><div id="478" class="line none">  478 bool <a href="../../../source/byte_buf.c.html#534">aws_byte_cursor_eq_byte_buf_ignore_case</a>(const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *const a, const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const b);</div><div id="479" class="line none">  479 </div><div id="480" class="line none">  480 /**</div><div id="481" class="line none">  481  * Compare an aws_byte_cursor and a null-terminated string.</div><div id="482" class="line none">  482  * Returns true if their contents are equivalent.</div><div id="483" class="line none">  483  * The cursor should NOT contain a null-terminator, or the comparison will always return false.</div><div id="484" class="line none">  484  */</div><div id="485" class="line none">  485 AWS_COMMON_API</div><div id="486" class="line none">  486 bool <a href="../../../source/byte_buf.c.html#545">aws_byte_cursor_eq_c_str</a>(const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *const cursor, const char *const c_str);</div><div id="487" class="line none">  487 </div><div id="488" class="line none">  488 /**</div><div id="489" class="line none">  489  * Perform a case-insensitive string comparison of an aws_byte_cursor and a null-terminated string.</div><div id="490" class="line none">  490  * Return whether their contents are equivalent.</div><div id="491" class="line none">  491  * The cursor should NOT contain a null-terminator, or the comparison will always return false.</div><div id="492" class="line none">  492  * The "C" locale is used for comparing upper and lowercase letters.</div><div id="493" class="line none">  493  * Data is assumed to be ASCII text, UTF-8 will work fine too.</div><div id="494" class="line none">  494  */</div><div id="495" class="line none">  495 AWS_COMMON_API</div><div id="496" class="line none">  496 bool <a href="../../../source/byte_buf.c.html#553">aws_byte_cursor_eq_c_str_ignore_case</a>(const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *const cursor, const char *const c_str);</div><div id="497" class="line none">  497 </div><div id="498" class="line none">  498 /**</div><div id="499" class="line none">  499  * Case-insensitive hash function for array containing ASCII or UTF-8 text.</div><div id="500" class="line none">  500  */</div><div id="501" class="line none">  501 AWS_COMMON_API</div><div id="502" class="line none">  502 uint64_t <a href="../../../source/byte_buf.c.html#492">aws_hash_array_ignore_case</a>(const void *array, const size_t <a href="byte_buf.h.html#27">len</a>);</div><div id="503" class="line none">  503 </div><div id="504" class="line none">  504 /**</div><div id="505" class="line none">  505  * Case-insensitive hash function for aws_byte_cursors stored in an aws_hash_table.</div><div id="506" class="line none">  506  * For case-sensitive hashing, use aws_hash_byte_cursor_ptr().</div><div id="507" class="line none">  507  */</div><div id="508" class="line none">  508 AWS_COMMON_API</div><div id="509" class="line none">  509 uint64_t <a href="../../../source/byte_buf.c.html#517">aws_hash_byte_cursor_ptr_ignore_case</a>(const void *item);</div><div id="510" class="line none">  510 </div><div id="511" class="line none">  511 /**</div><div id="512" class="line none">  512  * Returns a lookup table for bytes that is the identity transformation with the exception</div><div id="513" class="line none">  513  * of uppercase ascii characters getting replaced with lowercase characters.  Used in</div><div id="514" class="line none">  514  * caseless comparisons.</div><div id="515" class="line none">  515  */</div><div id="516" class="line none">  516 AWS_COMMON_API</div><div id="517" class="line none">  517 const uint8_t *<a href="../../../source/byte_buf.c.html#390">aws_lookup_table_to_lower_get</a>(void);</div><div id="518" class="line none">  518 </div><div id="519" class="line none">  519 /**</div><div id="520" class="line none">  520  * Returns lookup table to go from ASCII/UTF-8 hex character to a number (0-15).</div><div id="521" class="line none">  521  * Non-hex characters map to 255.</div><div id="522" class="line none">  522  * Valid examples:</div><div id="523" class="line none">  523  * '0' -&gt; 0</div><div id="524" class="line none">  524  * 'F' -&gt; 15</div><div id="525" class="line none">  525  * 'f' -&gt; 15</div><div id="526" class="line none">  526  * Invalid examples:</div><div id="527" class="line none">  527  * ' ' -&gt; 255</div><div id="528" class="line none">  528  * 'Z' -&gt; 255</div><div id="529" class="line none">  529  * '\0' -&gt; 255</div><div id="530" class="line none">  530  */</div><div id="531" class="line none">  531 AWS_COMMON_API</div><div id="532" class="line none">  532 const uint8_t *<a href="../../../source/byte_buf.c.html#1329">aws_lookup_table_hex_to_num_get</a>(void);</div><div id="533" class="line none">  533 </div><div id="534" class="line none">  534 /**</div><div id="535" class="line none">  535  * Lexical (byte value) comparison of two byte cursors</div><div id="536" class="line none">  536  */</div><div id="537" class="line none">  537 AWS_COMMON_API</div><div id="538" class="line none">  538 int <a href="../../../source/byte_buf.c.html#827">aws_byte_cursor_compare_lexical</a>(const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *lhs, const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *rhs);</div><div id="539" class="line none">  539 </div><div id="540" class="line none">  540 /**</div><div id="541" class="line none">  541  * Lexical (byte value) comparison of two byte cursors where the raw values are sent through a lookup table first</div><div id="542" class="line none">  542  */</div><div id="543" class="line none">  543 AWS_COMMON_API</div><div id="544" class="line none">  544 int <a href="../../../source/byte_buf.c.html#853">aws_byte_cursor_compare_lookup</a>(</div><div id="545" class="line none">  545     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *lhs,</div><div id="546" class="line none">  546     const struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *rhs,</div><div id="547" class="line none">  547     const uint8_t *lookup_table);</div><div id="548" class="line none">  548 </div><div id="549" class="line none">  549 /**</div><div id="550" class="line none">  550  * For creating a byte buffer from a null-terminated string literal.</div><div id="551" class="line none">  551  */</div><div id="552" class="line none">  552 AWS_COMMON_API struct <a href="byte_buf.h.html#25">aws_byte_buf</a> <a href="../../../source/byte_buf.c.html#900">aws_byte_buf_from_c_str</a>(const char *c_str);</div><div id="553" class="line none">  553 </div><div id="554" class="line none">  554 AWS_COMMON_API struct <a href="byte_buf.h.html#25">aws_byte_buf</a> <a href="../../../source/byte_buf.c.html#910">aws_byte_buf_from_array</a>(const void *<a href="string.h.html#45">bytes</a>, size_t <a href="byte_buf.h.html#27">len</a>);</div><div id="555" class="line none">  555 </div><div id="556" class="line none">  556 AWS_COMMON_API struct <a href="byte_buf.h.html#25">aws_byte_buf</a> <a href="../../../source/byte_buf.c.html#921">aws_byte_buf_from_empty_array</a>(const void *<a href="string.h.html#45">bytes</a>, size_t <a href="byte_buf.h.html#29">capacity</a>);</div><div id="557" class="line none">  557 </div><div id="558" class="line none">  558 AWS_COMMON_API struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> <a href="../../../source/byte_buf.c.html#933">aws_byte_cursor_from_buf</a>(const struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const buf);</div><div id="559" class="line none">  559 </div><div id="560" class="line none">  560 AWS_COMMON_API struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> <a href="../../../source/byte_buf.c.html#942">aws_byte_cursor_from_c_str</a>(const char *c_str);</div><div id="561" class="line none">  561 </div><div id="562" class="line none">  562 AWS_COMMON_API struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> <a href="../../../source/byte_buf.c.html#950">aws_byte_cursor_from_array</a>(const void *const <a href="string.h.html#45">bytes</a>, const size_t <a href="byte_buf.h.html#27">len</a>);</div><div id="563" class="line none">  563 </div><div id="564" class="line none">  564 /**</div><div id="565" class="line none">  565  * Tests if the given aws_byte_cursor has at least len bytes remaining. If so,</div><div id="566" class="line none">  566  * *buf is advanced by len bytes (incrementing -&gt;ptr and decrementing -&gt;len),</div><div id="567" class="line none">  567  * and an aws_byte_cursor referring to the first len bytes of the original *buf</div><div id="568" class="line none">  568  * is returned. Otherwise, an aws_byte_cursor with -&gt;ptr = NULL, -&gt;len = 0 is</div><div id="569" class="line none">  569  * returned.</div><div id="570" class="line none">  570  *</div><div id="571" class="line none">  571  * Note that if len is above (SIZE_MAX / 2), this function will also treat it as</div><div id="572" class="line none">  572  * a buffer overflow, and return NULL without changing *buf.</div><div id="573" class="line none">  573  */</div><div id="574" class="line none">  574 AWS_COMMON_API struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> <a href="../../../source/byte_buf.c.html#1041">aws_byte_cursor_advance</a>(struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *const cursor, const size_t <a href="byte_buf.h.html#27">len</a>);</div><div id="575" class="line none">  575 </div><div id="576" class="line none">  576 /**</div><div id="577" class="line none">  577  * Behaves identically to aws_byte_cursor_advance, but avoids speculative</div><div id="578" class="line none">  578  * execution potentially reading out-of-bounds pointers (by returning an</div><div id="579" class="line none">  579  * empty ptr in such speculated paths).</div><div id="580" class="line none">  580  *</div><div id="581" class="line none">  581  * This should generally be done when using an untrusted or</div><div id="582" class="line none">  582  * data-dependent value for 'len', to avoid speculating into a path where</div><div id="583" class="line none">  583  * cursor-&gt;ptr points outside the true ptr length.</div><div id="584" class="line none">  584  */</div><div id="585" class="line none">  585 </div><div id="586" class="line none">  586 AWS_COMMON_API struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> <a href="../../../source/byte_buf.c.html#1069">aws_byte_cursor_advance_nospec</a>(struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *const cursor, size_t <a href="byte_buf.h.html#27">len</a>);</div><div id="587" class="line none">  587 </div><div id="588" class="line none">  588 /**</div><div id="589" class="line none">  589  * Reads specified length of data from byte cursor and copies it to the</div><div id="590" class="line none">  590  * destination array.</div><div id="591" class="line none">  591  *</div><div id="592" class="line none">  592  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="593" class="line none">  593  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="594" class="line none">  594  * cursor unchanged.</div><div id="595" class="line none">  595  */</div><div id="596" class="line none">  596 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1112">aws_byte_cursor_read</a>(</div><div id="597" class="line none">  597     struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT cur,</div><div id="598" class="line none">  598     void *AWS_RESTRICT dest,</div><div id="599" class="line none">  599     const size_t <a href="byte_buf.h.html#27">len</a>);</div><div id="600" class="line none">  600 </div><div id="601" class="line none">  601 /**</div><div id="602" class="line none">  602  * Reads as many bytes from cursor as size of buffer, and copies them to buffer.</div><div id="603" class="line none">  603  *</div><div id="604" class="line none">  604  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="605" class="line none">  605  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="606" class="line none">  606  * cursor unchanged.</div><div id="607" class="line none">  607  */</div><div id="608" class="line none">  608 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1137">aws_byte_cursor_read_and_fill_buffer</a>(</div><div id="609" class="line none">  609     struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT cur,</div><div id="610" class="line none">  610     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT dest);</div><div id="611" class="line none">  611 </div><div id="612" class="line none">  612 /**</div><div id="613" class="line none">  613  * Reads a single byte from cursor, placing it in *var.</div><div id="614" class="line none">  614  *</div><div id="615" class="line none">  615  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="616" class="line none">  616  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="617" class="line none">  617  * cursor unchanged.</div><div id="618" class="line none">  618  */</div><div id="619" class="line none">  619 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1160">aws_byte_cursor_read_u8</a>(struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *AWS_RESTRICT cur, uint8_t *AWS_RESTRICT var);</div><div id="620" class="line none">  620 </div><div id="621" class="line none">  621 /**</div><div id="622" class="line none">  622  * Reads a 16-bit value in network byte order from cur, and places it in host</div><div id="623" class="line none">  623  * byte order into var.</div><div id="624" class="line none">  624  *</div><div id="625" class="line none">  625  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="626" class="line none">  626  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="627" class="line none">  627  * cursor unchanged.</div><div id="628" class="line none">  628  */</div><div id="629" class="line none">  629 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1176">aws_byte_cursor_read_be16</a>(struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *cur, uint16_t *var);</div><div id="630" class="line none">  630 </div><div id="631" class="line none">  631 /**</div><div id="632" class="line none">  632  * Reads an unsigned 24-bit value (3 bytes) in network byte order from cur,</div><div id="633" class="line none">  633  * and places it in host byte order into 32-bit var.</div><div id="634" class="line none">  634  * Ex: if cur's next 3 bytes are {0xAA, 0xBB, 0xCC}, then var becomes 0x00AABBCC.</div><div id="635" class="line none">  635  *</div><div id="636" class="line none">  636  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="637" class="line none">  637  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="638" class="line none">  638  * cursor unchanged.</div><div id="639" class="line none">  639  */</div><div id="640" class="line none">  640 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1198">aws_byte_cursor_read_be24</a>(struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *cur, uint32_t *var);</div><div id="641" class="line none">  641 </div><div id="642" class="line none">  642 /**</div><div id="643" class="line none">  643  * Reads a 32-bit value in network byte order from cur, and places it in host</div><div id="644" class="line none">  644  * byte order into var.</div><div id="645" class="line none">  645  *</div><div id="646" class="line none">  646  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="647" class="line none">  647  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="648" class="line none">  648  * cursor unchanged.</div><div id="649" class="line none">  649  */</div><div id="650" class="line none">  650 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1226">aws_byte_cursor_read_be32</a>(struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *cur, uint32_t *var);</div><div id="651" class="line none">  651 </div><div id="652" class="line none">  652 /**</div><div id="653" class="line none">  653  * Reads a 64-bit value in network byte order from cur, and places it in host</div><div id="654" class="line none">  654  * byte order into var.</div><div id="655" class="line none">  655  *</div><div id="656" class="line none">  656  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="657" class="line none">  657  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="658" class="line none">  658  * cursor unchanged.</div><div id="659" class="line none">  659  */</div><div id="660" class="line none">  660 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1289">aws_byte_cursor_read_be64</a>(struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *cur, uint64_t *var);</div><div id="661" class="line none">  661 </div><div id="662" class="line none">  662 /**</div><div id="663" class="line none">  663  * Reads a 32-bit value in network byte order from cur, and places it in host</div><div id="664" class="line none">  664  * byte order into var.</div><div id="665" class="line none">  665  *</div><div id="666" class="line none">  666  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="667" class="line none">  667  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="668" class="line none">  668  * cursor unchanged.</div><div id="669" class="line none">  669  */</div><div id="670" class="line none">  670 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1247">aws_byte_cursor_read_float_be32</a>(struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *cur, float *var);</div><div id="671" class="line none">  671 </div><div id="672" class="line none">  672 /**</div><div id="673" class="line none">  673  * Reads a 64-bit value in network byte order from cur, and places it in host</div><div id="674" class="line none">  674  * byte order into var.</div><div id="675" class="line none">  675  *</div><div id="676" class="line none">  676  * On success, returns true and updates the cursor pointer/length accordingly.</div><div id="677" class="line none">  677  * If there is insufficient space in the cursor, returns false, leaving the</div><div id="678" class="line none">  678  * cursor unchanged.</div><div id="679" class="line none">  679  */</div><div id="680" class="line none">  680 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1268">aws_byte_cursor_read_float_be64</a>(struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *cur, double *var);</div><div id="681" class="line none">  681 </div><div id="682" class="line none">  682 /**</div><div id="683" class="line none">  683  * Reads 2 hex characters from ASCII/UTF-8 text to produce an 8-bit number.</div><div id="684" class="line none">  684  * Accepts both lowercase 'a'-'f' and uppercase 'A'-'F'.</div><div id="685" class="line none">  685  * For example: "0F" produces 15.</div><div id="686" class="line none">  686  *</div><div id="687" class="line none">  687  * On success, returns true and advances the cursor by 2.</div><div id="688" class="line none">  688  * If there is insufficient space in the cursor or an invalid character</div><div id="689" class="line none">  689  * is encountered, returns false, leaving the cursor unchanged.</div><div id="690" class="line none">  690  */</div><div id="691" class="line none">  691 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1333">aws_byte_cursor_read_hex_u8</a>(struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *cur, uint8_t *var);</div><div id="692" class="line none">  692 </div><div id="693" class="line none">  693 /**</div><div id="694" class="line none">  694  * Appends a sub-buffer to the specified buffer.</div><div id="695" class="line none">  695  *</div><div id="696" class="line none">  696  * If the buffer has at least `len' bytes remaining (buffer-&gt;capacity - buffer-&gt;len &gt;= len),</div><div id="697" class="line none">  697  * then buffer-&gt;len is incremented by len, and an aws_byte_buf is assigned to *output corresponding</div><div id="698" class="line none">  698  * to the last len bytes of the input buffer. The aws_byte_buf at *output will have a null</div><div id="699" class="line none">  699  * allocator, a zero initial length, and a capacity of 'len'. The function then returns true.</div><div id="700" class="line none">  700  *</div><div id="701" class="line none">  701  * If there is insufficient space, then this function nulls all fields in *output and returns</div><div id="702" class="line none">  702  * false.</div><div id="703" class="line none">  703  */</div><div id="704" class="line none">  704 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1366">aws_byte_buf_advance</a>(</div><div id="705" class="line none">  705     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const AWS_RESTRICT <a href="byte_buf.h.html#28">buffer</a>,</div><div id="706" class="line none">  706     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *const AWS_RESTRICT output,</div><div id="707" class="line none">  707     const size_t <a href="byte_buf.h.html#27">len</a>);</div><div id="708" class="line none">  708 </div><div id="709" class="line none">  709 /**</div><div id="710" class="line none">  710  * Write specified number of bytes from array to byte buffer.</div><div id="711" class="line none">  711  *</div><div id="712" class="line none">  712  * On success, returns true and updates the buffer length accordingly.</div><div id="713" class="line none">  713  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="714" class="line none">  714  * buffer unchanged.</div><div id="715" class="line none">  715  */</div><div id="716" class="line none">  716 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1394">aws_byte_buf_write</a>(</div><div id="717" class="line none">  717     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT buf,</div><div id="718" class="line none">  718     const uint8_t *AWS_RESTRICT src,</div><div id="719" class="line none">  719     size_t <a href="byte_buf.h.html#27">len</a>);</div><div id="720" class="line none">  720 </div><div id="721" class="line none">  721 /**</div><div id="722" class="line none">  722  * Copies all bytes from buffer to buffer.</div><div id="723" class="line none">  723  *</div><div id="724" class="line none">  724  * On success, returns true and updates the buffer /length accordingly.</div><div id="725" class="line none">  725  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="726" class="line none">  726  * buffer unchanged.</div><div id="727" class="line none">  727  */</div><div id="728" class="line none">  728 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1422">aws_byte_buf_write_from_whole_buffer</a>(</div><div id="729" class="line none">  729     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT buf,</div><div id="730" class="line none">  730     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> src);</div><div id="731" class="line none">  731 </div><div id="732" class="line none">  732 /**</div><div id="733" class="line none">  733  * Copies all bytes from buffer to buffer.</div><div id="734" class="line none">  734  *</div><div id="735" class="line none">  735  * On success, returns true and updates the buffer /length accordingly.</div><div id="736" class="line none">  736  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="737" class="line none">  737  * buffer unchanged.</div><div id="738" class="line none">  738  */</div><div id="739" class="line none">  739 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1435">aws_byte_buf_write_from_whole_cursor</a>(</div><div id="740" class="line none">  740     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT buf,</div><div id="741" class="line none">  741     struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> src);</div><div id="742" class="line none">  742 </div><div id="743" class="line none">  743 /**</div><div id="744" class="line none">  744  * Without increasing buf's capacity, write as much as possible from advancing_cursor into buf.</div><div id="745" class="line none">  745  *</div><div id="746" class="line none">  746  * buf's len is updated accordingly.</div><div id="747" class="line none">  747  * advancing_cursor is advanced so it contains the remaining unwritten parts.</div><div id="748" class="line none">  748  * Returns the section of advancing_cursor which was written.</div><div id="749" class="line none">  749  *</div><div id="750" class="line none">  750  * This function cannot fail. If buf is full (len == capacity) or advancing_len has 0 length,</div><div id="751" class="line none">  751  * then buf and advancing_cursor are not altered and a cursor with 0 length is returned.</div><div id="752" class="line none">  752  *</div><div id="753" class="line none">  753  * Example: Given a buf with 2 bytes of space available and advancing_cursor with contents "abc".</div><div id="754" class="line none">  754  * "ab" will be written to buf and buf-&gt;len will increase 2 and become equal to buf-&gt;capacity.</div><div id="755" class="line none">  755  * advancing_cursor will advance so its contents become the unwritten "c".</div><div id="756" class="line none">  756  * The returned cursor's contents will be the "ab" from the original advancing_cursor.</div><div id="757" class="line none">  757  */</div><div id="758" class="line none">  758 AWS_COMMON_API struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> <a href="../../../source/byte_buf.c.html#1441">aws_byte_buf_write_to_capacity</a>(</div><div id="759" class="line none">  759     struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf,</div><div id="760" class="line none">  760     struct <a href="byte_buf.h.html#38">aws_byte_cursor</a> *advancing_cursor);</div><div id="761" class="line none">  761 </div><div id="762" class="line none">  762 /**</div><div id="763" class="line none">  763  * Copies one byte to buffer.</div><div id="764" class="line none">  764  *</div><div id="765" class="line none">  765  * On success, returns true and updates the cursor /length</div><div id="766" class="line none">  766  accordingly.</div><div id="767" class="line none">  767  *</div><div id="768" class="line none">  768  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="769" class="line none">  769  * buffer unchanged.</div><div id="770" class="line none">  770  */</div><div id="771" class="line none">  771 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1464">aws_byte_buf_write_u8</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *AWS_RESTRICT buf, uint8_t c);</div><div id="772" class="line none">  772 </div><div id="773" class="line none">  773 /**</div><div id="774" class="line none">  774  * Writes one byte repeatedly to buffer (like memset)</div><div id="775" class="line none">  775  *</div><div id="776" class="line none">  776  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="777" class="line none">  777  * buffer unchanged.</div><div id="778" class="line none">  778  */</div><div id="779" class="line none">  779 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1475">aws_byte_buf_write_u8_n</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf, uint8_t c, size_t <a href="error.h.html#34">count</a>);</div><div id="780" class="line none">  780 </div><div id="781" class="line none">  781 /**</div><div id="782" class="line none">  782  * Writes a 16-bit integer in network byte order (big endian) to buffer.</div><div id="783" class="line none">  783  *</div><div id="784" class="line none">  784  * On success, returns true and updates the buffer /length accordingly.</div><div id="785" class="line none">  785  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="786" class="line none">  786  * buffer unchanged.</div><div id="787" class="line none">  787  */</div><div id="788" class="line none">  788 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1497">aws_byte_buf_write_be16</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf, uint16_t x);</div><div id="789" class="line none">  789 </div><div id="790" class="line none">  790 /**</div><div id="791" class="line none">  791  * Writes low 24-bits (3 bytes) of an unsigned integer in network byte order (big endian) to buffer.</div><div id="792" class="line none">  792  * Ex: If x is 0x00AABBCC then {0xAA, 0xBB, 0xCC} is written to buffer.</div><div id="793" class="line none">  793  *</div><div id="794" class="line none">  794  * On success, returns true and updates the buffer /length accordingly.</div><div id="795" class="line none">  795  * If there is insufficient space in the buffer, or x's value cannot fit in 3 bytes,</div><div id="796" class="line none">  796  * returns false, leaving the buffer unchanged.</div><div id="797" class="line none">  797  */</div><div id="798" class="line none">  798 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1511">aws_byte_buf_write_be24</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf, uint32_t x);</div><div id="799" class="line none">  799 </div><div id="800" class="line none">  800 /**</div><div id="801" class="line none">  801  * Writes a 32-bit integer in network byte order (big endian) to buffer.</div><div id="802" class="line none">  802  *</div><div id="803" class="line none">  803  * On success, returns true and updates the buffer /length accordingly.</div><div id="804" class="line none">  804  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="805" class="line none">  805  * buffer unchanged.</div><div id="806" class="line none">  806  */</div><div id="807" class="line none">  807 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1532">aws_byte_buf_write_be32</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf, uint32_t x);</div><div id="808" class="line none">  808 </div><div id="809" class="line none">  809 /**</div><div id="810" class="line none">  810  * Writes a 32-bit float in network byte order (big endian) to buffer.</div><div id="811" class="line none">  811  *</div><div id="812" class="line none">  812  * On success, returns true and updates the buffer /length accordingly.</div><div id="813" class="line none">  813  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="814" class="line none">  814  * buffer unchanged.</div><div id="815" class="line none">  815  */</div><div id="816" class="line none">  816 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1545">aws_byte_buf_write_float_be32</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf, float x);</div><div id="817" class="line none">  817 </div><div id="818" class="line none">  818 /**</div><div id="819" class="line none">  819  * Writes a 64-bit integer in network byte order (big endian) to buffer.</div><div id="820" class="line none">  820  *</div><div id="821" class="line none">  821  * On success, returns true and updates the buffer /length accordingly.</div><div id="822" class="line none">  822  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="823" class="line none">  823  * buffer unchanged.</div><div id="824" class="line none">  824  */</div><div id="825" class="line none">  825 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1558">aws_byte_buf_write_be64</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf, uint64_t x);</div><div id="826" class="line none">  826 </div><div id="827" class="line none">  827 /**</div><div id="828" class="line none">  828  * Writes a 64-bit float in network byte order (big endian) to buffer.</div><div id="829" class="line none">  829  *</div><div id="830" class="line none">  830  * On success, returns true and updates the buffer /length accordingly.</div><div id="831" class="line none">  831  * If there is insufficient space in the buffer, returns false, leaving the</div><div id="832" class="line none">  832  * buffer unchanged.</div><div id="833" class="line none">  833  */</div><div id="834" class="line none">  834 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1571">aws_byte_buf_write_float_be64</a>(struct <a href="byte_buf.h.html#25">aws_byte_buf</a> *buf, double x);</div><div id="835" class="line none">  835 </div><div id="836" class="line none">  836 /**</div><div id="837" class="line none">  837  * Like isalnum(), but ignores C locale.</div><div id="838" class="line none">  838  * Returns true if ch has the value of ASCII/UTF-8: 'a'-'z', 'A'-'Z', or '0'-'9'.</div><div id="839" class="line none">  839  */</div><div id="840" class="line none">  840 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1594">aws_isalnum</a>(uint8_t ch);</div><div id="841" class="line none">  841 </div><div id="842" class="line none">  842 /**</div><div id="843" class="line none">  843  * Like isalpha(), but ignores C locale.</div><div id="844" class="line none">  844  * Returns true if ch has the value of ASCII/UTF-8: 'a'-'z' or 'A'-'Z'.</div><div id="845" class="line none">  845  */</div><div id="846" class="line none">  846 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1598">aws_isalpha</a>(uint8_t ch);</div><div id="847" class="line none">  847 </div><div id="848" class="line none">  848 /**</div><div id="849" class="line none">  849  * Like isdigit().</div><div id="850" class="line none">  850  * Returns true if ch has the value of ASCII/UTF-8: '0'-'9'.</div><div id="851" class="line none">  851  *</div><div id="852" class="line none">  852  * Note: C's built-in isdigit() is also supposed to ignore the C locale,</div><div id="853" class="line none">  853  * but cppreference.com claims "some implementations (e.g. Microsoft in 1252 codepage)</div><div id="854" class="line none">  854  * may classify additional single-byte characters as digits"</div><div id="855" class="line none">  855  */</div><div id="856" class="line none">  856 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1602">aws_isdigit</a>(uint8_t ch);</div><div id="857" class="line none">  857 </div><div id="858" class="line none">  858 /**</div><div id="859" class="line none">  859  * Like isxdigit().</div><div id="860" class="line none">  860  * Returns true if ch has the value of ASCII/UTF-8: '0'-'9', 'a'-'f', or 'A'-'F'.</div><div id="861" class="line none">  861  *</div><div id="862" class="line none">  862  * Note: C's built-in isxdigit() is also supposed to ignore the C locale,</div><div id="863" class="line none">  863  * but cppreference.com claims "some implementations (e.g. Microsoft in 1252 codepage)</div><div id="864" class="line none">  864  * may classify additional single-byte characters as digits"</div><div id="865" class="line none">  865  */</div><div id="866" class="line none">  866 </div><div id="867" class="line none">  867 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1606">aws_isxdigit</a>(uint8_t ch);</div><div id="868" class="line none">  868 </div><div id="869" class="line none">  869 /**</div><div id="870" class="line none">  870  * Like isspace(), but ignores C locale.</div><div id="871" class="line none">  871  * Return true if ch has the value of ASCII/UTF-8: space (0x20), form feed (0x0C),</div><div id="872" class="line none">  872  * line feed (0x0A), carriage return (0x0D), horizontal tab (0x09), or vertical tab (0x0B).</div><div id="873" class="line none">  873  */</div><div id="874" class="line none">  874 AWS_COMMON_API bool <a href="../../../source/byte_buf.c.html#1610">aws_isspace</a>(uint8_t ch);</div><div id="875" class="line none">  875 </div><div id="876" class="line none">  876 AWS_EXTERN_C_END</div><div id="877" class="line none">  877 </div><div id="878" class="line none">  878 #endif /* AWS_COMMON_BYTE_BUF_H */</div>
</div>
</body>
</html>
