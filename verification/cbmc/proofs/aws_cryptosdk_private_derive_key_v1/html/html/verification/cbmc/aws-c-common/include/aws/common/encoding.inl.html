
<html>
<head>
<title>verification/cbmc/aws-c-common/include/aws/common/encoding.inl</title>
<link rel="stylesheet" type="text/css" href="../../../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 #ifndef AWS_COMMON_ENCODING_INL</div><div id="2" class="line none">    2 #define AWS_COMMON_ENCODING_INL</div><div id="3" class="line none">    3 </div><div id="4" class="line none">    4 /**</div><div id="5" class="line none">    5  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.</div><div id="6" class="line none">    6  * SPDX-License-Identifier: Apache-2.0.</div><div id="7" class="line none">    7  */</div><div id="8" class="line none">    8 </div><div id="9" class="line none">    9 #include &lt;aws/common/byte_buf.h&gt;</div><div id="10" class="line none">   10 #include &lt;aws/common/byte_order.h&gt;</div><div id="11" class="line none">   11 #include &lt;aws/common/common.h&gt;</div><div id="12" class="line none">   12 #include &lt;aws/common/encoding.h&gt;</div><div id="13" class="line none">   13 </div><div id="14" class="line none">   14 AWS_EXTERN_C_BEGIN</div><div id="15" class="line none">   15 </div><div id="16" class="line none">   16 /* Add a 64 bit unsigned integer to the buffer, ensuring network - byte order</div><div id="17" class="line none">   17  * Assumes the buffer size is at least 8 bytes.</div><div id="18" class="line none">   18  */</div><div id="19" class="line none">   19 AWS_STATIC_IMPL void <a href="encoding.inl.html#19">aws_write_u64</a>(uint64_t <a href="atomics.h.html#17">value</a>, uint8_t *<a href="byte_buf.h.html#28">buffer</a>) {</div><div id="20" class="line none">   20     <a href="atomics.h.html#17">value</a> = <a href="byte_order.inl.html#34">aws_hton64</a>(<a href="atomics.h.html#17">value</a>);</div><div id="21" class="line none">   21 </div><div id="22" class="line none">   22     memcpy((void *)<a href="byte_buf.h.html#28">buffer</a>, &amp;<a href="atomics.h.html#17">value</a>, sizeof(<a href="atomics.h.html#17">value</a>));</div><div id="23" class="line none">   23 }</div><div id="24" class="line none">   24 </div><div id="25" class="line none">   25 /*</div><div id="26" class="line none">   26  * Extracts a 64 bit unsigned integer from buffer. Ensures conversion from</div><div id="27" class="line none">   27  * network byte order to host byte order. Assumes buffer size is at least 8</div><div id="28" class="line none">   28  * bytes.</div><div id="29" class="line none">   29  */</div><div id="30" class="line none">   30 AWS_STATIC_IMPL uint64_t <a href="encoding.inl.html#30">aws_read_u64</a>(const uint8_t *<a href="byte_buf.h.html#28">buffer</a>) {</div><div id="31" class="line none">   31     uint64_t <a href="atomics.h.html#17">value</a> = 0;</div><div id="32" class="line none">   32     memcpy((void *)&amp;<a href="atomics.h.html#17">value</a>, (void *)<a href="byte_buf.h.html#28">buffer</a>, sizeof(<a href="atomics.h.html#17">value</a>));</div><div id="33" class="line none">   33 </div><div id="34" class="line none">   34     return <a href="byte_order.inl.html#54">aws_ntoh64</a>(<a href="atomics.h.html#17">value</a>);</div><div id="35" class="line none">   35 }</div><div id="36" class="line none">   36 </div><div id="37" class="line none">   37 /* Add a 32 bit unsigned integer to the buffer, ensuring network - byte order</div><div id="38" class="line none">   38  * Assumes the buffer size is at least 4 bytes.</div><div id="39" class="line none">   39  */</div><div id="40" class="line none">   40 AWS_STATIC_IMPL void <a href="encoding.inl.html#40">aws_write_u32</a>(uint32_t <a href="atomics.h.html#17">value</a>, uint8_t *<a href="byte_buf.h.html#28">buffer</a>) {</div><div id="41" class="line none">   41     <a href="atomics.h.html#17">value</a> = <a href="byte_order.inl.html#61">aws_hton32</a>(<a href="atomics.h.html#17">value</a>);</div><div id="42" class="line none">   42 </div><div id="43" class="line none">   43     memcpy((void *)<a href="byte_buf.h.html#28">buffer</a>, (void *)&amp;<a href="atomics.h.html#17">value</a>, sizeof(<a href="atomics.h.html#17">value</a>));</div><div id="44" class="line none">   44 }</div><div id="45" class="line none">   45 </div><div id="46" class="line none">   46 /*</div><div id="47" class="line none">   47  * Extracts a 32 bit unsigned integer from buffer. Ensures conversion from</div><div id="48" class="line none">   48  * network byte order to host byte order. Assumes the buffer size is at least 4</div><div id="49" class="line none">   49  * bytes.</div><div id="50" class="line none">   50  */</div><div id="51" class="line none">   51 AWS_STATIC_IMPL uint32_t <a href="encoding.inl.html#51">aws_read_u32</a>(const uint8_t *<a href="byte_buf.h.html#28">buffer</a>) {</div><div id="52" class="line none">   52     uint32_t <a href="atomics.h.html#17">value</a> = 0;</div><div id="53" class="line none">   53     memcpy((void *)&amp;<a href="atomics.h.html#17">value</a>, (void *)<a href="byte_buf.h.html#28">buffer</a>, sizeof(<a href="atomics.h.html#17">value</a>));</div><div id="54" class="line none">   54 </div><div id="55" class="line none">   55     return <a href="byte_order.inl.html#118">aws_ntoh32</a>(<a href="atomics.h.html#17">value</a>);</div><div id="56" class="line none">   56 }</div><div id="57" class="line none">   57 </div><div id="58" class="line none">   58 /* Add a 24 bit unsigned integer to the buffer, ensuring network - byte order</div><div id="59" class="line none">   59  * return the new position in the buffer for the next operation.</div><div id="60" class="line none">   60  * Note, since this uses uint32_t for storage, the 3 least significant bytes</div><div id="61" class="line none">   61  * will be used. Assumes buffer is at least 3 bytes long.</div><div id="62" class="line none">   62  */</div><div id="63" class="line none">   63 AWS_STATIC_IMPL void <a href="encoding.inl.html#63">aws_write_u24</a>(uint32_t <a href="atomics.h.html#17">value</a>, uint8_t *<a href="byte_buf.h.html#28">buffer</a>) {</div><div id="64" class="line none">   64     <a href="atomics.h.html#17">value</a> = <a href="byte_order.inl.html#61">aws_hton32</a>(<a href="atomics.h.html#17">value</a>);</div><div id="65" class="line none">   65     memcpy((void *)<a href="byte_buf.h.html#28">buffer</a>, (void *)((uint8_t *)&amp;<a href="atomics.h.html#17">value</a> + 1), sizeof(<a href="atomics.h.html#17">value</a>) - 1);</div><div id="66" class="line none">   66 }</div><div id="67" class="line none">   67 </div><div id="68" class="line none">   68 /*</div><div id="69" class="line none">   69  * Extracts a 24 bit unsigned integer from buffer. Ensures conversion from</div><div id="70" class="line none">   70  * network byte order to host byte order. Assumes buffer is at least 3 bytes</div><div id="71" class="line none">   71  * long.</div><div id="72" class="line none">   72  */</div><div id="73" class="line none">   73 AWS_STATIC_IMPL uint32_t <a href="encoding.inl.html#73">aws_read_u24</a>(const uint8_t *<a href="byte_buf.h.html#28">buffer</a>) {</div><div id="74" class="line none">   74     uint32_t <a href="atomics.h.html#17">value</a> = 0;</div><div id="75" class="line none">   75     memcpy((void *)((uint8_t *)&amp;<a href="atomics.h.html#17">value</a> + 1), (void *)<a href="byte_buf.h.html#28">buffer</a>, sizeof(<a href="atomics.h.html#17">value</a>) - 1);</div><div id="76" class="line none">   76 </div><div id="77" class="line none">   77     return <a href="byte_order.inl.html#118">aws_ntoh32</a>(<a href="atomics.h.html#17">value</a>);</div><div id="78" class="line none">   78 }</div><div id="79" class="line none">   79 </div><div id="80" class="line none">   80 /* Add a 16 bit unsigned integer to the buffer, ensuring network-byte order</div><div id="81" class="line none">   81  * return the new position in the buffer for the next operation.</div><div id="82" class="line none">   82  * Assumes buffer is at least 2 bytes long.</div><div id="83" class="line none">   83  */</div><div id="84" class="line none">   84 AWS_STATIC_IMPL void <a href="encoding.inl.html#84">aws_write_u16</a>(uint16_t <a href="atomics.h.html#17">value</a>, uint8_t *<a href="byte_buf.h.html#28">buffer</a>) {</div><div id="85" class="line none">   85     <a href="atomics.h.html#17">value</a> = <a href="byte_order.inl.html#143">aws_hton16</a>(<a href="atomics.h.html#17">value</a>);</div><div id="86" class="line none">   86 </div><div id="87" class="line none">   87     memcpy((void *)<a href="byte_buf.h.html#28">buffer</a>, (void *)&amp;<a href="atomics.h.html#17">value</a>, sizeof(<a href="atomics.h.html#17">value</a>));</div><div id="88" class="line none">   88 }</div><div id="89" class="line none">   89 </div><div id="90" class="line none">   90 /*</div><div id="91" class="line none">   91  * Extracts a 16 bit unsigned integer from buffer. Ensures conversion from</div><div id="92" class="line none">   92  * network byte order to host byte order. Assumes buffer is at least 2 bytes</div><div id="93" class="line none">   93  * long.</div><div id="94" class="line none">   94  */</div><div id="95" class="line none">   95 AWS_STATIC_IMPL uint16_t <a href="encoding.inl.html#95">aws_read_u16</a>(const uint8_t *<a href="byte_buf.h.html#28">buffer</a>) {</div><div id="96" class="line none">   96     uint16_t <a href="atomics.h.html#17">value</a> = 0;</div><div id="97" class="line none">   97     memcpy((void *)&amp;<a href="atomics.h.html#17">value</a>, (void *)<a href="byte_buf.h.html#28">buffer</a>, sizeof(<a href="atomics.h.html#17">value</a>));</div><div id="98" class="line none">   98 </div><div id="99" class="line none">   99     return <a href="byte_order.inl.html#154">aws_ntoh16</a>(<a href="atomics.h.html#17">value</a>);</div><div id="100" class="line none">  100 }</div><div id="101" class="line none">  101 </div><div id="102" class="line none">  102 /* Reference: https://unicodebook.readthedocs.io/guess_encoding.html */</div><div id="103" class="line none">  103 AWS_STATIC_IMPL enum <a href="encoding.h.html#133">aws_text_encoding</a> <a href="encoding.inl.html#103">aws_text_detect_encoding</a>(const uint8_t *<a href="string.h.html#45">bytes</a>, size_t <a href="private/hash_table_impl.h.html#35">size</a>) {</div><div id="104" class="line none">  104     static const char *UTF_8_BOM = "\xEF\xBB\xBF";</div><div id="105" class="line none">  105     static const char *UTF_16_BE_BOM = "\xFE\xFF";</div><div id="106" class="line none">  106     static const char *UTF_16_LE_BOM = "\xFF\xFE";</div><div id="107" class="line none">  107     static const char *UTF_32_BE_BOM = "\x00\x00\xFE\xFF";</div><div id="108" class="line none">  108     static const char *UTF_32_LE_BOM = "\xFF\xFE\x00\x00";</div><div id="109" class="line none">  109 </div><div id="110" class="line none">  110     if (<a href="private/hash_table_impl.h.html#35">size</a> &gt;= 3) {</div><div id="111" class="line none">  111         if (memcmp(<a href="string.h.html#45">bytes</a>, UTF_8_BOM, 3) == 0)</div><div id="112" class="line none">  112             return <a href="encoding.h.html#135">AWS_TEXT_UTF8</a>;</div><div id="113" class="line none">  113     }</div><div id="114" class="line none">  114     if (<a href="private/hash_table_impl.h.html#35">size</a> &gt;= 4) {</div><div id="115" class="line none">  115         if (memcmp(<a href="string.h.html#45">bytes</a>, UTF_32_LE_BOM, 4) == 0)</div><div id="116" class="line none">  116             return <a href="encoding.h.html#137">AWS_TEXT_UTF32</a>;</div><div id="117" class="line none">  117         if (memcmp(<a href="string.h.html#45">bytes</a>, UTF_32_BE_BOM, 4) == 0)</div><div id="118" class="line none">  118             return <a href="encoding.h.html#137">AWS_TEXT_UTF32</a>;</div><div id="119" class="line none">  119     }</div><div id="120" class="line none">  120     if (<a href="private/hash_table_impl.h.html#35">size</a> &gt;= 2) {</div><div id="121" class="line none">  121         if (memcmp(<a href="string.h.html#45">bytes</a>, UTF_16_LE_BOM, 2) == 0)</div><div id="122" class="line none">  122             return <a href="encoding.h.html#136">AWS_TEXT_UTF16</a>;</div><div id="123" class="line none">  123         if (memcmp(<a href="string.h.html#45">bytes</a>, UTF_16_BE_BOM, 2) == 0)</div><div id="124" class="line none">  124             return <a href="encoding.h.html#136">AWS_TEXT_UTF16</a>;</div><div id="125" class="line none">  125     }</div><div id="126" class="line none">  126     size_t idx = 0;</div><div id="127" class="line none">  127     for (; idx &lt; <a href="private/hash_table_impl.h.html#35">size</a>; ++idx) {</div><div id="128" class="line none">  128         if (<a href="string.h.html#45">bytes</a>[idx] &amp; 0x80) {</div><div id="129" class="line none">  129             return <a href="encoding.h.html#134">AWS_TEXT_UNKNOWN</a>;</div><div id="130" class="line none">  130         }</div><div id="131" class="line none">  131     }</div><div id="132" class="line none">  132     return <a href="encoding.h.html#138">AWS_TEXT_ASCII</a>;</div><div id="133" class="line none">  133 }</div><div id="134" class="line none">  134 </div><div id="135" class="line none">  135 AWS_STATIC_IMPL bool <a href="encoding.inl.html#135">aws_text_is_utf8</a>(const uint8_t *<a href="string.h.html#45">bytes</a>, size_t <a href="private/hash_table_impl.h.html#35">size</a>) {</div><div id="136" class="line none">  136     enum <a href="encoding.h.html#133">aws_text_encoding</a> encoding = <a href="encoding.inl.html#103">aws_text_detect_encoding</a>(<a href="string.h.html#45">bytes</a>, <a href="private/hash_table_impl.h.html#35">size</a>);</div><div id="137" class="line none">  137     return encoding == <a href="encoding.h.html#135">AWS_TEXT_UTF8</a> || encoding == <a href="encoding.h.html#138">AWS_TEXT_ASCII</a>;</div><div id="138" class="line none">  138 }</div><div id="139" class="line none">  139 </div><div id="140" class="line none">  140 AWS_EXTERN_C_END</div><div id="141" class="line none">  141 </div><div id="142" class="line none">  142 #endif /*  AWS_COMMON_ENCODING_INL */</div>
</div>
</body>
</html>
