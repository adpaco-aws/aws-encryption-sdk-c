
<html>
<head>
<title>verification/cbmc/aws-c-common/verification/cbmc/sources/utils.c</title>
<link rel="stylesheet" type="text/css" href="../../../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 /**</div><div id="2" class="line none">    2  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.</div><div id="3" class="line none">    3  * SPDX-License-Identifier: Apache-2.0.</div><div id="4" class="line none">    4  */</div><div id="5" class="line none">    5 </div><div id="6" class="line none">    6 #include &lt;aws/common/private/hash_table_impl.h&gt;</div><div id="7" class="line none">    7 #include &lt;proof_helpers/utils.h&gt;</div><div id="8" class="line none">    8 </div><div id="9" class="line none">    9 void <a href="utils.c.html#9">assert_bytes_match</a>(const uint8_t *const a, const uint8_t *const b, const size_t <a href="../../../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="10" class="line none">   10     assert(<a href="../../../include/aws/common/byte_buf.h.html#27">len</a> == 0 || !a == !b);</div><div id="11" class="line none">   11     if (<a href="../../../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0 &amp;&amp; a != NULL &amp;&amp; b != NULL) {</div><div id="12" class="line none">   12         size_t i;</div><div id="13" class="line none">   13         __CPROVER_assume(i &lt; <a href="../../../include/aws/common/byte_buf.h.html#27">len</a> &amp;&amp; <a href="../../../include/aws/common/byte_buf.h.html#27">len</a> &lt; MAX_MALLOC); /* prevent spurious pointer overflows */</div><div id="14" class="line none">   14         assert(a[i] == b[i]);</div><div id="15" class="line none">   15     }</div><div id="16" class="line none">   16 }</div><div id="17" class="line none">   17 </div><div id="18" class="line none">   18 void <a href="utils.c.html#18">assert_all_bytes_are</a>(const uint8_t *const a, const uint8_t c, const size_t <a href="../../../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="19" class="line none">   19     if (<a href="../../../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0 &amp;&amp; a != NULL) {</div><div id="20" class="line none">   20         size_t i;</div><div id="21" class="line none">   21         __CPROVER_assume(i &lt; <a href="../../../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="22" class="line none">   22         assert(a[i] == c);</div><div id="23" class="line none">   23     }</div><div id="24" class="line none">   24 }</div><div id="25" class="line none">   25 </div><div id="26" class="line none">   26 void <a href="utils.c.html#26">assert_all_zeroes</a>(const uint8_t *const a, const size_t <a href="../../../include/aws/common/byte_buf.h.html#27">len</a>) {</div><div id="27" class="line none">   27     <a href="utils.c.html#18">assert_all_bytes_are</a>(a, 0, <a href="../../../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="28" class="line none">   28 }</div><div id="29" class="line none">   29 </div><div id="30" class="line none">   30 void <a href="utils.c.html#30">assert_byte_from_buffer_matches</a>(const uint8_t *const <a href="../../../include/aws/common/byte_buf.h.html#28">buffer</a>, const struct <a href="../include/proof_helpers/utils.h.html#21">store_byte_from_buffer</a> *const b) {</div><div id="31" class="line missed">   31     if (<a href="../../../include/aws/common/byte_buf.h.html#28">buffer</a> &amp;&amp; b) {</div><div id="32" class="line missed">   32         assert(*(<a href="../../../include/aws/common/byte_buf.h.html#28">buffer</a> + b-&gt;<a href="../include/proof_helpers/utils.h.html#22">index</a>) == b-&gt;<a href="../include/proof_helpers/utils.h.html#23">byte</a>);</div><div id="33" class="line none">   33     }</div><div id="34" class="line missed">   34 }</div><div id="35" class="line none">   35 </div><div id="36" class="line none">   36 void <a href="utils.c.html#36">save_byte_from_array</a>(const uint8_t *const array, const size_t <a href="../../../include/aws/common/private/hash_table_impl.h.html#35">size</a>, struct <a href="../include/proof_helpers/utils.h.html#21">store_byte_from_buffer</a> *const storage) {</div><div id="37" class="line hit">   37     if (<a href="../../../include/aws/common/private/hash_table_impl.h.html#35">size</a> &gt; 0 &amp;&amp; array &amp;&amp; storage) {</div><div id="38" class="line hit">   38         storage-&gt;<a href="../include/proof_helpers/utils.h.html#22">index</a> = <a href="../include/proof_helpers/nondet.h.html#17">nondet_size_t</a>();</div><div id="39" class="line hit">   39         __CPROVER_assume(storage-&gt;<a href="../include/proof_helpers/utils.h.html#22">index</a> &lt; <a href="../../../include/aws/common/private/hash_table_impl.h.html#35">size</a>);</div><div id="40" class="line hit">   40         storage-&gt;<a href="../include/proof_helpers/utils.h.html#23">byte</a> = array[storage-&gt;<a href="../include/proof_helpers/utils.h.html#22">index</a>];</div><div id="41" class="line none">   41     }</div><div id="42" class="line hit">   42 }</div><div id="43" class="line none">   43 </div><div id="44" class="line none">   44 void <a href="utils.c.html#44">assert_array_list_equivalence</a>(</div><div id="45" class="line none">   45     const struct <a href="../../../include/aws/common/array_list.h.html#15">aws_array_list</a> *const lhs,</div><div id="46" class="line none">   46     const struct <a href="../../../include/aws/common/array_list.h.html#15">aws_array_list</a> *const rhs,</div><div id="47" class="line none">   47     const struct <a href="../include/proof_helpers/utils.h.html#21">store_byte_from_buffer</a> *const rhs_byte) {</div><div id="48" class="line none">   48     /* In order to be equivalent, either both are NULL or both are non-NULL */</div><div id="49" class="line none">   49     if (lhs == rhs) {</div><div id="50" class="line none">   50         return;</div><div id="51" class="line none">   51     } else {</div><div id="52" class="line none">   52         assert(lhs &amp;&amp; rhs); /* if only one is null, they differ */</div><div id="53" class="line none">   53     }</div><div id="54" class="line none">   54     assert(lhs-&gt;<a href="../../../include/aws/common/array_list.h.html#16">alloc</a> == rhs-&gt;<a href="../../../include/aws/common/array_list.h.html#16">alloc</a>);</div><div id="55" class="line none">   55     assert(lhs-&gt;<a href="../../../include/aws/common/array_list.h.html#17">current_size</a> == rhs-&gt;<a href="../../../include/aws/common/array_list.h.html#17">current_size</a>);</div><div id="56" class="line none">   56     assert(lhs-&gt;<a href="../../../include/aws/common/array_list.h.html#18">length</a> == rhs-&gt;<a href="../../../include/aws/common/array_list.h.html#18">length</a>);</div><div id="57" class="line none">   57     assert(lhs-&gt;<a href="../../../include/aws/common/array_list.h.html#19">item_size</a> == rhs-&gt;<a href="../../../include/aws/common/array_list.h.html#19">item_size</a>);</div><div id="58" class="line none">   58     if (lhs-&gt;<a href="../../../include/aws/common/array_list.h.html#17">current_size</a> &gt; 0) {</div><div id="59" class="line none">   59         <a href="utils.c.html#30">assert_byte_from_buffer_matches</a>((uint8_t *)lhs-&gt;<a href="../../../include/aws/common/array_list.h.html#20">data</a>, rhs_byte);</div><div id="60" class="line none">   60     }</div><div id="61" class="line none">   61 }</div><div id="62" class="line none">   62 </div><div id="63" class="line none">   63 void <a href="utils.c.html#63">assert_byte_buf_equivalence</a>(</div><div id="64" class="line none">   64     const struct <a href="../../../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const lhs,</div><div id="65" class="line none">   65     const struct <a href="../../../include/aws/common/byte_buf.h.html#25">aws_byte_buf</a> *const rhs,</div><div id="66" class="line none">   66     const struct <a href="../include/proof_helpers/utils.h.html#21">store_byte_from_buffer</a> *const rhs_byte) {</div><div id="67" class="line none">   67     /* In order to be equivalent, either both are NULL or both are non-NULL */</div><div id="68" class="line hit">   68     if (lhs == rhs) {</div><div id="69" class="line both">   69         return;</div><div id="70" class="line none">   70     } else {</div><div id="71" class="line missed">   71         assert(lhs &amp;&amp; rhs); /* if only one is null, they differ */</div><div id="72" class="line none">   72     }</div><div id="73" class="line missed">   73     assert(lhs-&gt;<a href="../../../include/aws/common/byte_buf.h.html#27">len</a> == rhs-&gt;<a href="../../../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="74" class="line missed">   74     assert(lhs-&gt;<a href="../../../include/aws/common/byte_buf.h.html#29">capacity</a> == rhs-&gt;<a href="../../../include/aws/common/byte_buf.h.html#29">capacity</a>);</div><div id="75" class="line missed">   75     assert(lhs-&gt;<a href="../../../include/aws/common/ring_buffer.h.html#19">allocator</a> == rhs-&gt;<a href="../../../include/aws/common/ring_buffer.h.html#19">allocator</a>);</div><div id="76" class="line missed">   76     if (lhs-&gt;<a href="../../../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0) {</div><div id="77" class="line missed">   77         <a href="utils.c.html#30">assert_byte_from_buffer_matches</a>(lhs-&gt;<a href="../../../include/aws/common/byte_buf.h.html#28">buffer</a>, rhs_byte);</div><div id="78" class="line none">   78     }</div><div id="79" class="line hit">   79 }</div><div id="80" class="line none">   80 </div><div id="81" class="line none">   81 void <a href="utils.c.html#81">assert_byte_cursor_equivalence</a>(</div><div id="82" class="line none">   82     const struct <a href="../../../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const lhs,</div><div id="83" class="line none">   83     const struct <a href="../../../include/aws/common/byte_buf.h.html#38">aws_byte_cursor</a> *const rhs,</div><div id="84" class="line none">   84     const struct <a href="../include/proof_helpers/utils.h.html#21">store_byte_from_buffer</a> *const rhs_byte) {</div><div id="85" class="line none">   85     assert(!lhs == !rhs);</div><div id="86" class="line none">   86     if (lhs &amp;&amp; rhs) {</div><div id="87" class="line none">   87         assert(lhs-&gt;<a href="../../../include/aws/common/byte_buf.h.html#27">len</a> == rhs-&gt;<a href="../../../include/aws/common/byte_buf.h.html#27">len</a>);</div><div id="88" class="line none">   88         if (lhs-&gt;<a href="../../../include/aws/common/byte_buf.h.html#27">len</a> &gt; 0) {</div><div id="89" class="line none">   89             <a href="utils.c.html#30">assert_byte_from_buffer_matches</a>(lhs-&gt;<a href="../../../include/aws/common/byte_buf.h.html#41">ptr</a>, rhs_byte);</div><div id="90" class="line none">   90         }</div><div id="91" class="line none">   91     }</div><div id="92" class="line none">   92 }</div><div id="93" class="line none">   93 </div><div id="94" class="line none">   94 void <a href="utils.c.html#94">save_byte_from_hash_table</a>(const struct <a href="../../../include/aws/common/hash_table.h.html#48">aws_hash_table</a> *<a href="../../../include/aws/common/hash_table.h.html#75">map</a>, struct <a href="../include/proof_helpers/utils.h.html#21">store_byte_from_buffer</a> *storage) {</div><div id="95" class="line none">   95     struct <a href="../../../include/aws/common/hash_table.h.html#47">hash_table_state</a> *state = <a href="../../../include/aws/common/hash_table.h.html#75">map</a>-&gt;<a href="../../../include/aws/common/hash_table.h.html#49">p_impl</a>;</div><div id="96" class="line none">   96     size_t size_in_bytes;</div><div id="97" class="line none">   97     __CPROVER_assume(<a href="../../../include/aws/common/private/hash_table_impl.h.html#60">hash_table_state_required_bytes</a>(state-&gt;<a href="../../../include/aws/common/private/hash_table_impl.h.html#35">size</a>, &amp;size_in_bytes) == <a href="../../../include/aws/common/error.h.html#15">AWS_OP_SUCCESS</a>);</div><div id="98" class="line none">   98     <a href="utils.c.html#36">save_byte_from_array</a>((uint8_t *)state, size_in_bytes, storage);</div><div id="99" class="line none">   99 }</div><div id="100" class="line none">  100 </div><div id="101" class="line none">  101 void <a href="utils.c.html#101">check_hash_table_unchanged</a>(const struct <a href="../../../include/aws/common/hash_table.h.html#48">aws_hash_table</a> *<a href="../../../include/aws/common/hash_table.h.html#75">map</a>, const struct <a href="../include/proof_helpers/utils.h.html#21">store_byte_from_buffer</a> *storage) {</div><div id="102" class="line none">  102     struct <a href="../../../include/aws/common/hash_table.h.html#47">hash_table_state</a> *state = <a href="../../../include/aws/common/hash_table.h.html#75">map</a>-&gt;<a href="../../../include/aws/common/hash_table.h.html#49">p_impl</a>;</div><div id="103" class="line none">  103     uint8_t *byte_array = (uint8_t *)state;</div><div id="104" class="line none">  104     assert(byte_array[storage-&gt;<a href="../include/proof_helpers/utils.h.html#22">index</a>] == storage-&gt;<a href="../include/proof_helpers/utils.h.html#23">byte</a>);</div><div id="105" class="line none">  105 }</div><div id="106" class="line none">  106 </div><div id="107" class="line none">  107 int <a href="utils.c.html#107">nondet_compare</a>(const void *const a, const void *const b) {</div><div id="108" class="line missed">  108     assert(a != NULL);</div><div id="109" class="line missed">  109     assert(b != NULL);</div><div id="110" class="line missed">  110     return <a href="../include/proof_helpers/nondet.h.html#16">nondet_int</a>();</div><div id="111" class="line missed">  111 }</div><div id="112" class="line none">  112 </div><div id="113" class="line none">  113 int <a href="utils.c.html#113">__CPROVER_uninterpreted_compare</a>(const void *const a, const void *const b);</div><div id="114" class="line none">  114 int <a href="utils.c.html#114">uninterpreted_compare</a>(const void *const a, const void *const b) {</div><div id="115" class="line none">  115     assert(a != NULL);</div><div id="116" class="line none">  116     assert(b != NULL);</div><div id="117" class="line none">  117     int rval = <a href="utils.c.html#113">__CPROVER_uninterpreted_compare</a>(a, b);</div><div id="118" class="line none">  118     /* Compare is reflexive */</div><div id="119" class="line none">  119     __CPROVER_assume(<a href="../include/proof_helpers/utils.h.html#19">IMPLIES</a>(a == b, rval == 0));</div><div id="120" class="line none">  120     /* Compare is anti-symmetric*/</div><div id="121" class="line none">  121     __CPROVER_assume(<a href="utils.c.html#113">__CPROVER_uninterpreted_compare</a>(b, a) == -rval);</div><div id="122" class="line none">  122     /* If two things are equal, their hashes are also equal */</div><div id="123" class="line none">  123     if (rval == 0) {</div><div id="124" class="line none">  124         __CPROVER_assume(<a href="../include/proof_helpers/utils.h.html#17">__CPROVER_uninterpreted_hasher</a>(a) == <a href="../include/proof_helpers/utils.h.html#17">__CPROVER_uninterpreted_hasher</a>(b));</div><div id="125" class="line none">  125     }</div><div id="126" class="line none">  126     return rval;</div><div id="127" class="line none">  127 }</div><div id="128" class="line none">  128 </div><div id="129" class="line none">  129 bool <a href="utils.c.html#129">nondet_equals</a>(const void *const a, const void *const b) {</div><div id="130" class="line none">  130     assert(a != NULL);</div><div id="131" class="line none">  131     assert(b != NULL);</div><div id="132" class="line none">  132     return <a href="../include/proof_helpers/nondet.h.html#15">nondet_bool</a>();</div><div id="133" class="line none">  133 }</div><div id="134" class="line none">  134 </div><div id="135" class="line none">  135 bool <a href="utils.c.html#135">__CPROVER_uninterpreted_equals</a>(const void *const a, const void *const b);</div><div id="136" class="line none">  136 uint64_t <a href="../include/proof_helpers/utils.h.html#17">__CPROVER_uninterpreted_hasher</a>(const void *const a);</div><div id="137" class="line none">  137 /**</div><div id="138" class="line none">  138  * Add assumptions that equality is reflexive and symmetric. Don't bother with</div><div id="139" class="line none">  139  * transitivity because it doesn't cause any spurious proof failures on hash-table</div><div id="140" class="line none">  140  */</div><div id="141" class="line none">  141 bool <a href="utils.c.html#141">uninterpreted_equals</a>(const void *const a, const void *const b) {</div><div id="142" class="line none">  142     bool rval = <a href="utils.c.html#135">__CPROVER_uninterpreted_equals</a>(a, b);</div><div id="143" class="line none">  143     /* Equals is reflexive */</div><div id="144" class="line none">  144     __CPROVER_assume(<a href="../include/proof_helpers/utils.h.html#19">IMPLIES</a>(a == b, rval));</div><div id="145" class="line none">  145     /* Equals is symmetric */</div><div id="146" class="line none">  146     __CPROVER_assume(<a href="utils.c.html#135">__CPROVER_uninterpreted_equals</a>(b, a) == rval);</div><div id="147" class="line none">  147     /* If two things are equal, their hashes are also equal */</div><div id="148" class="line none">  148     if (rval) {</div><div id="149" class="line none">  149         __CPROVER_assume(<a href="../include/proof_helpers/utils.h.html#17">__CPROVER_uninterpreted_hasher</a>(a) == <a href="../include/proof_helpers/utils.h.html#17">__CPROVER_uninterpreted_hasher</a>(b));</div><div id="150" class="line none">  150     }</div><div id="151" class="line none">  151     return rval;</div><div id="152" class="line none">  152 }</div><div id="153" class="line none">  153 </div><div id="154" class="line none">  154 bool <a href="utils.c.html#154">uninterpreted_equals_assert_inputs_nonnull</a>(const void *const a, const void *const b) {</div><div id="155" class="line none">  155     assert(a != NULL);</div><div id="156" class="line none">  156     assert(b != NULL);</div><div id="157" class="line none">  157     return <a href="utils.c.html#141">uninterpreted_equals</a>(a, b);</div><div id="158" class="line none">  158 }</div><div id="159" class="line none">  159 </div><div id="160" class="line none">  160 uint64_t <a href="utils.c.html#160">nondet_hasher</a>(const void *a) {</div><div id="161" class="line none">  161     assert(a != NULL);</div><div id="162" class="line none">  162     return <a href="../include/proof_helpers/nondet.h.html#20">nondet_uint64_t</a>();</div><div id="163" class="line none">  163 }</div><div id="164" class="line none">  164 </div><div id="165" class="line none">  165 /**</div><div id="166" class="line none">  166  * Standard stub function to hash one item.</div><div id="167" class="line none">  167  */</div><div id="168" class="line none">  168 uint64_t <a href="utils.c.html#168">uninterpreted_hasher</a>(const void *a) {</div><div id="169" class="line none">  169     assert(a != NULL);</div><div id="170" class="line none">  170     return <a href="../include/proof_helpers/utils.h.html#17">__CPROVER_uninterpreted_hasher</a>(a);</div><div id="171" class="line none">  171 }</div><div id="172" class="line none">  172 </div><div id="173" class="line none">  173 bool uninterpreted_predicate_fn(uint8_t <a href="../../../include/aws/common/atomics.h.html#17">value</a>);</div>
</div>
</body>
</html>
